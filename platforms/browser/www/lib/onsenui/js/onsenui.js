/*! onsenui v2.0.4 - 2016-11-18 */
if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/


/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
window.animit = (function(){
  'use strict';

  var TIMEOUT_RATIO = 1.4;

  var util = {
  };

  // capitalize string
  util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
  * @param {Object} params
  * @param {String} params.property
  * @param {Float} params.duration
  * @param {String} params.timing
  */
  util.buildTransitionValue = function(params) {
    params.property = params.property || 'all';
    params.duration = params.duration || 0.4;
    params.timing = params.timing || 'linear';

    var props = params.property.split(/ +/);

    return props.map(function(prop) {
      return prop + ' ' + params.duration + 's ' + params.timing;
    }).join(', ');
  };

  /**
  * Add an event handler on "transitionend" event.
  */
  util.onceOnTransitionEnd = function(element, callback) {
    if (!element) {
      return function() {};
    }

    var fn = function(event) {
      if (element == event.target) {
        event.stopPropagation();
        removeListeners();

        callback();
      }
    };

    var removeListeners = function() {
      util._transitionEndEvents.forEach(function(eventName) {
        element.removeEventListener(eventName, fn, false);
      });
    };

    util._transitionEndEvents.forEach(function(eventName) {
      element.addEventListener(eventName, fn, false);
    });

    return removeListeners;
  };

  util._transitionEndEvents = (function() {

    if ('ontransitionend' in window) {
      return ['transitionend'];
    }

    if ('onwebkittransitionend' in window) {
      return ['webkitTransitionEnd'];
    }

    if (util.vendorPrefix === 'webkit' || util.vendorPrefix === 'o' || util.vendorPrefix === 'moz' || util.vendorPrefix === 'ms') {
      return [util.vendorPrefix + 'TransitionEnd', 'transitionend'];
    }

    return [];
  })();

  util._cssPropertyDict = (function() {
    var styles = window.getComputedStyle(document.documentElement, '');
    var dict = {};
    var a = 'A'.charCodeAt(0);
    var z = 'z'.charCodeAt(0);

    var upper = function(s) {
      return s.substr(1).toUpperCase();
    };

    for (var i = 0; i < styles.length; i++) {

      var key = styles[i]
        .replace(/^[\-]+/, '')
        .replace(/[\-][a-z]/g, upper)
        .replace(/^moz/, 'Moz');

      if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
        if (key !== 'cssText' && key !== 'parentText') {
          dict[key] = true;
        }
      }
    }

    return dict;
  })();

  util.hasCssProperty = function(name) {
    return name in util._cssPropertyDict;
  };

  /**
   * Vendor prefix for css property.
   */
  util.vendorPrefix = (function() {
    var styles = window.getComputedStyle(document.documentElement, ''),
    pre = (Array.prototype.slice
      .call(styles)
      .join('')
      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
    )[1];
    return pre;
  })();

  util.forceLayoutAtOnce = function(elements, callback) {
    this.batchImmediate(function() {
      elements.forEach(function(element) {
        // force layout
        element.offsetHeight;
      });
      callback();
    });
  };

  util.batchImmediate = (function() {
    var callbacks = [];

    return function(callback) {
      if (callbacks.length === 0) {
        setImmediate(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.batchAnimationFrame = (function() {
    var callbacks = [];

    var raf = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      setTimeout(callback, 1000 / 60);
    };

    return function(callback) {
      if (callbacks.length === 0) {
        raf(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.transitionPropertyName = (function() {
    if (util.hasCssProperty('transitionDuration')) {
      return 'transition';
    }

    if (util.hasCssProperty(util.vendorPrefix + 'TransitionDuration')) {
      return util.vendorPrefix + 'Transition';
    }

    throw new Error('Invalid state');
  })();


  /**
   * @param {HTMLElement} element
   */
  var Animit = function(element) {
    if (!(this instanceof Animit)) {
      return new Animit(element);
    }

    if (element instanceof HTMLElement) {
      this.elements = [element];
    } else if (Object.prototype.toString.call(element) === '[object Array]') {
      this.elements = element;

    } else {
      throw new Error('First argument must be an array or an instance of HTMLElement.');
    }

    this.transitionQueue = [];
    this.lastStyleAttributeDict = [];
  };

  Animit.prototype = {

    /**
     * @property {Array}
     */
    transitionQueue: undefined,

    /**
     * @property {Array}
     */
    elements: undefined,

    /**
     * Start animation sequence with passed animations.
     *
     * @param {Function} callback
     */
    play: function(callback) {
      if (typeof callback === 'function') {
        this.transitionQueue.push(function(done) {
          callback();
          done();
        });
      }

      this.startAnimation();

      return this;
    },

    /**
     * Queue transition animations or other function.
     *
     * e.g. animit(elt).queue({color: 'red'})
     * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
     * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
     *
     * @param {Object|Animit.Transition|Function} transition
     * @param {Object} [options]
     */
    queue: function(transition, options) {
      var queue = this.transitionQueue;

      if (transition && options) {
        options.css = transition;
        transition = new Animit.Transition(options);
      }

      if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
        if (transition.css) {
          transition = new Animit.Transition(transition);
        } else {
          transition = new Animit.Transition({
            css: transition
          });
        }
      }

      if (transition instanceof Function) {
        queue.push(transition);
      } else if (transition instanceof Animit.Transition) {
        queue.push(transition.build());
      } else {
        throw new Error('Invalid arguments');
      }

      return this;
    },

    /**
     * Queue transition animations.
     *
     * @param {Float} seconds
     */
    wait: function(seconds) {
      if (seconds > 0) {
        this.transitionQueue.push(function(done) {
          setTimeout(done, 1000 * seconds);
        });
      }

      return this;
    },

    saveStyle: function() {

      this.transitionQueue.push(function(done) {
        this.elements.forEach(function(element, index) {
          var css = this.lastStyleAttributeDict[index] = {};

          for (var i = 0; i < element.style.length; i++) {
            css[element.style[i]] = element.style[element.style[i]];
          }
        }.bind(this));
        done();
      }.bind(this));

      return this;
    },

    /**
     * Restore element's style.
     *
     * @param {Object} [options]
     * @param {Float} [options.duration]
     * @param {String} [options.timing]
     * @param {String} [options.transition]
     */
    restoreStyle: function(options) {
      options = options || {};
      var self = this;

      if (options.transition && !options.duration) {
        throw new Error('"options.duration" is required when "options.transition" is enabled.');
      }

      var transitionName = util.transitionPropertyName;

      if (options.transition || (options.duration && options.duration > 0)) {
        var transitionValue = options.transition || ('all ' + options.duration + 's ' + (options.timing || 'linear'));

        this.transitionQueue.push(function(done) {
          var elements = this.elements;
          var timeoutId;

          var clearTransition = function() {
            elements.forEach(function(element) {
              element.style[transitionName] = '';
            });
          };

          // add "transitionend" event handler
          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            clearTransition();
            done();
          });

          // for fail safe.
          timeoutId = setTimeout(function() {
            removeListeners();
            clearTransition();
            done();
          }, options.duration * 1000 * TIMEOUT_RATIO);

          // transition and style settings
          elements.forEach(function(element, index) {

            var css = self.lastStyleAttributeDict[index];

            if (!css) {
              throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
            }

            self.lastStyleAttributeDict[index] = undefined;

            var name;
            for (var i = 0, len = element.style.length; i < len; i++) {
              name = element.style[i];
              if (css[name] === undefined) {
                css[name] = '';
              }
            }

            element.style[transitionName] = transitionValue;

            Object.keys(css).forEach(function(key) {
              if (key !== transitionName) {
                element.style[key] = css[key];
              }
            });

            element.style[transitionName] = transitionValue;
          });
        });
      } else {
        this.transitionQueue.push(function(done) {
          reset();
          done();
        });
      }

      return this;

      function reset() {
        // Clear transition animation settings.
        self.elements.forEach(function(element, index) {
          element.style[transitionName] = 'none';

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          for (var i = 0, name = ''; i < element.style.length; i++) {
            name = element.style[i];
            if (typeof css[element.style[i]] === 'undefined') {
              css[element.style[i]] = '';
            }
          }

          Object.keys(css).forEach(function(key) {
            element.style[key] = css[key];
          });

        });
      }
    },

    /**
     * Start animation sequence.
     */
    startAnimation: function() {
      this._dequeueTransition();

      return this;
    },

    _dequeueTransition: function() {
      var transition = this.transitionQueue.shift();
      if (this._currentTransition) {
        throw new Error('Current transition exists.');
      }
      this._currentTransition = transition;
      var self = this;
      var called = false;

      var done = function() {
        if (!called) {
          called = true;
          self._currentTransition = undefined;
          self._dequeueTransition();
        } else {
          throw new Error('Invalid state: This callback is called twice.');
        }
      };

      if (transition) {
        transition.call(this, done);
      }
    }

  };

  /**
   * @param {Animit} arguments
   */
  Animit.runAll = function(/* arguments... */) {
    for (var i = 0; i < arguments.length; i++) {
      arguments[i].play();
    }
  };


  /**
   * @param {Object} options
   * @param {Float} [options.duration]
   * @param {String} [options.property]
   * @param {String} [options.timing]
   */
  Animit.Transition = function(options) {
    this.options = options || {};
    this.options.duration = this.options.duration || 0;
    this.options.timing = this.options.timing || 'linear';
    this.options.css = this.options.css || {};
    this.options.property = this.options.property || 'all';
  };

  Animit.Transition.prototype = {

    /**
     * @param {HTMLElement} element
     * @return {Function}
     */
    build: function() {

      if (Object.keys(this.options.css).length === 0) {
        throw new Error('options.css is required.');
      }

      var css = createActualCssProps(this.options.css);

      if (this.options.duration > 0) {
        var transitionValue = util.buildTransitionValue(this.options);
        var self = this;

        return function(callback) {
          var elements = this.elements;
          var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
          var timeoutId;

          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            callback();
          });

          timeoutId = setTimeout(function() {
            removeListeners();
            callback();
          }, timeout);

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = transitionValue;

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

        };
      }

      if (this.options.duration <= 0) {
        return function(callback) {
          var elements = this.elements;

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = '';

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

          if (elements.length > 0) {
            util.forceLayoutAtOnce(elements, function() {
              util.batchAnimationFrame(callback);
            });
          } else {
            util.batchAnimationFrame(callback);
          }
        };
      }

      function createActualCssProps(css) {
        var result = {};

        Object.keys(css).forEach(function(name) {
          var value = css[name];

          if (util.hasCssProperty(name)) {
            result[name] = value;
            return;
          }

          var prefixed = util.vendorPrefix + util.capitalize(name);
          if (util.hasCssProperty(prefixed)) {
            result[prefixed] = value;
          } else {
            result[prefixed] = value;
            result[name] = value;
          }
        });

        return result;
      }

    }
  };


  return Animit;
})();

/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


/*!

Copyright (C) 2014-2016 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

if ('customElements' in window) {
  window.customElements.define = undefined;
}

(function(window){'use strict';

  // DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK
  // THIS IS A PROJECT BASED ON A BUILD SYSTEM
  // THIS FILE IS JUST WRAPPED UP RESULTING IN
  // build/document-register-element.js
  // and its .max.js counter part

  var
    document = window.document,
    Object = window.Object
  ;

  var htmlClass = (function (info) {
    // (C) Andrea Giammarchi - @WebReflection - MIT Style
    var
      catchClass = /^[A-Z]+[a-z]/,
      filterBy = function (re) {
        var arr = [], tag;
        for (tag in register) {
          if (re.test(tag)) arr.push(tag);
        }
        return arr;
      },
      add = function (Class, tag) {
        tag = tag.toLowerCase();
        if (!(tag in register)) {
          register[Class] = (register[Class] || []).concat(tag);
          register[tag] = (register[tag.toUpperCase()] = Class);
        }
      },
      register = (Object.create || Object)(null),
      htmlClass = {},
      i, section, tags, Class
    ;
    for (section in info) {
      for (Class in info[section]) {
        tags = info[section][Class];
        register[Class] = tags;
        for (i = 0; i < tags.length; i++) {
          register[tags[i].toLowerCase()] =
          register[tags[i].toUpperCase()] = Class;
        }
      }
    }
    htmlClass.get = function get(tagOrClass) {
      return typeof tagOrClass === 'string' ?
        (register[tagOrClass] || (catchClass.test(tagOrClass) ? [] : '')) :
        filterBy(tagOrClass);
    };
    htmlClass.set = function set(tag, Class) {
      return (catchClass.test(tag) ?
        add(tag, Class) :
        add(Class, tag)
      ), htmlClass;
    };
    return htmlClass;
  }({
    "collections": {
      "HTMLAllCollection": [
        "all"
      ],
      "HTMLCollection": [
        "forms"
      ],
      "HTMLFormControlsCollection": [
        "elements"
      ],
      "HTMLOptionsCollection": [
        "options"
      ]
    },
    "elements": {
      "Element": [
        "element"
      ],
      "HTMLAnchorElement": [
        "a"
      ],
      "HTMLAppletElement": [
        "applet"
      ],
      "HTMLAreaElement": [
        "area"
      ],
      "HTMLAttachmentElement": [
        "attachment"
      ],
      "HTMLAudioElement": [
        "audio"
      ],
      "HTMLBRElement": [
        "br"
      ],
      "HTMLBaseElement": [
        "base"
      ],
      "HTMLBodyElement": [
        "body"
      ],
      "HTMLButtonElement": [
        "button"
      ],
      "HTMLCanvasElement": [
        "canvas"
      ],
      "HTMLContentElement": [
        "content"
      ],
      "HTMLDListElement": [
        "dl"
      ],
      "HTMLDataElement": [
        "data"
      ],
      "HTMLDataListElement": [
        "datalist"
      ],
      "HTMLDetailsElement": [
        "details"
      ],
      "HTMLDialogElement": [
        "dialog"
      ],
      "HTMLDirectoryElement": [
        "dir"
      ],
      "HTMLDivElement": [
        "div"
      ],
      "HTMLDocument": [
        "document"
      ],
      "HTMLElement": [
        "element",
        "abbr",
        "address",
        "article",
        "aside",
        "b",
        "bdi",
        "bdo",
        "cite",
        "code",
        "command",
        "dd",
        "dfn",
        "dt",
        "em",
        "figcaption",
        "figure",
        "footer",
        "header",
        "i",
        "kbd",
        "mark",
        "nav",
        "noscript",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "small",
        "strong",
        "sub",
        "summary",
        "sup",
        "u",
        "var",
        "wbr"
      ],
      "HTMLEmbedElement": [
        "embed"
      ],
      "HTMLFieldSetElement": [
        "fieldset"
      ],
      "HTMLFontElement": [
        "font"
      ],
      "HTMLFormElement": [
        "form"
      ],
      "HTMLFrameElement": [
        "frame"
      ],
      "HTMLFrameSetElement": [
        "frameset"
      ],
      "HTMLHRElement": [
        "hr"
      ],
      "HTMLHeadElement": [
        "head"
      ],
      "HTMLHeadingElement": [
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
      ],
      "HTMLHtmlElement": [
        "html"
      ],
      "HTMLIFrameElement": [
        "iframe"
      ],
      "HTMLImageElement": [
        "img"
      ],
      "HTMLInputElement": [
        "input"
      ],
      "HTMLKeygenElement": [
        "keygen"
      ],
      "HTMLLIElement": [
        "li"
      ],
      "HTMLLabelElement": [
        "label"
      ],
      "HTMLLegendElement": [
        "legend"
      ],
      "HTMLLinkElement": [
        "link"
      ],
      "HTMLMapElement": [
        "map"
      ],
      "HTMLMarqueeElement": [
        "marquee"
      ],
      "HTMLMediaElement": [
        "media"
      ],
      "HTMLMenuElement": [
        "menu"
      ],
      "HTMLMenuItemElement": [
        "menuitem"
      ],
      "HTMLMetaElement": [
        "meta"
      ],
      "HTMLMeterElement": [
        "meter"
      ],
      "HTMLModElement": [
        "del",
        "ins"
      ],
      "HTMLOListElement": [
        "ol"
      ],
      "HTMLObjectElement": [
        "object"
      ],
      "HTMLOptGroupElement": [
        "optgroup"
      ],
      "HTMLOptionElement": [
        "option"
      ],
      "HTMLOutputElement": [
        "output"
      ],
      "HTMLParagraphElement": [
        "p"
      ],
      "HTMLParamElement": [
        "param"
      ],
      "HTMLPictureElement": [
        "picture"
      ],
      "HTMLPreElement": [
        "pre"
      ],
      "HTMLProgressElement": [
        "progress"
      ],
      "HTMLQuoteElement": [
        "blockquote",
        "q",
        "quote"
      ],
      "HTMLScriptElement": [
        "script"
      ],
      "HTMLSelectElement": [
        "select"
      ],
      "HTMLShadowElement": [
        "shadow"
      ],
      "HTMLSlotElement": [
        "slot"
      ],
      "HTMLSourceElement": [
        "source"
      ],
      "HTMLSpanElement": [
        "span"
      ],
      "HTMLStyleElement": [
        "style"
      ],
      "HTMLTableCaptionElement": [
        "caption"
      ],
      "HTMLTableCellElement": [
        "td",
        "th"
      ],
      "HTMLTableColElement": [
        "col",
        "colgroup"
      ],
      "HTMLTableElement": [
        "table"
      ],
      "HTMLTableRowElement": [
        "tr"
      ],
      "HTMLTableSectionElement": [
        "thead",
        "tbody",
        "tfoot"
      ],
      "HTMLTemplateElement": [
        "template"
      ],
      "HTMLTextAreaElement": [
        "textarea"
      ],
      "HTMLTimeElement": [
        "time"
      ],
      "HTMLTitleElement": [
        "title"
      ],
      "HTMLTrackElement": [
        "track"
      ],
      "HTMLUListElement": [
        "ul"
      ],
      "HTMLUnknownElement": [
        "unknown",
        "vhgroupv",
        "vkeygen"
      ],
      "HTMLVideoElement": [
        "video"
      ]
    },
    "nodes": {
      "Attr": [
        "node"
      ],
      "Audio": [
        "audio"
      ],
      "CDATASection": [
        "node"
      ],
      "CharacterData": [
        "node"
      ],
      "Comment": [
        "#comment"
      ],
      "Document": [
        "#document"
      ],
      "DocumentFragment": [
        "#document-fragment"
      ],
      "DocumentType": [
        "node"
      ],
      "HTMLDocument": [
        "#document"
      ],
      "Image": [
        "img"
      ],
      "Option": [
        "option"
      ],
      "ProcessingInstruction": [
        "node"
      ],
      "ShadowRoot": [
        "#shadow-root"
      ],
      "Text": [
        "#text"
      ],
      "XMLDocument": [
        "xml"
      ]
    }
  }));
  
  
    var
    // V0 polyfill entry
    REGISTER_ELEMENT = 'registerElement',
  
    // IE < 11 only + old WebKit for attributes + feature detection
    EXPANDO_UID = '__' + REGISTER_ELEMENT + (window.Math.random() * 10e4 >> 0),
  
    // shortcuts and costants
    ADD_EVENT_LISTENER = 'addEventListener',
    ATTACHED = 'attached',
    CALLBACK = 'Callback',
    DETACHED = 'detached',
    EXTENDS = 'extends',
  
    ATTRIBUTE_CHANGED_CALLBACK = 'attributeChanged' + CALLBACK,
    ATTACHED_CALLBACK = ATTACHED + CALLBACK,
    CONNECTED_CALLBACK = 'connected' + CALLBACK,
    DISCONNECTED_CALLBACK = 'disconnected' + CALLBACK,
    CREATED_CALLBACK = 'created' + CALLBACK,
    DETACHED_CALLBACK = DETACHED + CALLBACK,
  
    ADDITION = 'ADDITION',
    MODIFICATION = 'MODIFICATION',
    REMOVAL = 'REMOVAL',
  
    DOM_ATTR_MODIFIED = 'DOMAttrModified',
    DOM_CONTENT_LOADED = 'DOMContentLoaded',
    DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',
  
    PREFIX_TAG = '<',
    PREFIX_IS = '=',
  
    // valid and invalid node names
    validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,
    invalidNames = [
      'ANNOTATION-XML',
      'COLOR-PROFILE',
      'FONT-FACE',
      'FONT-FACE-SRC',
      'FONT-FACE-URI',
      'FONT-FACE-FORMAT',
      'FONT-FACE-NAME',
      'MISSING-GLYPH'
    ],
  
    // registered types and their prototypes
    types = [],
    protos = [],
  
    // to query subnodes
    query = '',
  
    // html shortcut used to feature detect
    documentElement = document.documentElement,
  
    // ES5 inline helpers || basic patches
    indexOf = types.indexOf || function (v) {
      for(var i = this.length; i-- && this[i] !== v;){}
      return i;
    },
  
    // other helpers / shortcuts
    OP = Object.prototype,
    hOP = OP.hasOwnProperty,
    iPO = OP.isPrototypeOf,
  
    defineProperty = Object.defineProperty,
    empty = [],
    gOPD = Object.getOwnPropertyDescriptor,
    gOPN = Object.getOwnPropertyNames,
    gPO = Object.getPrototypeOf,
    sPO = Object.setPrototypeOf,
  
    // jshint proto: true
    hasProto = !!Object.__proto__,
  
    // V1 helpers
    fixGetClass = false,
    DRECEV1 = '__dreCEv1',
    customElements = window.customElements,
    usableCustomElements = !!(
      customElements &&
      customElements.define &&
      customElements.get &&
      customElements.whenDefined
    ),
    Dict = Object.create || Object,
    Map = window.Map || function Map() {
      var K = [], V = [], i;
      return {
        get: function (k) {
          return V[indexOf.call(K, k)];
        },
        set: function (k, v) {
          i = indexOf.call(K, k);
          if (i < 0) V[K.push(k) - 1] = v;
          else V[i] = v;
        }
      };
    },
    Promise = window.Promise || function (fn) {
      var
        notify = [],
        done = false,
        p = {
          'catch': function () {
            return p;
          },
          'then': function (cb) {
            notify.push(cb);
            if (done) setTimeout(resolve, 1);
            return p;
          }
        }
      ;
      function resolve(value) {
        done = true;
        while (notify.length) notify.shift()(value);
      }
      fn(resolve);
      return p;
    },
    justCreated = false,
    constructors = Dict(null),
    waitingList = Dict(null),
    nodeNames = new Map(),
    secondArgument = String,
  
    // used to create unique instances
    create = Object.create || function Bridge(proto) {
      // silly broken polyfill probably ever used but short enough to work
      return proto ? ((Bridge.prototype = proto), new Bridge()) : this;
    },
  
    // will set the prototype if possible
    // or copy over all properties
    setPrototype = sPO || (
      hasProto ?
        function (o, p) {
          o.__proto__ = p;
          return o;
        } : (
      (gOPN && gOPD) ?
        (function(){
          function setProperties(o, p) {
            for (var
              key,
              names = gOPN(p),
              i = 0, length = names.length;
              i < length; i++
            ) {
              key = names[i];
              if (!hOP.call(o, key)) {
                defineProperty(o, key, gOPD(p, key));
              }
            }
          }
          return function (o, p) {
            do {
              setProperties(o, p);
            } while ((p = gPO(p)) && !iPO.call(p, o));
            return o;
          };
        }()) :
        function (o, p) {
          for (var key in p) {
            o[key] = p[key];
          }
          return o;
        }
    )),
  
    // DOM shortcuts and helpers, if any
  
    MutationObserver = window.MutationObserver ||
                       window.WebKitMutationObserver,
  
    HTMLElementPrototype = (
      window.HTMLElement ||
      window.Element ||
      window.Node
    ).prototype,
  
    IE8 = !iPO.call(HTMLElementPrototype, documentElement),
  
    safeProperty = IE8 ? function (o, k, d) {
      o[k] = d.value;
      return o;
    } : defineProperty,
  
    isValidNode = IE8 ?
      function (node) {
        return node.nodeType === 1;
      } :
      function (node) {
        return iPO.call(HTMLElementPrototype, node);
      },
  
    targets = IE8 && [],
  
    attachShadow = HTMLElementPrototype.attachShadow,
    cloneNode = HTMLElementPrototype.cloneNode,
    dispatchEvent = HTMLElementPrototype.dispatchEvent,
    getAttribute = HTMLElementPrototype.getAttribute,
    hasAttribute = HTMLElementPrototype.hasAttribute,
    removeAttribute = HTMLElementPrototype.removeAttribute,
    setAttribute = HTMLElementPrototype.setAttribute,
  
    // replaced later on
    createElement = document.createElement,
    patchedCreateElement = createElement,
  
    // shared observer for all attributes
    attributesObserver = MutationObserver && {
      attributes: true,
      characterData: true,
      attributeOldValue: true
    },
  
    // useful to detect only if there's no MutationObserver
    DOMAttrModified = MutationObserver || function(e) {
      doesNotSupportDOMAttrModified = false;
      documentElement.removeEventListener(
        DOM_ATTR_MODIFIED,
        DOMAttrModified
      );
    },
  
    // will both be used to make DOMNodeInserted asynchronous
    asapQueue,
    asapTimer = 0,
  
    // internal flags
    setListener = false,
    doesNotSupportDOMAttrModified = true,
    dropDomContentLoaded = true,
  
    // needed for the innerHTML helper
    notFromInnerHTMLHelper = true,
  
    // optionally defined later on
    onSubtreeModified,
    callDOMAttrModified,
    getAttributesMirror,
    observer,
    observe,
  
    // based on setting prototype capability
    // will check proto or the expando attribute
    // in order to setup the node once
    patchIfNotAlready,
    patch
  ;
  
  // only if needed
  if (!(REGISTER_ELEMENT in document)) {
  
    if (sPO || hasProto) {
        patchIfNotAlready = function (node, proto) {
          if (!iPO.call(proto, node)) {
            setupNode(node, proto);
          }
        };
        patch = setupNode;
    } else {
        patchIfNotAlready = function (node, proto) {
          if (!node[EXPANDO_UID]) {
            node[EXPANDO_UID] = Object(true);
            setupNode(node, proto);
          }
        };
        patch = patchIfNotAlready;
    }
  
    if (IE8) {
      doesNotSupportDOMAttrModified = false;
      (function (){
        var
          descriptor = gOPD(HTMLElementPrototype, ADD_EVENT_LISTENER),
          addEventListener = descriptor.value,
          patchedRemoveAttribute = function (name) {
            var e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
            e.attrName = name;
            e.prevValue = getAttribute.call(this, name);
            e.newValue = null;
            e[REMOVAL] = e.attrChange = 2;
            removeAttribute.call(this, name);
            dispatchEvent.call(this, e);
          },
          patchedSetAttribute = function (name, value) {
            var
              had = hasAttribute.call(this, name),
              old = had && getAttribute.call(this, name),
              e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true})
            ;
            setAttribute.call(this, name, value);
            e.attrName = name;
            e.prevValue = had ? old : null;
            e.newValue = value;
            if (had) {
              e[MODIFICATION] = e.attrChange = 1;
            } else {
              e[ADDITION] = e.attrChange = 0;
            }
            dispatchEvent.call(this, e);
          },
          onPropertyChange = function (e) {
            // jshint eqnull:true
            var
              node = e.currentTarget,
              superSecret = node[EXPANDO_UID],
              propertyName = e.propertyName,
              event
            ;
            if (superSecret.hasOwnProperty(propertyName)) {
              superSecret = superSecret[propertyName];
              event = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
              event.attrName = superSecret.name;
              event.prevValue = superSecret.value || null;
              event.newValue = (superSecret.value = node[propertyName] || null);
              if (event.prevValue == null) {
                event[ADDITION] = event.attrChange = 0;
              } else {
                event[MODIFICATION] = event.attrChange = 1;
              }
              dispatchEvent.call(node, event);
            }
          }
        ;
        descriptor.value = function (type, handler, capture) {
          if (
            type === DOM_ATTR_MODIFIED &&
            this[ATTRIBUTE_CHANGED_CALLBACK] &&
            this.setAttribute !== patchedSetAttribute
          ) {
            this[EXPANDO_UID] = {
              className: {
                name: 'class',
                value: this.className
              }
            };
            this.setAttribute = patchedSetAttribute;
            this.removeAttribute = patchedRemoveAttribute;
            addEventListener.call(this, 'propertychange', onPropertyChange);
          }
          addEventListener.call(this, type, handler, capture);
        };
        defineProperty(HTMLElementPrototype, ADD_EVENT_LISTENER, descriptor);
      }());
    } else if (!MutationObserver) {
      documentElement[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, DOMAttrModified);
      documentElement.setAttribute(EXPANDO_UID, 1);
      documentElement.removeAttribute(EXPANDO_UID);
      if (doesNotSupportDOMAttrModified) {
        onSubtreeModified = function (e) {
          var
            node = this,
            oldAttributes,
            newAttributes,
            key
          ;
          if (node === e.target) {
            oldAttributes = node[EXPANDO_UID];
            node[EXPANDO_UID] = (newAttributes = getAttributesMirror(node));
            for (key in newAttributes) {
              if (!(key in oldAttributes)) {
                // attribute was added
                return callDOMAttrModified(
                  0,
                  node,
                  key,
                  oldAttributes[key],
                  newAttributes[key],
                  ADDITION
                );
              } else if (newAttributes[key] !== oldAttributes[key]) {
                // attribute was changed
                return callDOMAttrModified(
                  1,
                  node,
                  key,
                  oldAttributes[key],
                  newAttributes[key],
                  MODIFICATION
                );
              }
            }
            // checking if it has been removed
            for (key in oldAttributes) {
              if (!(key in newAttributes)) {
                // attribute removed
                return callDOMAttrModified(
                  2,
                  node,
                  key,
                  oldAttributes[key],
                  newAttributes[key],
                  REMOVAL
                );
              }
            }
          }
        };
        callDOMAttrModified = function (
          attrChange,
          currentTarget,
          attrName,
          prevValue,
          newValue,
          action
        ) {
          var e = {
            attrChange: attrChange,
            currentTarget: currentTarget,
            attrName: attrName,
            prevValue: prevValue,
            newValue: newValue
          };
          e[action] = attrChange;
          onDOMAttrModified(e);
        };
        getAttributesMirror = function (node) {
          for (var
            attr, name,
            result = {},
            attributes = node.attributes,
            i = 0, length = attributes.length;
            i < length; i++
          ) {
            attr = attributes[i];
            name = attr.name;
            if (name !== 'setAttribute') {
              result[name] = attr.value;
            }
          }
          return result;
        };
      }
    }
  
    // set as enumerable, writable and configurable
    document[REGISTER_ELEMENT] = function registerElement(type, options) {
      upperType = type.toUpperCase();
      if (!setListener) {
        // only first time document.registerElement is used
        // we need to set this listener
        // setting it by default might slow down for no reason
        setListener = true;
        if (MutationObserver) {
          observer = (function(attached, detached){
            function checkEmAll(list, callback) {
              for (var i = 0, length = list.length; i < length; callback(list[i++])){}
            }
            return new MutationObserver(function (records) {
              for (var
                current, node, newValue,
                i = 0, length = records.length; i < length; i++
              ) {
                current = records[i];
                if (current.type === 'childList') {
                  checkEmAll(current.addedNodes, attached);
                  checkEmAll(current.removedNodes, detached);
                } else {
                  node = current.target;
                  if (notFromInnerHTMLHelper &&
                      node[ATTRIBUTE_CHANGED_CALLBACK] &&
                      current.attributeName !== 'style') {
                    newValue = getAttribute.call(node, current.attributeName);
                    if (newValue !== current.oldValue) {
                      node[ATTRIBUTE_CHANGED_CALLBACK](
                        current.attributeName,
                        current.oldValue,
                        newValue
                      );
                    }
                  }
                }
              }
            });
          }(executeAction(ATTACHED), executeAction(DETACHED)));
          observe = function (node) {
            observer.observe(
              node,
              {
                childList: true,
                subtree: true
              }
            );
            return node;
          };
          observe(document);
          if (attachShadow) {
            HTMLElementPrototype.attachShadow = function () {
              return observe(attachShadow.apply(this, arguments));
            };
          }
        } else {
          asapQueue = [];
          document[ADD_EVENT_LISTENER]('DOMNodeInserted', onDOMNode(ATTACHED));
          document[ADD_EVENT_LISTENER]('DOMNodeRemoved', onDOMNode(DETACHED));
        }
  
        document[ADD_EVENT_LISTENER](DOM_CONTENT_LOADED, onReadyStateChange);
        document[ADD_EVENT_LISTENER]('readystatechange', onReadyStateChange);
  
        HTMLElementPrototype.cloneNode = function (deep) {
          var
            node = cloneNode.call(this, !!deep),
            i = getTypeIndex(node)
          ;
          if (-1 < i) patch(node, protos[i]);
          if (deep) loopAndSetup(node.querySelectorAll(query));
          return node;
        };
      }
  
      if (-2 < (
        indexOf.call(types, PREFIX_IS + upperType) +
        indexOf.call(types, PREFIX_TAG + upperType)
      )) {
        throwTypeError(type);
      }
  
      if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {
        throw new Error('The type ' + type + ' is invalid');
      }
  
      var
        constructor = function () {
          return extending ?
            document.createElement(nodeName, upperType) :
            document.createElement(nodeName);
        },
        opt = options || OP,
        extending = hOP.call(opt, EXTENDS),
        nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,
        upperType,
        i
      ;
  
      if (extending && -1 < (
        indexOf.call(types, PREFIX_TAG + nodeName)
      )) {
        throwTypeError(nodeName);
      }
  
      i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1;
  
      query = query.concat(
        query.length ? ',' : '',
        extending ? nodeName + '[is="' + type.toLowerCase() + '"]' : nodeName
      );
  
      constructor.prototype = (
        protos[i] = hOP.call(opt, 'prototype') ?
          opt.prototype :
          create(HTMLElementPrototype)
      );
  
      loopAndVerify(
        document.querySelectorAll(query),
        ATTACHED
      );
  
      return constructor;
    };
  
    document.createElement = (patchedCreateElement = function (localName, typeExtension) {
      var
        is = getIs(typeExtension),
        node = is ?
          createElement.call(document, localName, secondArgument(is)) :
          createElement.call(document, localName),
        name = '' + localName,
        i = indexOf.call(
          types,
          (is ? PREFIX_IS : PREFIX_TAG) +
          (is || name).toUpperCase()
        ),
        setup = -1 < i
      ;
      if (is) {
        node.setAttribute('is', is = is.toLowerCase());
        if (setup) {
          setup = isInQSA(name.toUpperCase(), is);
        }
      }
      notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;
      if (setup) patch(node, protos[i]);
      return node;
    });
  
  }
  
  function ASAP() {
    var queue = asapQueue.splice(0, asapQueue.length);
    asapTimer = 0;
    while (queue.length) {
      queue.shift().call(
        null, queue.shift()
      );
    }
  }
  
  function loopAndVerify(list, action) {
    for (var i = 0, length = list.length; i < length; i++) {
      verifyAndSetupAndAction(list[i], action);
    }
  }
  
  function loopAndSetup(list) {
    for (var i = 0, length = list.length, node; i < length; i++) {
      node = list[i];
      patch(node, protos[getTypeIndex(node)]);
    }
  }
  
  function executeAction(action) {
    return function (node) {
      if (isValidNode(node)) {
        verifyAndSetupAndAction(node, action);
        loopAndVerify(
          node.querySelectorAll(query),
          action
        );
      }
    };
  }
  
  function getTypeIndex(target) {
    var
      is = getAttribute.call(target, 'is'),
      nodeName = target.nodeName.toUpperCase(),
      i = indexOf.call(
        types,
        is ?
            PREFIX_IS + is.toUpperCase() :
            PREFIX_TAG + nodeName
      )
    ;
    return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;
  }
  
  function isInQSA(name, type) {
    return -1 < query.indexOf(name + '[is="' + type + '"]');
  }
  
  function onDOMAttrModified(e) {
    var
      node = e.currentTarget,
      attrChange = e.attrChange,
      attrName = e.attrName,
      target = e.target,
      addition = e[ADDITION] || 2,
      removal = e[REMOVAL] || 3
    ;
    if (notFromInnerHTMLHelper &&
        (!target || target === node) &&
        node[ATTRIBUTE_CHANGED_CALLBACK] &&
        attrName !== 'style' && (
          e.prevValue !== e.newValue ||
          // IE9, IE10, and Opera 12 gotcha
          e.newValue === '' && (
            attrChange === addition ||
            attrChange === removal
          )
    )) {
      node[ATTRIBUTE_CHANGED_CALLBACK](
        attrName,
        attrChange === addition ? null : e.prevValue,
        attrChange === removal ? null : e.newValue
      );
    }
  }
  
  function onDOMNode(action) {
    var executor = executeAction(action);
    return function (e) {
      asapQueue.push(executor, e.target);
      if (asapTimer) clearTimeout(asapTimer);
      asapTimer = setTimeout(ASAP, 1);
    };
  }
  
  function onReadyStateChange(e) {
    if (dropDomContentLoaded) {
      dropDomContentLoaded = false;
      e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);
    }
    loopAndVerify(
      (e.target || document).querySelectorAll(query),
      e.detail === DETACHED ? DETACHED : ATTACHED
    );
    if (IE8) purge();
  }
  
  function patchedSetAttribute(name, value) {
    // jshint validthis:true
    var self = this;
    setAttribute.call(self, name, value);
    onSubtreeModified.call(self, {target: self});
  }
  
  function setupNode(node, proto) {
    setPrototype(node, proto);
    if (observer) {
      observer.observe(node, attributesObserver);
    } else {
      if (doesNotSupportDOMAttrModified) {
        node.setAttribute = patchedSetAttribute;
        node[EXPANDO_UID] = getAttributesMirror(node);
        node[ADD_EVENT_LISTENER](DOM_SUBTREE_MODIFIED, onSubtreeModified);
      }
      node[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, onDOMAttrModified);
    }
    if (node[CREATED_CALLBACK] && notFromInnerHTMLHelper) {
      node.created = true;
      node[CREATED_CALLBACK]();
      node.created = false;
    }
  }
  
  function purge() {
    for (var
      node,
      i = 0,
      length = targets.length;
      i < length; i++
    ) {
      node = targets[i];
      if (!documentElement.contains(node)) {
        length--;
        targets.splice(i--, 1);
        verifyAndSetupAndAction(node, DETACHED);
      }
    }
  }
  
  function throwTypeError(type) {
    throw new Error('A ' + type + ' type is already registered');
  }
  
  function verifyAndSetupAndAction(node, action) {
    var
      fn,
      i = getTypeIndex(node)
    ;
    if (-1 < i) {
      patchIfNotAlready(node, protos[i]);
      i = 0;
      if (action === ATTACHED && !node[ATTACHED]) {
        node[DETACHED] = false;
        node[ATTACHED] = true;
        i = 1;
        if (IE8 && indexOf.call(targets, node) < 0) {
          targets.push(node);
        }
      } else if (action === DETACHED && !node[DETACHED]) {
        node[ATTACHED] = false;
        node[DETACHED] = true;
        i = 1;
      }
      if (i && (fn = node[action + CALLBACK])) fn.call(node);
    }
  }
  
  
  
  // V1 in da House!
  function CustomElementRegistry() {}
  
  CustomElementRegistry.prototype = {
    constructor: CustomElementRegistry,
    // a workaround for the stubborn WebKit
    define: usableCustomElements ?
      function (name, Class, options) {
        if (options) {
          CERDefine(name, Class, options);
        } else {
          var NAME = name.toUpperCase();
          constructors[NAME] = {
            constructor: Class,
            create: [NAME]
          };
          nodeNames.set(Class, NAME);
          customElements.define(name, Class);
        }
      } :
      CERDefine,
    get: usableCustomElements ?
      function (name) {
        return customElements.get(name) || get(name);
      } :
      get,
    whenDefined: usableCustomElements ?
      function (name) {
        return Promise.race([
          customElements.whenDefined(name),
          whenDefined(name)
        ]);
      } :
      whenDefined
  };
  
  function CERDefine(name, Class, options) {
    var
      is = options && options[EXTENDS] || '',
      CProto = Class.prototype,
      proto = create(CProto),
      attributes = Class.observedAttributes || empty,
      definition = {prototype: proto}
    ;
    // TODO: is this needed at all since it's inherited?
    // defineProperty(proto, 'constructor', {value: Class});
    safeProperty(proto, CREATED_CALLBACK, {
        value: function () {
          if (justCreated) justCreated = false;
          else if (!this[DRECEV1]) {
            this[DRECEV1] = true;
            new Class(this);
            if (CProto[CREATED_CALLBACK])
              CProto[CREATED_CALLBACK].call(this);
            var info = constructors[nodeNames.get(Class)];
            if (!usableCustomElements || info.create.length > 1) {
              notifyAttributes(this);
            }
          }
      }
    });
    safeProperty(proto, ATTRIBUTE_CHANGED_CALLBACK, {
      value: function (name) {
        if (-1 < indexOf.call(attributes, name))
          CProto[ATTRIBUTE_CHANGED_CALLBACK].apply(this, arguments);
      }
    });
    if (CProto[CONNECTED_CALLBACK]) {
      safeProperty(proto, ATTACHED_CALLBACK, {
        value: CProto[CONNECTED_CALLBACK]
      });
    }
    if (CProto[DISCONNECTED_CALLBACK]) {
      safeProperty(proto, DETACHED_CALLBACK, {
        value: CProto[DISCONNECTED_CALLBACK]
      });
    }
    if (is) definition[EXTENDS] = is;
    name = name.toUpperCase();
    constructors[name] = {
      constructor: Class,
      create: is ? [is, secondArgument(name)] : [name]
    };
    nodeNames.set(Class, name);
    document[REGISTER_ELEMENT](name.toLowerCase(), definition);
    whenDefined(name);
    waitingList[name].r();
  }
  
  function get(name) {
    var info = constructors[name.toUpperCase()];
    return info && info.constructor;
  }
  
  function getIs(options) {
    return typeof options === 'string' ?
        options : (options && options.is || '');
  }
  
  function notifyAttributes(self) {
    var
      callback = self[ATTRIBUTE_CHANGED_CALLBACK],
      attributes = callback ? self.attributes : empty,
      i = attributes.length,
      attribute
    ;
    while (i--) {
      attribute =  attributes[i]; // || attributes.item(i);
      callback.call(
        self,
        attribute.name || attribute.nodeName,
        null,
        attribute.value || attribute.nodeValue
      );
    }
  }
  
  function whenDefined(name) {
    name = name.toUpperCase();
    if (!(name in waitingList)) {
      waitingList[name] = {};
      waitingList[name].p = new Promise(function (resolve) {
        waitingList[name].r = resolve;
      });
    }
    return waitingList[name].p;
  }
  
  function polyfillV1() {
    if (customElements) delete window.customElements;
    defineProperty(window, 'customElements', {
      configurable: true,
      value: new CustomElementRegistry()
    });
    defineProperty(window, 'CustomElementRegistry', {
      configurable: true,
      value: CustomElementRegistry
    });
    for (var
      patchClass = function (name) {
        var Class = window[name];
        if (Class) {
          window[name] = function CustomElementsV1(self) {
            var info, isNative;
            if (!self) self = this;
            if (!self[DRECEV1]) {
              justCreated = true;
              info = constructors[nodeNames.get(self.constructor)];
              isNative = usableCustomElements && info.create.length === 1;
              self = isNative ?
                Reflect.construct(Class, empty, info.constructor) :
                document.createElement.apply(document, info.create);
              self[DRECEV1] = true;
              justCreated = false;
              if (!isNative) notifyAttributes(self);
            }
            return self;
          };
          window[name].prototype = Class.prototype;
          try {
            Class.prototype.constructor = window[name];
          } catch(WebKit) {
            fixGetClass = true;
            defineProperty(Class, DRECEV1, {value: window[name]});
          }
        }
      },
      Classes = htmlClass.get(/^HTML[A-Z]*[a-z]/),
      i = Classes.length;
      i--;
      patchClass(Classes[i])
    ) {}
    (document.createElement = function (name, options) {
      var is = getIs(options);
      return is ?
        patchedCreateElement.call(this, name, secondArgument(is)) :
        patchedCreateElement.call(this, name);
    });
  }
  
  // if customElements is not there at all
  if (!customElements) polyfillV1();
  else {
    // if available test extends work as expected
    try {
      (function (DRE, options, name) {
        options[EXTENDS] = 'a';
        DRE.prototype = create(HTMLAnchorElement.prototype);
        DRE.prototype.constructor = DRE;
        window.customElements.define(name, DRE, options);
        if (
          getAttribute.call(document.createElement('a', {is: name}), 'is') !== name ||
          (usableCustomElements && getAttribute.call(new DRE(), 'is') !== name)
        ) {
          throw options;
        }
      }(
        function DRE() {
          return Reflect.construct(HTMLAnchorElement, [], DRE);
        },
        {},
        'document-register-element-a'
      ));
    } catch(o_O) {
      // or force the polyfill if not
      // and keep internal original reference
      polyfillV1();
    }
  }
  
  try {
    createElement.call(document, 'a', 'a');
  } catch(FireFox) {
    secondArgument = function (is) {
      return {is: is};
    };
  }
  
}(window));

;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		// Ignore touches on contenteditable elements to prevent conflict with text selection.
		// (For details: https://github.com/ftlabs/fastclick/pull/211 )
		if (targetElement.isContentEditable) {
			return true;
		}

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

// see https://github.com/WebReflection/document-register-element/issues/21#issuecomment-102020311
var innerHTML = (function (document) {

  var
    EXTENDS = 'extends',
    register = document.registerElement,
    div = document.createElement('div'),
    dre = 'document-register-element',
    innerHTML = register.innerHTML,
    initialize,
    registered
  ;

  // avoid duplicated wrappers
  if (innerHTML) return innerHTML;

  try {

    // feature detect the problem
    register.call(
      document,
      dre,
      {prototype: Object.create(
        HTMLElement.prototype,
        {createdCallback: {value: Object}}
      )}
    );

    div.innerHTML = '<' + dre + '></' + dre + '>';

    // if natively supported, nothing to do
    if ('createdCallback' in div.querySelector(dre)) {
      // return just an innerHTML wrap
      return (register.innerHTML = function (el, html) {
        el.innerHTML = html;
        return el;
      });
    }

  } catch(meh) {}

  // in other cases
  registered = [];
  initialize = function (el) {
    if (
      'createdCallback' in el         ||
      'attachedCallback' in el        ||
      'detachedCallback' in el        ||
      'attributeChangedCallback' in el
    ) return;
    document.createElement.innerHTMLHelper = true;
    for (var
      parentNode = el.parentNode,
      type = el.getAttribute('is'),
      name = el.nodeName,
      node = document.createElement.apply(
        document,
        type ? [name, type] : [name]
      ),
      attributes = el.attributes,
      i = 0,
      length = attributes.length,
      attr, fc;
      i < length; i++
    ) {
      attr = attributes[i];
      node.setAttribute(attr.name, attr.value);
    }
    if (node.createdCallback) {
      node.created = true;
      node.createdCallback();
      node.created = false;
    }
    while ((fc = el.firstChild)) node.appendChild(fc);
    document.createElement.innerHTMLHelper = false;
    if (parentNode) parentNode.replaceChild(node, el);
  };
  // augment the document.registerElement method
  return ((document.registerElement = function registerElement(type, options) {
    var name = (options[EXTENDS] ?
      (options[EXTENDS] + '[is="' + type + '"]') : type
    ).toLowerCase();
    if (registered.indexOf(name) < 0) registered.push(name);
    return register.apply(document, arguments);
  }).innerHTML = function (el, html) {
    el.innerHTML = html;
    for (var
      nodes = el.querySelectorAll(registered.join(',')),
      i = nodes.length; i--; initialize(nodes[i])
    ) {}
    return el;
  });
}(document));
/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;

    this._events[event] = this._events[event]
      .filter(function(_fct) {
        if (fct) {
           return fct !== _fct;
        }
        else {
          return false;
        }
      });
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (!window.Promise) {
    window.Promise = Promise;
  }
})(this);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   (global.ons = factory());
}(this, (function () { 'use strict';

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var unwrap = function unwrap(string) {
  return string.slice(1, -1);
};
var isObjectString = function isObjectString(string) {
  return string.startsWith('{') && string.endsWith('}');
};
var isArrayString = function isArrayString(string) {
  return string.startsWith('[') && string.endsWith(']');
};
var isQuotedString = function isQuotedString(string) {
  return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
};

var error$1 = function error$1(token, string, originalString) {
  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
};

var processToken = function processToken(token, string, originalString) {
  if (token === 'true' || token === 'false') {
    return token === 'true';
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error$1(token, string, originalString);
  }
};

var nextToken = function nextToken(string) {
  string = string.trimLeft();
  var limit = string.length;

  if (string[0] === ':' || string[0] === ',') {

    limit = 1;
  } else if (string[0] === '{' || string[0] === '[') {

    var c = string.charCodeAt(0);
    var nestedObject = 1;
    for (var i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === '\'' || string[0] === '\"') {

    for (var _i = 1; _i < string.length; _i++) {
      if (string[_i] === string[0]) {
        limit = _i + 1;
        break;
      }
    }
  } else {

    for (var _i2 = 1; _i2 < string.length; _i2++) {
      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
        limit = _i2;
        break;
      }
    }
  }

  return string.slice(0, limit);
};

var parseObject = function parseObject(string) {
  var isValidKey = function isValidKey(key) {
    return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
    );
  };

  string = string.trim();
  var originalString = string;
  var object = {};
  var readingKey = true,
      key = void 0,
      previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trimLeft();

    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
      error$1(token, string, originalString);
    } else if (token === ':' && readingKey && previousToken) {
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
      }
    } else if (token === ',' && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }

  if (token) {
    object[key] = processToken(token, string, originalString);
  }

  return object;
};

var parseArray = function parseArray(string) {
  string = string.trim();
  var originalString = string;
  var array = [];
  var previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trimLeft();

    if (token === ',' && (!previousToken || previousToken === ',')) {
      error$1(token, string, originalString);
    } else if (token === ',') {
      array.push(processToken(previousToken, string, originalString));
    }
  }

  if (token) {
    if (token !== ',') {
      array.push(processToken(token, string, originalString));
    } else {
      error$1(token, string, originalString);
    }
  }

  return array;
};

var parse = function parse(string) {
  string = string.trim();

  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error('Provided string must be object or array like: ' + string);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util = {};

/**
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {Function}
 */
util.prepareQuery = function (query) {
  return query instanceof Function ? query : function (element) {
    return util.match(element, query);
  };
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name.
 * @return {Boolean}
 */
util.match = function (element, query) {
  if (query[0] === '.') {
    return element.classList.contains(query.slice(1));
  }
  return element.nodeName.toLowerCase() === query;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findChild = function (element, query) {
  var match = util.prepareQuery(query);

  for (var i = 0; i < element.children.length; i++) {
    var node = element.children[i];
    if (match(node)) {
      return node;
    }
  }
  return null;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findParent = function (element, query) {
  var match = util.prepareQuery(query);

  var parent = element.parentNode;
  for (;;) {
    if (!parent || parent === document) {
      return null;
    }
    if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.isAttached = function (element) {
  while (document.documentElement !== element) {
    if (!element) {
      return false;
    }
    element = element.parentNode;
  }
  return true;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.hasAnyComponentAsParent = function (element) {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal|ons-sliding-menu|ons-split-view)/)) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Element} element
 * @param {String} action to propagate
 */
util.propagateAction = function (element, action) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util.propagateAction(child, action);
    }
  }
};

/**
 * @param {String} selector - tag and class only
 * @param {Object} style
 * @param {Element}
 */
util.create = function () {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var classList = selector.split('.');
  var element = document.createElement(classList.shift() || 'div');

  if (classList.length) {
    element.className = classList.join(' ');
  }

  util.extend(element.style, style);

  return element;
};

/**
 * @param {String} html
 * @return {Element}
 */
util.createElement = function (html) {
  var wrapper = document.createElement('div');
  innerHTML(wrapper, html);

  if (wrapper.children.length > 1) {
    throw new Error('"html" must be one wrapper element.');
  }

  return wrapper.children[0];
};

/**
 * @param {String} html
 * @return {HTMLFragment}
 */
util.createFragment = function (html) {
  var wrapper = document.createElement('div');
  innerHTML(wrapper, html);
  var fragment = document.createDocumentFragment();

  while (wrapper.firstChild) {
    fragment.appendChild(wrapper.firstChild);
  }

  return fragment;
};

/*
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
util.extend = function (dst) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < args.length; i++) {
    if (args[i]) {
      var keys = Object.keys(args[i]);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }

  return dst;
};

/**
 * @param {Object} arrayLike
 * @return {Array}
 */
util.arrayFrom = function (arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

/**
 * @param {String} jsonString
 * @param {Object} [failSafe]
 * @return {Object}
 */
util.parseJSONObjectSafely = function (jsonString) {
  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    var result = JSON.parse('' + jsonString);
    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};

/**
 * @param {String} path - path such as 'myApp.controllers.data.loadData'
 * @return {Any} - whatever is located at that path
 */
util.findFromPath = function (path) {
  path = path.split('.');
  var el = window,
      key;
  while (key = path.shift()) {
    // eslint-disable-line no-cond-assign
    el = el[key];
  }
  return el;
};

/**
 * @param {Element} element
 * @param {String} eventName
 * @param {Object} [detail]
 * @return {CustomEvent}
 */
util.triggerElementEvent = function (target, eventName) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail: detail
  });

  Object.keys(detail).forEach(function (key) {
    event[key] = detail[key];
  });

  target.dispatchEvent(event);

  return event;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean}
 */
util.hasModifier = function (target, modifierName) {
  if (!target.hasAttribute('modifier')) {
    return false;
  }
  return target.getAttribute('modifier').split(/\s+/).some(function (e) {
    return e === modifierName;
  });
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean} Whether it was added or not.
 */
util.addModifier = function (target, modifierName) {
  if (util.hasModifier(target, modifierName)) {
    return false;
  }

  modifierName = modifierName.trim();
  var modifierAttribute = target.getAttribute('modifier') || '';
  target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean} Whether it was found or not.
 */
util.removeModifier = function (target, modifierName) {
  if (!target.getAttribute('modifier')) {
    return false;
  }

  var modifiers = target.getAttribute('modifier').split(/\s+/);

  var newModifiers = modifiers.filter(function (item) {
    return item && item !== modifierName;
  });
  target.setAttribute('modifier', newModifiers.join(' '));

  return modifiers.length !== newModifiers.length;
};

util.updateParentPosition = function (el) {
  if (!el._parentUpdated && el.parentElement) {
    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
      el.parentElement.style.position = 'relative';
    }
    el._parentUpdated = true;
  }
};

util.toggleAttribute = function (element, name, enable) {
  if (enable) {
    element.setAttribute(name, '');
  } else {
    element.removeAttribute(name);
  }
};

util.bindListeners = function (element, listenerNames) {
  listenerNames.forEach(function (name) {
    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};

util.each = function (obj, f) {
  return Object.keys(obj).forEach(function (key) {
    return f(key, obj[key]);
  });
};

/**
 * @param {Element} target
 */
util.updateRipple = function (target) {
  var rippleElement = util.findChild(target, 'ons-ripple');

  if (target.hasAttribute('ripple')) {
    if (!rippleElement) {
      target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};

/**
 * @param {String}
 * @return {Object}
 */
util.animationOptionsParse = parse;

/**
 * @param {*} value
 */
util.isInteger = function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/**
 * @return {Obejct} Deferred promise.
 */
util.defer = function () {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

/*
 * Gesture detector library that forked from github.com/EightMedia/hammer.js.
 */

var Event$1;
var Utils;
var Detection;
var PointerEvent;

/**
 * @object ons.GestureDetector
 * @category gesture
 * @description
 *   [en]Utility class for gesture detection.[/en]
 *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
 */

/**
 * @method constructor
 * @signature constructor(element[, options])
 * @description
 *  [en]Create a new GestureDetector instance.[/en]
 *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
 * @param {Element} element
 *   [en]Name of the event.[/en]
 *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
 * @param {Object} [options]
 *   [en]Options object.[/en]
 *   [ja]オプションを指定します。[/ja]
 * @return {ons.GestureDetector.Instance}
 */
var GestureDetector = function GestureDetector(element, options) {
  return new GestureDetector.Instance(element, options || {});
};

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  GestureDetector.defaults.drag = false;
 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
 *  delete GestureDetector.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: 'pan-y',
    touchCallout: 'none',
    contentZooming: 'none',
    userDrag: 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

/**
 * GestureDetector document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
GestureDetector.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

/**
 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
GestureDetector.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = GestureDetector.EVENT_START = 'start';
var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
var EVENT_END = GestureDetector.EVENT_END = 'end';
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
GestureDetector.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
GestureDetector.plugins = GestureDetector.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
GestureDetector.gestures = GestureDetector.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup() {
  if (GestureDetector.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event$1.determineEventTypes();

  // Register all gestures inside GestureDetector.gestures
  Utils.each(GestureDetector.gestures, function (gesture) {
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

  // GestureDetector is ready...!
  GestureDetector.READY = true;
}

/**
 * @module GestureDetector
 *
 * @class Utils
 * @static
 */
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },

  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler) {
    element.addEventListener(type, handler, false);
  },

  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler) {
    element.removeEventListener(type, handler, false);
  },

  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;

    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
      // arrays
    } else if (obj.length !== undefined) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
      // objects
    } else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },

  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find) {
    if (src.indexOf) {
      var index = src.indexOf(find);
      return index === -1 ? false : index;
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return false;
    }
  },

  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },

  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [],
        pageY = [],
        clientX = [],
        clientY = [],
        min = Math.min,
        max = Math.max;

    // no need to loop when only one touch
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }

    Utils.each(touches, function (touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });

    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },

  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.atan2(y, x) * 180 / Math.PI;
  },

  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX),
        y = Math.abs(touch1.clientY - touch2.clientY);

    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },

  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.sqrt(x * x + y * y);
  },

  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },

  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },

  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },

  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
    prop = Utils.toCamelCase(prop);

    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      // prefixes
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }

      // test the style
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || '';
        break;
      }
    }
  },

  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }

    // set the css properties
    Utils.each(props, function (value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });

    var falseFn = toggle && function () {
      return false;
    };

    // also the disable onselectstart
    if (props.userSelect == 'none') {
      element.onselectstart = falseFn;
    }
    // and disable ondragstart
    if (props.userDrag == 'none') {
      element.ondragstart = falseFn;
    }
  },

  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function (s) {
      return s[1].toUpperCase();
    });
  }
};

/**
 * @module GestureDetector
 */
/**
 * @class Event
 * @static
 */
Event$1 = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,

  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,

  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,

  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.on(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.off(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    var onTouchHandler = function onTouchHandler(ev) {
      var srcType = ev.type.toLowerCase(),
          isPointer = GestureDetector.HAS_POINTEREVENTS,
          isMouse = Utils.inStr(srcType, 'mouse'),
          triggerType;

      // if we are in a mouseevent, but there has been a touchevent triggered in this session
      // we want to do nothing. simply break out of the event.
      if (isMouse && self.preventMouseEvents) {
        return;

        // mousebutton must be down
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self.preventMouseEvents = false;
        self.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
        // just a valid start event, but no mouse
      } else if (!isMouse && eventType == EVENT_START) {
        self.preventMouseEvents = true;
        self.shouldDetect = true;
      }

      // update the pointer event before entering the detection
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }

      // we are in a touch/down state, so allowed detection of gestures
      if (self.shouldDetect) {
        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
      }

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      if (triggerType == EVENT_END) {
        self.preventMouseEvents = false;
        self.shouldDetect = false;
        PointerEvent.reset();
        // update the pointerevent object after the detection
      }

      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };

    this.on(element, EVENT_TYPES[eventType], onTouchHandler);
    return onTouchHandler;
  },

  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
    var changedLength = touchListLength;

    // at each touchstart-like event we want also want to trigger a TOUCH event...
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
      // ...the same for a touchend-like event
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;

      // keep track of how many touches have been removed
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }

    // after there are still touches on the screen,
    // we just want to trigger a MOVE event. so change the START or END to a MOVE
    // but only after detection has been started, the first time we actually want a START
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }

    // detection has been started, we keep track of this, see above
    this.started = true;

    // generate some event data, some basic information
    var evData = this.collectEventData(element, triggerType, touchList, ev);

    // trigger the triggerType event before the change (TOUCH, RELEASE) events
    // but the END event should be at last
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }

    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;

      handler.call(Detection, evData);

      evData.eventType = triggerType;
      delete evData.changedLength;
    }

    // trigger the END event
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      this.started = false;
    }

    return triggerType;
  },

  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
      } else {
        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
    } else {
      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
    }

    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },

  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    // get the fake pointerEvent touchlist
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }

      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];

      Utils.each(concat, function (touch) {
        if (Utils.inArray(identifiers, touch.identifier) === false) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });

      return touchList;
    }

    // make fake touchList from mouse position
    ev.identifier = 1;
    return [ev];
  },

  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }

    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches: touches,
      eventType: eventType,
      pointerType: pointerType,
      srcEvent: ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function preventDefault() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function stopPropagation() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function stopDetect() {
        return Detection.stopDetect();
      }
    };
  }
};

/**
 * @module GestureDetector
 *
 * @class PointerEvent
 * @static
 */
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function (pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },

  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
        types = {};

    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },

  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};

/**
 * @module GestureDetector
 *
 * @class Detection
 * @static
 */
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],

  // data of the current GestureDetector.gesture detection session
  current: null,

  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped: false,

  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a GestureDetector.gesture detection on an element
    if (this.current) {
      return;
    }

    this.stopped = false;

    // holds current session
    this.current = {
      inst: inst, // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent: false, // last eventData
      lastCalcEvent: false, // last eventData for calculations.
      futureCalcEvent: false, // last eventData for calculations.
      lastCalcData: {}, // last lastCalcData
      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },

  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // GestureDetector instance and instance options
    var inst = this.current.inst,
        instOptions = inst.options;

    // call GestureDetector.gesture handlers
    Utils.each(this.gestures, function triggerGesture(gesture) {
      // only when the instance options have enabled this gesture
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);

    // store as previous event event
    if (this.current) {
      this.current.lastEvent = eventData;
    }

    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }

    return eventData; // eslint-disable-line consistent-return
  },

  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;
    this.stopped = true;
  },

  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current,
        recalc = false,
        calcEv = cur.lastCalcEvent,
        calcData = cur.lastCalcData;

    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }

    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }

    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);

      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }

    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },

  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current,
        startEv = cur.startEvent,
        lastEv = cur.lastEvent || startEv;

    // update the start touchlist to calculate the scale/rotation
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function (touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }

    var deltaTime = ev.timeStamp - startEv.timeStamp,
        deltaX = ev.center.clientX - startEv.center.clientX,
        deltaY = ev.center.clientY - startEv.center.clientY;

    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

    Utils.extend(ev, {
      startEvent: startEv,

      deltaTime: deltaTime,
      deltaX: deltaX,
      deltaY: deltaY,

      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });

    return ev;
  },

  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if (options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend GestureDetector default options with the GestureDetector.gesture options
    Utils.extend(GestureDetector.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add GestureDetector.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function (a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });

    return this.gestures;
  }
};

/**
 * @module GestureDetector
 */

/**
 * create new GestureDetector instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
 * @return {GestureDetector.Instance}
 */
GestureDetector.Instance = function (element, options) {
  var self = this;

  // setup GestureDetectorJS window events and register all gestures
  // this also sets up the default options
  setup();

  /**
   * @property element
   * @type {HTMLElement}
   */
  this.element = element;

  /**
   * @property enabled
   * @type {Boolean}
   * @protected
   */
  this.enabled = true;

  /**
   * options, merged with the defaults
   * options with an _ are converted to camelCase
   * @property options
   * @type {Object}
   */
  Utils.each(options, function (value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });

  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

  // add some css to the element to prevent the browser from doing its native behavior
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }

  /**
   * event start handler on the element to start the detection
   * @property eventStartHandler
   * @type {Object}
   */
  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
    if (self.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  });

  /**
   * keep a list of user event handlers which needs to be removed when calling 'dispose'
   * @property eventHandlers
   * @type {Array}
   */
  this.eventHandlers = [];
};

GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  on: function onEvent(gestures, handler) {
    var self = this;
    Event$1.on(self.element, gestures, handler, function (type) {
      self.eventHandlers.push({ gesture: type, handler: handler });
    });
    return self;
  },

  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja]イベントリスナーを削除します。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  off: function offEvent(gestures, handler) {
    var self = this;

    Event$1.off(self.element, gestures, handler, function (type) {
      var index = Utils.inArray({ gesture: type, handler: handler });
      if (index !== false) {
        self.eventHandlers.splice(index, 1);
      }
    });
    return self;
  },

  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if (!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = GestureDetector.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },

  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja]有効にするかどうかを指定します。[/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },

  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    Utils.toggleBehavior(this.element, this.options.behavior, false);

    // unbind all custom event handlers
    for (i = -1; eh = this.eventHandlers[++i];) {
      // eslint-disable-line no-cond-assign
      Utils.off(this.element, eh.gesture, eh.handler);
    }

    this.eventHandlers = [];

    // unbind the start event listener
    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};

/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  GestureDetectortime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function dragGesture(ev, inst) {
    var cur = Detection.current;

    // max touches
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }

    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }

        var startCenter = cur.startEvent.center;

        // we are dragging!
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }

        // keep direction on the axis that the drag gesture started on
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        // trigger events
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);

        var isVertical = Utils.isVertical(ev.direction);

        // block the browser events
        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
          ev.preventDefault();
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;

      case EVENT_END:
        triggered = false;
        break;
    }
  }

  GestureDetector.gestures.Drag = {
    name: name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,

      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,

      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,

      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,

      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,

      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,

      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
GestureDetector.gestures.Gesture = {
  name: 'gesture',
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var timer;

  function holdGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current;

    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);

        // set the gesture so we can check in the timeout if it still is
        current.name = name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        timer = setTimeout(function () {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;

      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;

      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }

  GestureDetector.gestures.Hold = {
    name: name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,

      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
GestureDetector.gestures.Release = {
  name: 'release',
  index: Infinity,
  handler: function releaseGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
GestureDetector.gestures.Swipe = {
  name: 'swipe',
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,

    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,

    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,

    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },

  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length,
          options = inst.options;

      // max touches
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var hasMoved = false;

  function tapGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current,
        prev = Detection.previous,
        sincePrev,
        didDoubleTap;

    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;

      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;

      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          // previous gesture, for the double tap since these are two different gesture detections
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;

          // check if double tap
          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
            inst.trigger('doubletap', ev);
            didDoubleTap = true;
          }

          // do a single tap
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }

  GestureDetector.gestures.Tap = {
    name: name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,

      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,

      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,

      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,

      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
GestureDetector.gestures.Touch = {
  name: 'touch',
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,

    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if (inst.options.preventDefault) {
      ev.preventDefault();
    }

    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger('touch', ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // at least multitouch
        if (ev.touches.length < 2) {
          return;
        }

        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = name;

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        inst.trigger(name, ev); // basic transform event

        // trigger rotate event
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;
    }
  }

  GestureDetector.gestures.Transform = {
    name: name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,

      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },

    handler: transformGesture
  };
})('transform');

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.platform
 * @category util
 * @description
 *   [en]Utility methods to detect current platform.[/en]
 *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 */
var Platform = function () {

  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  function Platform() {
    classCallCheck(this, Platform);

    this._renderPlatform = null;
  }

  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
   */


  createClass(Platform, [{
    key: 'select',
    value: function select(platform) {
      if (typeof platform === 'string') {
        this._renderPlatform = platform.trim().toLowerCase();
      }
    }

    /**
     * @method isWebView
     * @signature isWebView()
     * @description
     *   [en]Returns whether app is running in Cordova.[/en]
     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWebView',
    value: function isWebView() {
      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
        throw new Error('isWebView() method is available after dom contents loaded.');
      }

      return !!(window.cordova || window.phonegap || window.PhoneGap);
    }

    /**
     * @method isIOS
     * @signature isIOS()
     * @description
     *   [en]Returns whether the OS is iOS.[/en]
     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS',
    value: function isIOS() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'ios';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform)
        );
      } else {
        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isAndroid
     * @signature isAndroid()
     * @description
     *   [en]Returns whether the OS is Android.[/en]
     *   [ja]Android上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroid',
    value: function isAndroid() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'android';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Android/i.test(device.platform)
        );
      } else {
        return (/Android/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isAndroidPhone
     * @signature isAndroidPhone()
     * @description
     *   [en]Returns whether the device is Android phone.[/en]
     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidPhone',
    value: function isAndroidPhone() {
      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isAndroidTablet
     * @signature isAndroidTablet()
     * @description
     *   [en]Returns whether the device is Android tablet.[/en]
     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidTablet',
    value: function isAndroidTablet() {
      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isWP',
    value: function isWP() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'wp';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Win32NT|WinCE/i.test(device.platform)
        );
      } else {
        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @methos isIPhone
     * @signature isIPhone()
     * @description
     *   [en]Returns whether the device is iPhone.[/en]
     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhone',
    value: function isIPhone() {
      return (/iPhone/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isIPad
     * @signature isIPad()
     * @description
     *   [en]Returns whether the device is iPad.[/en]
     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPad',
    value: function isIPad() {
      return (/iPad/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isIPod',
    value: function isIPod() {
      return (/iPod/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isBlackBerry
     * @signature isBlackBerry()
     * @description
     *   [en]Returns whether the device is BlackBerry.[/en]
     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isBlackBerry',
    value: function isBlackBerry() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'blackberry';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/BlackBerry/i.test(device.platform)
        );
      } else {
        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isOpera
     * @signature isOpera()
     * @description
     *   [en]Returns whether the browser is Opera.[/en]
     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isOpera',
    value: function isOpera() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'opera';
      } else {
        return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
      }
    }

    /**
     * @method isFirefox
     * @signature isFirefox()
     * @description
     *   [en]Returns whether the browser is Firefox.[/en]
     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isFirefox',
    value: function isFirefox() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'firefox';
      } else {
        return typeof InstallTrigger !== 'undefined';
      }
    }

    /**
     * @method isSafari
     * @signature isSafari()
     * @description
     *   [en]Returns whether the browser is Safari.[/en]
     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isSafari',
    value: function isSafari() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'safari';
      } else {
        return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
      }
    }

    /**
     * @method isChrome
     * @signature isChrome()
     * @description
     *   [en]Returns whether the browser is Chrome.[/en]
     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isChrome',
    value: function isChrome() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'chrome';
      } else {
        return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
      }
    }

    /**
     * @method isIE
     * @signature isIE()
     * @description
     *   [en]Returns whether the browser is Internet Explorer.[/en]
     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIE',
    value: function isIE() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'ie';
      } else {
        return false || !!document.documentMode;
      }
    }

    /**
     * @method isEdge
     * @signature isEdge()
     * @description
     *   [en]Returns whether the browser is Edge.[/en]
     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isEdge',
    value: function isEdge() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'edge';
      } else {
        return navigator.userAgent.indexOf(' Edge/') >= 0;
      }
    }

    /**
     * @method isIOS7above
     * @signature isIOS7above()
     * @description
     *   [en]Returns whether the iOS version is 7 or above.[/en]
     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS7above',
    value: function isIOS7above() {
      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
        );
      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
        return parseInt(ver.split('.')[0]) >= 7;
      }
      return false;
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getMobileOS',
    value: function getMobileOS() {
      if (this.isAndroid()) {
        return 'android';
      } else if (this.isIOS()) {
        return 'ios';
      } else if (this.isWP()) {
        return 'wp';
      } else {
        return 'other';
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getIOSDevice',
    value: function getIOSDevice() {
      if (this.isIPhone()) {
        return 'iphone';
      } else if (this.isIPad()) {
        return 'ipad';
      } else if (this.isIPod()) {
        return 'ipod';
      } else {
        return 'na';
      }
    }
  }]);
  return Platform;
}();

var platform = new Platform();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var readyMap = new WeakMap();
var queueMap = new WeakMap();

function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}

function setContentReady(element) {
  readyMap.set(element, true);
}

function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}

function consumeQueue(element) {
  var callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach(function (callback) {
    return callback();
  });
}

function contentReady(element) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  addCallback(element, fn);

  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }

  var observer = new MutationObserver(function (changes) {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });

  // failback for elements has empty content.
  setImmediate(function () {
    setContentReady(element);
    consumeQueue(element);
  });
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.notification
 * @category dialog
 * @tutorial vanilla/Reference/dialog
 * @description
 *   [en]
 *     Utility methods to create different kinds of alert dialogs. There are three methods available:
 *
 *     * `ons.notification.alert()`
 *     * `ons.notification.confirm()`
 *     * `ons.notification.prompt()`
 *
 *     It will automatically display a Material Design dialog on Android devices.
 *   [/en]
 *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 * @example
 * ons.notification.alert('Hello, world!');
 *
 * ons.notification.confirm('Are you ready?')
 *   .then(
 *     function(answer) {
 *       if (answer === 1) {
 *         ons.notification.alert('Let\'s go!');
 *       }
 *     }
 *   );
 *
 * ons.notification.prompt('How old are ?')
 *   .then(
 *     function(age) {
 *       ons.notification.alert('You are ' + age + ' years old.');
 *     }
 *   );
 */
var notification = {};

notification._createAlertDialog = function (options) {
  // Prompt input string
  var inputString = '';
  if (options.isPrompt) {
    inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
  }

  // Buttons string
  var buttons = '';
  options.buttonLabels.forEach(function (label, index) {
    buttons += '\n      <button class="\n        alert-dialog-button\n        ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n        ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--one' : '') + '\n      ">\n        ' + label + '\n      </button>\n    ';
  });

  // Dialog Element
  var el = {};
  var _destroyDialog = function _destroyDialog() {
    if (el.dialog.onDialogCancel) {
      el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
    }

    Object.keys(el).forEach(function (key) {
      return delete el[key];
    });
    el = null;

    if (options.destroy instanceof Function) {
      options.destroy();
    }
  };

  el.dialog = document.createElement('ons-alert-dialog');
  innerHTML(el.dialog, '\n    <div class="alert-dialog-mask"></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--one' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ');
  contentReady(el.dialog);

  // Set attributes
  ['id', 'class', 'animation'].forEach(function (a) {
    return options.hasOwnProperty(a) && el.dialog.setAttribute(a, options[a]);
  });
  if (options.modifier) {
    util.addModifier(el.dialog, options.modifier);
  }

  var deferred = util.defer();

  // Prompt events
  if (options.isPrompt && options.submitOnEnter) {
    el.input = el.dialog.querySelector('.text-input');
    el.input.onkeypress = function (event) {
      if (event.keyCode === 13) {
        el.dialog.hide().then(function () {
          var resolveValue = el.input.value;
          _destroyDialog();
          options.callback(resolveValue);
          deferred.resolve(resolveValue);
        });
      }
    };
  }

  // Button events
  el.footer = el.dialog.querySelector('.alert-dialog-footer');
  util.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
    buttonElement.onclick = function () {
      el.dialog.hide().then(function () {
        var resolveValue = options.isPrompt ? el.input.value : index;
        el.dialog.remove();
        _destroyDialog();
        options.callback(resolveValue);
        deferred.resolve(resolveValue);
      });
    };

    el.footer.appendChild(buttonElement);
  });

  // Cancel events
  if (options.cancelable) {
    el.dialog.cancelable = true;
    el.dialog.onDialogCancel = function () {
      setImmediate(function () {
        el.dialog.remove();
        _destroyDialog();
      });
      var resolveValue = options.isPrompt ? null : -1;
      options.callback(resolveValue);
      deferred.reject(resolveValue);
    };
    el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
  }

  // Show dialog
  document.body.appendChild(el.dialog);
  options.compile(el.dialog);
  setImmediate(function () {
    el.dialog.show().then(function () {
      if (el.input && options.isPrompt && options.autofocus) {
        el.input.focus();
      }
    });
  });

  return deferred.promise;
};

var _normalizeArguments = function _normalizeArguments(message) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  typeof message === 'string' ? options.message = message : options = message;
  if (!options.message && !options.messageHTML) {
    throw new Error('Alert dialog must contain a message.');
  }

  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ''];
    }
  }

  return util.extend({
    compile: function compile(param) {
      return param;
    },
    callback: function callback(param) {
      return param;
    },
    buttonLabels: ['OK'],
    primaryButtonIndex: 0,
    animation: 'default',
    cancelable: false
  }, defaults, options);
};

/**
 * @method alert
 * @signature alert(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve when the dialog is closed.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Alert message.[/en]
 *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
 * @param {String} [options.messageHTML]
 *   [en]Alert message in HTML.[/en]
 *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `0`.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
 *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
 *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade"のいずれかを指定できます。[/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
 *   [ja]ons-alert-dialog要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-alert-dialog>` element's class.[/en]
 *   [ja]ons-alert-dialog要素のclass。[/ja]
 * @param {String} [options.title]
 *   [en]Dialog title. Default is `"Alert"`.[/en]
 *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the dialog.[/en]
 *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after dialog has been closed.[/en]
 *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display an alert dialog to show the user a message.
 *
 *     The content of the message can be either simple text or HTML.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.alert(message, options);
 *     ons.notification.alert(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
 *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.alert = function (message, options) {
  options = _normalizeArguments(message, options, {
    title: 'Alert'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method confirm
 * @signature confirm(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 * @param {Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
 *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `1`.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
 * @description
 *   [en]
 *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.confirm(message, options);
 *     ons.notification.confirm(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザに確認を促すダイアログを表示します。
 *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.confirm = function (message, options) {
  options = _normalizeArguments(message, options, {
    buttonLabels: ['Cancel', 'OK'],
    primaryButtonIndex: 1,
    title: 'Confirm'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method prompt
 * @signature prompt(message [, options] | options)
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve to the input value when the dialog is closed.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `0`.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {String} [options.placeholder]
 *   [en]Placeholder for the text input.[/en]
 *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
 * @param {String} [options.defaultValue]
 *   [en]Default value for the text input.[/en]
 *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
 * @param {String} [options.inputType]
 *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.autofocus]
 *   [en]Autofocus the input element. Default is `true`.[/en]
 *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @param {Boolean} [options.submitOnEnter]
 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
 *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @description
 *   [en]
 *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.prompt(message, options);
 *     ons.notification.prompt(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーに入力を促すダイアログを表示します。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.prompt = function (message, options) {
  options = _normalizeArguments(message, options, {
    title: 'Alert',
    isPrompt: true,
    autofocus: true,
    submitOnEnter: true
  });

  return notification._createAlertDialog(options);
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var pageAttributeExpression = {
  _variables: {},

  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function defineVariable(name, value) {
    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (typeof name !== 'string') {
      throw new Error('Variable name must be a string.');
    } else if (typeof value !== 'string' && typeof value !== 'function') {
      throw new Error('Variable value must be a string or a function.');
    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
      throw new Error('"' + name + '" is already defined.');
    }
    this._variables[name] = value;
  },

  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function getVariable(name) {
    if (!this._variables.hasOwnProperty(name)) {
      return null;
    }

    return this._variables[name];
  },

  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function removeVariable(name) {
    delete this._variables[name];
  },

  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function getAllVariables() {
    return this._variables;
  },
  _parsePart: function _parsePart(part) {
    var c = void 0,
        inInterpolation = false,
        currentIndex = 0;

    var tokens = [];

    if (part.length === 0) {
      throw new Error('Unable to parse empty string.');
    }

    for (var i = 0; i < part.length; i++) {
      c = part.charAt(i);

      if (c === '$' && part.charAt(i + 1) === '{') {
        if (inInterpolation) {
          throw new Error('Nested interpolation not supported.');
        }

        var token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }

        currentIndex = i;
        inInterpolation = true;
      } else if (c === '}') {
        if (!inInterpolation) {
          throw new Error('} must be preceeded by ${');
        }

        var _token = part.substring(currentIndex, i + 1);
        if (_token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }

        currentIndex = i + 1;
        inInterpolation = false;
      }
    }

    if (inInterpolation) {
      throw new Error('Unterminated interpolation.');
    }

    tokens.push(part.substring(currentIndex, part.length));

    return tokens;
  },
  _replaceToken: function _replaceToken(token) {
    var re = /^\${(.*?)}$/,
        match = token.match(re);

    if (match) {
      var name = match[1].trim();
      var variable = this.getVariable(name);

      if (variable === null) {
        throw new Error('Variable "' + name + '" does not exist.');
      } else if (typeof variable === 'string') {
        return variable;
      } else {
        var rv = variable();

        if (typeof rv !== 'string') {
          throw new Error('Must return a string.');
        }

        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function _replaceTokens(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function _parseExpression(expression) {
    return expression.split(',').map(function (part) {
      return part.trim();
    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
      return part.join('');
    });
  },

  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function evaluate(expression) {
    if (!expression) {
      return [];
    }

    return this._parseExpression(expression);
  }
};

// Define default variables.
pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
pageAttributeExpression.defineVariable('runtime', function () {
  return platform.isWebView() ? 'cordova' : 'browser';
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var internal$1 = {};

internal$1.config = {
  autoStatusBarFill: true,
  animationsDisabled: false
};

internal$1.nullElement = window.document.createElement('div');

/**
 * @return {Boolean}
 */
internal$1.isEnabledAutoStatusBarFill = function () {
  return !!internal$1.config.autoStatusBarFill;
};

/**
 * @param {String} html
 * @return {String}
 */
internal$1.normalizePageHTML = function (html) {
  html = ('' + html).trim();

  if (!html.match(/^<ons-page/)) {
    html = '<ons-page _muted>' + html + '</ons-page>';
  }

  return html;
};

internal$1.waitDOMContentLoaded = function (callback) {
  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
    window.document.addEventListener('DOMContentLoaded', callback);
  } else {
    setImmediate(callback);
  }
};

internal$1.autoStatusBarFill = function (action) {
  var onReady = function onReady() {
    if (internal$1.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener('deviceready', onReady);
    document.removeEventListener('DOMContentLoaded', onReady);
  };

  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
    document.addEventListener('deviceready', onReady);
  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
    document.addEventListener('DOMContentLoaded', function () {
      onReady();
    });
  } else {
    onReady();
  }
};

internal$1.shouldFillStatusBar = function () {
  return internal$1.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
};

internal$1.templateStore = {
  _storage: {},

  /**
   * @param {String} key
   * @return {String/null} template
   */
  get: function get(key) {
    return internal$1.templateStore._storage[key] || null;
  },


  /**
   * @param {String} key
   * @param {String} template
   */
  set: function set(key, template) {
    internal$1.templateStore._storage[key] = template;
  }
};

window.document.addEventListener('_templateloaded', function (e) {
  if (e.target.nodeName.toLowerCase() === 'ons-template') {
    internal$1.templateStore.set(e.templateId, e.template);
  }
}, false);

window.document.addEventListener('DOMContentLoaded', function () {
  register('script[type="text/ons-template"]');
  register('script[type="text/template"]');
  register('script[type="text/ng-template"]');

  function register(query) {
    var templates = window.document.querySelectorAll(query);
    for (var i = 0; i < templates.length; i++) {
      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
    }
  }
}, false);

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getTemplateHTMLAsync = function (page) {
  return new Promise(function (resolve, reject) {
    setImmediate(function () {
      var cache = internal$1.templateStore.get(page);

      if (cache) {
        var html = typeof cache === 'string' ? cache : cache[1];
        resolve(html);
      } else {
        (function () {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', page, true);
          xhr.onload = function (response) {
            var html = xhr.responseText;
            if (xhr.status >= 400 && xhr.status < 600) {
              reject(html);
            } else {
              resolve(html);
            }
          };
          xhr.onerror = function () {
            throw new Error('The page is not found: ' + page);
          };
          xhr.send(null);
        })();
      }
    });
  });
};

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getPageHTMLAsync = function (page) {
  var pages = pageAttributeExpression.evaluate(page);

  var getPage = function getPage(page) {
    if (typeof page !== 'string') {
      return Promise.reject('Must specify a page.');
    }

    return internal$1.getTemplateHTMLAsync(page).then(function (html) {
      return internal$1.normalizePageHTML(html);
    }, function (error) {
      if (pages.length === 0) {
        return Promise.reject(error);
      }

      return getPage(pages.shift());
    }).then(function (html) {
      return internal$1.normalizePageHTML(html);
    });
  };

  return getPage(pages.shift());
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AnimatorFactory = function () {

  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  function AnimatorFactory(opts) {
    classCallCheck(this, AnimatorFactory);

    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || 'default';
    this._animationOptions = opts.defaultAnimationOptions || {};

    if (!this._animators[this._animation]) {
      throw new Error('No such animation: ' + this._animation);
    }
  }

  /**
   * @param {String} jsonString
   * @return {Object/null}
   */


  createClass(AnimatorFactory, [{
    key: 'setAnimationOptions',


    /**
     * @param {Object} options
     */
    value: function setAnimationOptions(options) {
      this._animationOptions = options;
    }

    /**
     * @param {Object} options
     * @param {String} [options.animation] The animation name
     * @param {Object} [options.animationOptions] The animation options
     * @param {Object} defaultAnimator The default animator instance
     * @return {Object} An animator instance
     */

  }, {
    key: 'newAnimator',
    value: function newAnimator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultAnimator = arguments[1];


      var animator = null;

      if (options.animation instanceof this._baseClass) {
        return options.animation;
      }

      var Animator = null;

      if (typeof options.animation === 'string') {
        Animator = this._animators[options.animation];
      }

      if (!Animator && defaultAnimator) {
        animator = defaultAnimator;
      } else {
        Animator = Animator || this._animators[this._animation];

        var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

        animator = new Animator(animationOpts);

        if (typeof animator === 'function') {
          animator = new animator(animationOpts); // eslint-disable-line new-cap
        }
      }

      if (!(animator instanceof this._baseClass)) {
        throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
      }

      return animator;
    }
  }], [{
    key: 'parseAnimationOptionsString',
    value: function parseAnimationOptionsString(jsonString) {
      try {
        if (typeof jsonString === 'string') {
          var result = util.animationOptionsParse(jsonString);
          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
            return result;
          } else {
            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
          }
        }
        return {};
      } catch (e) {
        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        return {};
      }
    }
  }]);
  return AnimatorFactory;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModifierUtil = function () {
  function ModifierUtil() {
    classCallCheck(this, ModifierUtil);
  }

  createClass(ModifierUtil, null, [{
    key: 'diff',

    /**
     * @param {String} last
     * @param {String} current
     */
    value: function diff(last, current) {
      last = makeDict(('' + last).trim());
      current = makeDict(('' + current).trim());

      var removed = Object.keys(last).reduce(function (result, token) {
        if (!current[token]) {
          result.push(token);
        }
        return result;
      }, []);

      var added = Object.keys(current).reduce(function (result, token) {
        if (!last[token]) {
          result.push(token);
        }
        return result;
      }, []);

      return { added: added, removed: removed };

      function makeDict(modifier) {
        var dict = {};
        ModifierUtil.split(modifier).forEach(function (token) {
          return dict[token] = token;
        });
        return dict;
      }
    }

    /**
     * @param {Object} diff
     * @param {Object} classList
     * @param {String} template
     */

  }, {
    key: 'applyDiffToClassList',
    value: function applyDiffToClassList(diff, classList, template) {
      diff.added.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return classList.add(klass);
      });

      diff.removed.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return classList.remove(klass);
      });
    }

    /**
     * @param {Object} diff
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'applyDiffToElement',
    value: function applyDiffToElement(diff, element, scheme) {
      var matches = function matches(e, s) {
        return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
      };
      for (var selector in scheme) {
        if (scheme.hasOwnProperty(selector)) {
          var targetElements = !selector || matches(element, selector) ? [element] : element.querySelectorAll(selector);
          for (var i = 0; i < targetElements.length; i++) {
            ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
          }
        }
      }
    }

    /**
     * @param {String} last
     * @param {String} current
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'onModifierChanged',
    value: function onModifierChanged(last, current, element, scheme) {
      return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
    }

    /**
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'initModifier',
    value: function initModifier(element, scheme) {
      var modifier = element.getAttribute('modifier');
      if (typeof modifier !== 'string') {
        return;
      }

      ModifierUtil.applyDiffToElement({
        removed: [],
        added: ModifierUtil.split(modifier)
      }, element, scheme);
    }
  }, {
    key: 'split',
    value: function split(modifier) {
      if (typeof modifier !== 'string') {
        return [];
      }

      return modifier.trim().split(/ +/).filter(function (token) {
        return token !== '';
      });
    }
  }]);
  return ModifierUtil;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var LazyRepeatDelegate = function () {
  function LazyRepeatDelegate(userDelegate) {
    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, LazyRepeatDelegate);

    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
      throw Error('"delegate" parameter must be an object.');
    }
    this._userDelegate = userDelegate;

    if (!(templateElement instanceof Element) && templateElement !== null) {
      throw Error('"templateElement" parameter must be an instance of Element or null.');
    }
    this._templateElement = templateElement;
  }

  createClass(LazyRepeatDelegate, [{
    key: 'hasRenderFunction',


    /**
     * @return {Boolean}
     */
    value: function hasRenderFunction() {
      return this._userDelegate._render instanceof Function;
    }

    /**
     * @return {void}
     */

  }, {
    key: '_render',
    value: function _render(items, height) {
      this._userDelegate._render(items, height);
    }

    /**
     * @param {Number} index
     * @param {Element} parent
     * @param {Function} done A function that take item object as parameter.
     */

  }, {
    key: 'loadItemElement',
    value: function loadItemElement(index, parent, done) {
      if (this._userDelegate.loadItemElement instanceof Function) {
        this._userDelegate.loadItemElement(index, parent, function (element) {
          return done({ element: element });
        });
      } else {
        var element = this._userDelegate.createItemContent(index, this._templateElement);
        if (!(element instanceof Element)) {
          throw Error('createItemContent() must return an instance of Element.');
        }
        parent.appendChild(element);
        done({ element: element });
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'countItems',
    value: function countItems() {
      var count = this._userDelegate.countItems();
      if (typeof count !== 'number') {
        throw Error('countItems() must return a number.');
      }
      return count;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     * @param {Element} item.element
     */

  }, {
    key: 'updateItem',
    value: function updateItem(index, item) {
      if (this._userDelegate.updateItemContent instanceof Function) {
        this._userDelegate.updateItemContent(index, item);
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'calculateItemHeight',
    value: function calculateItemHeight(index) {
      if (this._userDelegate.calculateItemHeight instanceof Function) {
        var height = this._userDelegate.calculateItemHeight(index);

        if (typeof height !== 'number') {
          throw Error('calculateItemHeight() must return a number.');
        }

        return height;
      }

      return 0;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     */

  }, {
    key: 'destroyItem',
    value: function destroyItem(index, item) {
      if (this._userDelegate.destroyItem instanceof Function) {
        this._userDelegate.destroyItem(index, item);
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._userDelegate.destroy instanceof Function) {
        this._userDelegate.destroy();
      }

      this._userDelegate = this._templateElement = null;
    }
  }, {
    key: 'itemHeight',
    get: function get() {
      return this._userDelegate.itemHeight;
    }
  }]);
  return LazyRepeatDelegate;
}();

/**
 * This class provide core functions for ons-lazy-repeat.
 */
var LazyRepeatProvider = function () {

  /**
   * @param {Element} wrapperElement
   * @param {LazyRepeatDelegate} delegate
   */
  function LazyRepeatProvider(wrapperElement, delegate) {
    classCallCheck(this, LazyRepeatProvider);

    if (!(delegate instanceof LazyRepeatDelegate)) {
      throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
    }

    this._wrapperElement = wrapperElement;
    this._delegate = delegate;

    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
      wrapperElement.classList.add('lazy-list');
    }

    this._pageContent = this._findPageContentElement(wrapperElement);

    if (!this._pageContent) {
      throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
    }

    this._topPositions = [];
    this._renderedItems = {};

    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
      this._unknownItemHeight = true;
    }
    this._addEventListeners();
    this._onChange();
  }

  createClass(LazyRepeatProvider, [{
    key: '_findPageContentElement',
    value: function _findPageContentElement(wrapperElement) {
      var pageContent = util.findParent(wrapperElement, '.page__content');

      if (pageContent) {
        return pageContent;
      }

      var page = util.findParent(wrapperElement, 'ons-page');
      if (page) {
        var content = util.findChild(page, '.content');
        if (content) {
          return content;
        }
      }

      return null;
    }
  }, {
    key: '_checkItemHeight',
    value: function _checkItemHeight(callback) {
      var _this = this;

      this._delegate.loadItemElement(0, this._wrapperElement, function (item) {
        if (!_this._unknownItemHeight) {
          throw Error('Invalid state');
        }

        var done = function done() {
          _this._wrapperElement.removeChild(item.element);
          delete _this._unknownItemHeight;
          callback();
        };

        _this._itemHeight = item.element.offsetHeight;

        if (_this._itemHeight > 0) {
          done();
          return;
        }

        // retry to measure offset height
        // dirty fix for angular2 directive
        var lastVisibility = _this._wrapperElement.style.visibility;
        _this._wrapperElement.style.visibility = 'hidden';
        item.element.style.visibility = 'hidden';

        setImmediate(function () {
          _this._itemHeight = item.element.offsetHeight;
          if (_this._itemHeight == 0) {
            throw Error('Invalid state: this._itemHeight must be greater than zero.');
          }
          _this._wrapperElement.style.visibility = lastVisibility;
          done();
        });
      });
    }
  }, {
    key: '_countItems',
    value: function _countItems() {
      return this._delegate.countItems();
    }
  }, {
    key: '_getItemHeight',
    value: function _getItemHeight(i) {
      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._render();
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      this._removeAllElements();
      this._onChange();
    }
  }, {
    key: '_render',
    value: function _render() {
      var _this2 = this;

      if (this._unknownItemHeight) {
        return this._checkItemHeight(this._render.bind(this));
      }

      var items = this._getItemsInView();

      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
        this._delegate._render(items, this._listHeight);
        return null;
      }

      var keep = {};

      items.forEach(function (item) {
        _this2._renderElement(item);
        keep[item.index] = true;
      });

      Object.keys(this._renderedItems).forEach(function (key) {
        return keep[key] || _this2._removeElement(key);
      });

      this._wrapperElement.style.height = this._listHeight + 'px';
    }

    /**
     * @param {Object} item
     * @param {Number} item.index
     * @param {Number} item.top
     */

  }, {
    key: '_renderElement',
    value: function _renderElement(_ref) {
      var _this3 = this;

      var index = _ref.index,
          top = _ref.top;

      var item = this._renderedItems[index];
      if (item) {
        this._delegate.updateItem(index, item); // update if it exists
        item.element.style.top = top + 'px';
        return;
      }

      this._delegate.loadItemElement(index, this._wrapperElement, function (item) {
        util.extend(item.element.style, {
          position: 'absolute',
          top: top + 'px',
          left: 0,
          right: 0
        });

        _this3._renderedItems[index] = item;
      });
    }

    /**
     * @param {Number} index
     */

  }, {
    key: '_removeElement',
    value: function _removeElement(index) {
      var item = this._renderedItems[index];

      this._delegate.destroyItem(index, item);

      if (item.element.parentElement) {
        item.element.parentElement.removeChild(item.element);
      }

      delete this._renderedItems[index];
    }
  }, {
    key: '_removeAllElements',
    value: function _removeAllElements() {
      var _this4 = this;

      Object.keys(this._renderedItems).forEach(function (key) {
        return _this4._removeElement(key);
      });
    }
  }, {
    key: '_calculateStartIndex',
    value: function _calculateStartIndex(current) {
      var start = 0;
      var end = this._itemCount - 1;

      if (this.staticItemHeight) {
        return parseInt(-current / this.staticItemHeight);
      }

      // Binary search for index at top of screen so we can speed up rendering.
      for (;;) {
        var middle = Math.floor((start + end) / 2);
        var value = current + this._topPositions[middle];

        if (end < start) {
          return 0;
        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
          return middle;
        } else if (isNaN(value) || value >= 0) {
          end = middle - 1;
        } else {
          start = middle + 1;
        }
      }
    }
  }, {
    key: '_recalculateTopPositions',
    value: function _recalculateTopPositions() {
      var l = Math.min(this._topPositions.length, this._itemCount);
      this._topPositions[0] = 0;
      for (var i = 1, _l; i < _l; i++) {
        this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
      }
    }
  }, {
    key: '_getItemsInView',
    value: function _getItemsInView() {
      var offset = this._wrapperElement.getBoundingClientRect().top;
      var limit = 4 * window.innerHeight - offset;
      var count = this._countItems();

      if (count !== this._itemCount) {
        this._itemCount = count;
        this._recalculateTopPositions();
      }

      var i = Math.max(0, this._calculateStartIndex(offset) - 30);

      var items = [];
      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
        if (i >= this._topPositions.length) {
          // perf optimization
          this._topPositions.length += 100;
        }

        this._topPositions[i] = top;
        items.push({ top: top, index: i });
        top += this._getItemHeight(i);
      }
      this._listHeight = top;

      return items;
    }
  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout = void 0;
      return function () {
        var _this5 = this,
            _arguments = arguments;

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        if (callNow) {
          func.apply(this, arguments);
        } else {
          timeout = setTimeout(function () {
            timeout = null;
            func.apply(_this5, _arguments);
          }, wait);
        }
      };
    }
  }, {
    key: '_doubleFireOnTouchend',
    value: function _doubleFireOnTouchend() {
      this._render();
      this._debounce(this._render.bind(this), 100);
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

      if (platform.isIOS()) {
        this._boundOnChange = this._debounce(this._boundOnChange, 30);
      }

      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.addEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.removeEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._removeAllElements();
      this._delegate.destroy();
      this._parentElement = this._delegate = this._renderedItems = null;
      this._removeEventListeners();
    }
  }, {
    key: 'staticItemHeight',
    get: function get() {
      return this._delegate.itemHeight || this._itemHeight;
    }
  }]);
  return LazyRepeatProvider;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
internal$1.AnimatorFactory = AnimatorFactory;
internal$1.ModifierUtil = ModifierUtil;
internal$1.LazyRepeatProvider = LazyRepeatProvider;
internal$1.LazyRepeatDelegate = LazyRepeatDelegate;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var create = function create() {

  /**
   * @object ons.orientation
   * @category util
   * @description
   *   [en]Utility methods for orientation detection.[/en]
   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
   */
  var obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
     */

    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja]イベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]削除するイベントリスナーを指定します。[/ja]
     */

    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,

    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
     */
    isPortrait: function isPortrait() {
      return this._isPortrait();
    },

    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
     */
    isLandscape: function isLandscape() {
      return !this.isPortrait();
    },

    _init: function _init() {
      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

      if ('orientation' in window) {
        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener('resize', this._onResize.bind(this), false);
      }

      this._isPortrait = function () {
        return window.innerHeight > window.innerWidth;
      };

      return this;
    },

    _onDOMContentLoaded: function _onDOMContentLoaded() {
      this._installIsPortraitImplementation();
      this.emit('change', { isPortrait: this.isPortrait() });
    },

    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
      var isPortrait = window.innerWidth < window.innerHeight;

      if (!('orientation' in window)) {
        this._isPortrait = function () {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },

    _onOrientationChange: function _onOrientationChange() {
      var _this = this;

      var isPortrait = this._isPortrait();

      // Wait for the dimensions to change because
      // of Android inconsistency.
      var nIter = 0;
      var interval = setInterval(function () {
        nIter++;

        var w = window.innerWidth;
        var h = window.innerHeight;

        if (isPortrait && w <= h || !isPortrait && w >= h) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },

    // Run on not mobile browser.
    _onResize: function _onResize() {
      this.emit('change', { isPortrait: this.isPortrait() });
    }
  };

  MicroEvent.mixin(obj);

  return obj;
};

var orientation = create()._init();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var softwareKeyboard = new MicroEvent();
softwareKeyboard._visible = false;

var onShow = function onShow() {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit('show');
};

var onHide = function onHide() {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit('hide');
};

var bindEvents = function bindEvents() {
  if (typeof Keyboard !== 'undefined') {
    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

    return true;
  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
    window.addEventListener('native.keyboardshow', onShow);
    window.addEventListener('native.keyboardhide', onHide);
    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

    return true;
  }

  return false;
};

var noPluginError = function noPluginError() {
  console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
};

document.addEventListener('deviceready', function () {
  if (!bindEvents()) {
    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
      noPluginError();
    }

    softwareKeyboard.on = noPluginError;
  }
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$2 = {
  _ready: false,

  _domContentLoaded: false,

  _onDOMContentLoaded: function _onDOMContentLoaded() {
    util$2._domContentLoaded = true;

    if (platform.isWebView()) {
      window.document.addEventListener('deviceready', function () {
        util$2._ready = true;
      }, false);
    } else {
      util$2._ready = true;
    }
  },

  addBackButtonListener: function addBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.addEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.addEventListener('backbutton', fn, false);
      });
    }
  },

  removeBackButtonListener: function removeBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.removeEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.removeEventListener('backbutton', fn, false);
      });
    }
  }
};
window.addEventListener('DOMContentLoaded', function () {
  return util$2._onDOMContentLoaded();
}, false);

var HandlerRepository = {
  _store: {},

  _genId: function () {
    var i = 0;
    return function () {
      return i++;
    };
  }(),

  set: function set(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },

  remove: function remove(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },

  get: function get(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return undefined;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    if (!this._store[id]) {
      throw new Error();
    }

    return this._store[id];
  },

  has: function has(element) {
    if (!element.dataset) {
      return false;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    return !!this._store[id];
  }
};

var DeviceBackButtonDispatcher = function () {
  function DeviceBackButtonDispatcher() {
    classCallCheck(this, DeviceBackButtonDispatcher);

    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }

  /**
   * Enable to handle 'backbutton' events.
   */


  createClass(DeviceBackButtonDispatcher, [{
    key: 'enable',
    value: function enable() {
      if (!this._isEnabled) {
        util$2.addBackButtonListener(this._boundCallback);
        this._isEnabled = true;
      }
    }

    /**
     * Disable to handle 'backbutton' events.
     */

  }, {
    key: 'disable',
    value: function disable() {
      if (this._isEnabled) {
        util$2.removeBackButtonListener(this._boundCallback);
        this._isEnabled = false;
      }
    }

    /**
     * Fire a 'backbutton' event manually.
     */

  }, {
    key: 'fireDeviceBackButtonEvent',
    value: function fireDeviceBackButtonEvent() {
      var event = document.createEvent('Event');
      event.initEvent('backbutton', true, true);
      document.dispatchEvent(event);
    }
  }, {
    key: '_callback',
    value: function _callback() {
      this._dispatchDeviceBackButtonEvent();
    }

    /**
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: 'createHandler',
    value: function createHandler(element, callback) {
      if (!(element instanceof HTMLElement)) {
        throw new Error('element must be an instance of HTMLElement');
      }

      if (!(callback instanceof Function)) {
        throw new Error('callback must be an instance of Function');
      }

      var handler = {
        _callback: callback,
        _element: element,

        disable: function disable() {
          HandlerRepository.remove(element);
        },

        setListener: function setListener(callback) {
          this._callback = callback;
        },

        enable: function enable() {
          HandlerRepository.set(element, this);
        },

        isEnabled: function isEnabled() {
          return HandlerRepository.get(element) === this;
        },

        destroy: function destroy() {
          HandlerRepository.remove(element);
          this._callback = this._element = null;
        }
      };

      handler.enable();

      return handler;
    }
  }, {
    key: '_dispatchDeviceBackButtonEvent',
    value: function _dispatchDeviceBackButtonEvent() {
      var tree = this._captureTree();

      var element = this._findHandlerLeafElement(tree);

      var handler = HandlerRepository.get(element);
      handler._callback(createEvent(element));

      function createEvent(element) {
        return {
          _element: element,
          callParentHandler: function callParentHandler() {
            var parent = this._element.parentNode;

            while (parent) {
              handler = HandlerRepository.get(parent);
              if (handler) {
                return handler._callback(createEvent(parent));
              }
              parent = parent.parentNode;
            }
          }
        };
      }
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_captureTree',
    value: function _captureTree() {
      return createTree(document.body);

      function createTree(element) {
        return {
          element: element,
          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

            if (childElement.style.display === 'none') {
              return [];
            }

            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
              return [];
            }

            var result = createTree(childElement);

            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
              return [];
            }

            return [result];
          }))
        };
      }

      function arrayOf(target) {
        var result = [];
        for (var i = 0; i < target.length; i++) {
          result.push(target[i]);
        }
        return result;
      }
    }

    /**
     * @param {Object} tree
     * @return {HTMLElement}
     */

  }, {
    key: '_findHandlerLeafElement',
    value: function _findHandlerLeafElement(tree) {
      return find(tree);

      function find(node) {
        if (node.children.length === 0) {
          return node.element;
        }

        if (node.children.length === 1) {
          return find(node.children[0]);
        }

        return node.children.map(function (childNode) {
          return childNode.element;
        }).reduce(function (left, right) {
          if (!left) {
            return right;
          }

          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

          if (!isNaN(leftZ) && !isNaN(rightZ)) {
            return leftZ > rightZ ? left : right;
          }

          throw new Error('Capturing backbutton-handler is failure.');
        }, null);
      }
    }
  }]);
  return DeviceBackButtonDispatcher;
}();

var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoStyleEnabled = true;

// Modifiers
var modifiersMap = {
  'quiet': 'material--flat',
  'light': 'material--flat',
  'outline': 'material--flat',
  'cta': '',
  'large--quiet': 'material--flat large',
  'large--cta': 'large',
  'noborder': '',
  'chevron': '',
  'tappable': ''
};

var platforms = {};

platforms.android = function (element) {

  if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

    var oldModifier = element.getAttribute('modifier') || '';

    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
    });
    newModifier.unshift('material');

    element.setAttribute('modifier', newModifier.join(' ').trim());
  }

  // Effects
  if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

    if (element.tagName.toLowerCase() === 'ons-list-item') {
      if (element.hasAttribute('tappable')) {
        element.setAttribute('ripple', '');
        element.removeAttribute('tappable');
      }
    } else {
      element.setAttribute('ripple', '');
    }
  }
};

platforms.ios = function (element) {

  // Modifiers
  if (/material/.test(element.getAttribute('modifier'))) {
    util.removeModifier(element, 'material');

    if (util.removeModifier(element, 'material--flat')) {
      util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
    }

    if (!element.getAttribute('modifier')) {
      element.removeAttribute('modifier');
    }
  }

  // Effects
  if (element.hasAttribute('ripple')) {
    if (element.tagName.toLowerCase() === 'ons-list-item') {
      element.setAttribute('tappable', '');
    }

    element.removeAttribute('ripple');
  }
};

var unlocked = {
  android: true
};

var prepareAutoStyle = function prepareAutoStyle(element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      platforms[mobileOS](element);
    }
  }
};

var autoStyle = {
  isEnabled: function isEnabled() {
    return autoStyleEnabled;
  },
  enable: function enable() {
    return autoStyleEnabled = true;
  },
  disable: function disable() {
    return autoStyleEnabled = false;
  },
  prepare: prepareAutoStyle
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var generateId = function () {
  var i = 0;
  return function () {
    return i++;
  };
}();

/**
 * Door locking system.
 *
 * @param {Object} [options]
 * @param {Function} [options.log]
 */

var DoorLock = function () {
  function DoorLock() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DoorLock);

    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function () {};
  }

  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */


  createClass(DoorLock, [{
    key: 'lock',
    value: function lock() {
      var _this = this;

      var unlock = function unlock() {
        _this._unlock(unlock);
      };
      unlock.id = generateId();
      this._lockList.push(unlock);
      this._log('lock: ' + unlock.id);

      return unlock;
    }
  }, {
    key: '_unlock',
    value: function _unlock(fn) {
      var index = this._lockList.indexOf(fn);
      if (index === -1) {
        throw new Error('This function is not registered in the lock list.');
      }

      this._lockList.splice(index, 1);
      this._log('unlock: ' + fn.id);

      this._tryToFreeWaitList();
    }
  }, {
    key: '_tryToFreeWaitList',
    value: function _tryToFreeWaitList() {
      while (!this.isLocked() && this._waitList.length > 0) {
        this._waitList.shift()();
      }
    }

    /**
     * Register a callback for waiting unlocked door.
     *
     * @params {Function} callback Callback on unlocking the door completely.
     */

  }, {
    key: 'waitUnlock',
    value: function waitUnlock(callback) {
      if (!(callback instanceof Function)) {
        throw new Error('The callback param must be a function.');
      }

      if (this.isLocked()) {
        this._waitList.push(callback);
      } else {
        callback();
      }
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isLocked',
    value: function isLocked() {
      return this._lockList.length > 0;
    }
  }]);
  return DoorLock;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
// Default implementation for global PageLoader.
function loadPage$1(_ref, done) {
  var page = _ref.page,
      parent = _ref.parent,
      _ref$params = _ref.params,
      params = _ref$params === undefined ? {} : _ref$params;

  internal$1.getPageHTMLAsync(page).then(function (html) {
    var pageElement = util.createElement(html.trim());
    parent.appendChild(pageElement);

    done(pageElement);
  });
}

function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}

var PageLoader = function () {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  function PageLoader(loader, unloader) {
    classCallCheck(this, PageLoader);

    this._loader = loader instanceof Function ? loader : loadPage$1;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }

  /**
   * Set internal loader implementation.
   */


  createClass(PageLoader, [{
    key: 'load',


    /**
     * @param {any} options.page
     * @param {Element} options.parent A location to load page.
     * @param {Object} [options.params] Extra parameters for ons-page.
     * @param {Function} done Take an object that has "element" property and "unload" function.
     */
    value: function load(_ref2, done) {
      var page = _ref2.page,
          parent = _ref2.parent,
          _ref2$params = _ref2.params,
          params = _ref2$params === undefined ? {} : _ref2$params;

      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
        if (!(pageElement instanceof Element)) {
          throw Error('pageElement must be an instance of Element.');
        }

        done(pageElement);
      });
    }
  }, {
    key: 'unload',
    value: function unload(pageElement) {
      if (!(pageElement instanceof Element)) {
        throw Error('pageElement must be an instance of Element.');
      }

      this._unloader(pageElement);
    }
  }, {
    key: 'internalLoader',
    set: function set(fn) {
      if (!(fn instanceof Function)) {
        throw Error('First parameter must be an instance of Function');
      }
      this._loader = fn;
    },
    get: function get() {
      return this._loader;
    }
  }]);
  return PageLoader;
}();

var defaultPageLoader = new PageLoader();

var instantPageLoader = new PageLoader(function (_ref3, done) {
  var page = _ref3.page,
      parent = _ref3.parent,
      _ref3$params = _ref3.params,
      params = _ref3$params === undefined ? {} : _ref3$params;

  var element = util.createElement(page.trim());
  parent.appendChild(element);

  done(element);
}, unloadPage);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons
 * @category util
 * @description
 *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
 *   [en]A global object that's used in Onsen UI. [/en]
 */
var ons$1 = {};

ons$1._util = util;
ons$1._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
ons$1._internal = internal$1;
ons$1.GestureDetector = GestureDetector;
ons$1.platform = platform;
ons$1.softwareKeyboard = softwareKeyboard;
ons$1.pageAttributeExpression = pageAttributeExpression;
ons$1.orientation = orientation;
ons$1.notification = notification;
ons$1._animationOptionsParser = parse;
ons$1._autoStyle = autoStyle;
ons$1._DoorLock = DoorLock;
ons$1._contentReady = contentReady;
ons$1.defaultPageLoader = defaultPageLoader;
ons$1.PageLoader = PageLoader;

ons$1._readyLock = new DoorLock();

ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

waitDeviceReady();

/**
 * @method isReady
 * @signature isReady()
 * @return {Boolean}
 *   [en]Will be true if Onsen UI is initialized.[/en]
 *   [ja]初期化されているかどうかを返します。[/ja]
 * @description
 *   [en]Returns true if Onsen UI is initialized.[/en]
 *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isReady = function () {
  return !ons$1._readyLock.isLocked();
};

/**
 * @method isWebView
 * @signature isWebView()
 * @return {Boolean}
 *   [en]Will be true if the app is running in Cordova.[/en]
 *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
 * @description
 *   [en]Returns true if running inside Cordova.[/en]
 *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isWebView = ons$1.platform.isWebView;

/**
 * @method ready
 * @signature ready(callback)
 * @description
 *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
 *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
 * @param {Function} callback
 *   [en]Function that executes after Onsen UI has been initialized.[/en]
 *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
 */
ons$1.ready = function (callback) {
  if (ons$1.isReady()) {
    callback();
  } else {
    ons$1._readyLock.waitUnlock(callback);
  }
};

/**
 * @method setDefaultDeviceBackButtonListener
 * @signature setDefaultDeviceBackButtonListener(listener)
 * @param {Function} listener
 *   [en]Function that executes when device back button is pressed.[/en]
 *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]Set default handler for device back button.[/en]
 *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
 */
ons$1.setDefaultDeviceBackButtonListener = function (listener) {
  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
};

/**
 * @method disableDeviceBackButtonHandler
 * @signature disableDeviceBackButtonHandler()
 * @description
 * [en]Disable device back button event handler.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
 */
ons$1.disableDeviceBackButtonHandler = function () {
  ons$1._deviceBackButtonDispatcher.disable();
};

/**
 * @method enableDeviceBackButtonHandler
 * @signature enableDeviceBackButtonHandler()
 * @description
 * [en]Enable device back button event handler.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
 */
ons$1.enableDeviceBackButtonHandler = function () {
  ons$1._deviceBackButtonDispatcher.enable();
};

/**
 * @method enableAutoStatusBarFill
 * @signature enableAutoStatusBarFill()
 * @description
 *   [en]Enable status bar fill feature on iOS7 and above.[/en]
 *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
 */
ons$1.enableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  ons$1._internal.config.autoStatusBarFill = true;
};

/**
 * @method disableAutoStatusBarFill
 * @signature disableAutoStatusBarFill()
 * @description
 *   [en]Disable status bar fill feature on iOS7 and above.[/en]
 *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
 */
ons$1.disableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  ons$1._internal.config.autoStatusBarFill = false;
};

/**
 * @method disableAnimations
 * @signature disableAnimations()
 * @description
 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
 *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
 */
ons$1.disableAnimations = function () {
  ons$1._internal.config.animationsDisabled = true;
};

/**
 * @method enableAnimations
 * @signature enableAnimations()
 * @description
 *   [en]Enable animations (default).[/en]
 *   [ja]アニメーションを有効にします。[/ja]
 */
ons$1.enableAnimations = function () {
  ons$1._internal.config.animationsDisabled = false;
};

/**
 * @method disableAutoStyling
 * @signature disableAutoStyling()
 * @description
 *   [en]Disable automatic styling.[/en]
 *   [ja][/ja]
 */
ons$1.disableAutoStyling = ons$1._autoStyle.disable;

/**
 * @method enableAutoStyling
 * @signature enableAutoStyling()
 * @description
 *   [en]Enable automatic styling based on OS (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAutoStyling = ons$1._autoStyle.enable;

/**
 * @method forcePlatformStyling
 * @signature forcePlatformStyling(platform)
 * @description
 *   [en]Refresh styling for the given platform.[/en]
 *   [ja][/ja]
 * @param {string} platform New platform to style the elements.
 */
ons$1.forcePlatformStyling = function (newPlatform) {
  ons$1.enableAutoStyling();
  ons$1.platform.select(newPlatform || 'ios');

  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
    if (element.tagName.toLowerCase() === 'ons-if') {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      ons$1._autoStyle.prepare(element, true);
      if (element.tagName.toLowerCase() === 'ons-tabbar') {
        element._updatePosition();
      }
    }
  });
};

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createPopoverOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var popover = div.querySelector('ons-popover');
    document.body.appendChild(popover);

    if (options.link instanceof Function) {
      options.link(popover);
    }

    return popover;
  });
};

/**
 * @method createPopover
 * @signature createPopover(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Object} [options.parentScope]
 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
 *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the popover component object.[/en]
 *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a popover instance from a template.[/en]
 *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
 */
ons$1.createPopover = ons$1._createPopoverOriginal;

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createDialogOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var dialog = div.querySelector('ons-dialog');
    document.body.appendChild(dialog);

    if (options.link instanceof Function) {
      options.link(dialog);
    }

    return dialog;
  });
};

/**
 * @method createDialog
 * @signature createDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a dialog instance from a template.[/en]
 *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createDialog = ons$1._createDialogOriginal;

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createAlertDialogOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var alertDialog = div.querySelector('ons-alert-dialog');
    document.body.appendChild(alertDialog);

    if (options.link instanceof Function) {
      options.link(alertDialog);
    }

    return alertDialog;
  });
};

/**
 * @method createAlertDialog
 * @signature createAlertDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the alert dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a alert dialog instance from a template.[/en]
 *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createAlertDialog = ons$1._createAlertDialogOriginal;

/**
 * @param {String} page
 * @param {Function} link
 */
ons$1._resolveLoadingPlaceholderOriginal = function (page, link) {
  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

  if (elements.length > 0) {
    elements.filter(function (element) {
      return !element.getAttribute('page');
    }).forEach(function (element) {
      element.setAttribute('ons-loading-placeholder', page);
      ons$1._resolveLoadingPlaceholder(element, page, link);
    });
  } else {
    throw new Error('No ons-loading-placeholder exists.');
  }
};

/**
 * @method resolveLoadingPlaceholder
 * @signature resolveLoadingPlaceholder(page)
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @description
 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
 *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
 */
ons$1.resolveLoadingPlaceholder = ons$1._resolveLoadingPlaceholderOriginal;

ons$1._setupLoadingPlaceHolders = function () {
  ons$1.ready(function () {
    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

    elements.forEach(function (element) {
      var page = element.getAttribute('ons-loading-placeholder');
      if (typeof page === 'string') {
        ons$1._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};

ons$1._resolveLoadingPlaceholder = function (element, page, link) {
  link = link || function (element, done) {
    done();
  };
  ons$1._internal.getPageHTMLAsync(page).then(function (html) {

    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }

    var contentElement = ons$1._util.createElement('<div>' + html + '</div>');
    contentElement.style.display = 'none';

    element.appendChild(contentElement);

    link(contentElement, function () {
      contentElement.style.display = '';
    });
  }).catch(function (error) {
    throw new Error('Unabled to resolve placeholder: ' + error);
  });
};

function waitDeviceReady() {
  var unlockDeviceReady = ons$1._readyLock.lock();
  window.addEventListener('DOMContentLoaded', function () {
    if (ons$1.isWebView()) {
      window.document.addEventListener('deviceready', unlockDeviceReady, false);
    } else {
      unlockDeviceReady();
    }
  }, false);
}

window._superSecretOns = ons$1;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    var _BaseElement = function _BaseElement() {};
    _BaseElement.prototype = document.createElement('div');
    return _BaseElement;
  } else {
    return HTMLElement;
  }
}

var BaseElement = function (_getElementClass) {
  inherits(BaseElement, _getElementClass);

  function BaseElement(self) {
    var _this, _ret;

    classCallCheck(this, BaseElement);

    self = (_this = possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this, self)), _this);
    self.init();
    return _ret = self, possibleConstructorReturn(_this, _ret);
  }

  createClass(BaseElement, [{
    key: 'init',
    value: function init() {}
  }]);
  return BaseElement;
}(getElementClass());

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-template
 * @category util
 * @description
 *   [en]
 *     Define a separate HTML fragment and use as a template.
 *
 *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
 *   [/en]
 *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @seealso ons-navigator
 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-tabbar
 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-splitter
 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
 *   [ja][/ja]
 * @example
 * <ons-template id="foobar.html">
 *   <ons-page>
 *     Page content
 *   </ons-page>
 * </ons-template>
 *
 * <ons-navigator page="foobar.html">
 * </ons-navigator>
 */

var TemplateElement = function (_BaseElement) {
  inherits(TemplateElement, _BaseElement);

  function TemplateElement() {
    classCallCheck(this, TemplateElement);
    return possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).apply(this, arguments));
  }

  createClass(TemplateElement, [{
    key: 'init',


    /**
     * @property template
     * @type {String}
     * @description
     *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      this.template = this.innerHTML;

      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
      event.template = this.template;
      event.templateId = this.getAttribute('id');

      this.dispatchEvent(event);
    }
  }]);
  return TemplateElement;
}(BaseElement);

customElements.define('ons-template', TemplateElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-if
 * @category conditional
 * @tutorial vanilla/Reference/if
 * @description
 *   [en]
 *     Conditionally display content depending on the platform, device orientation or both.
 *
 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
 *   [/en]
 *   [ja][/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-page>
 *   <ons-if orientation="landscape">
 *     Landscape view!
 *   </ons-if>
 *   <ons-if platform="android">
 *     This is Android.
 *   </ons-if>
 *   <ons-if platform="ios other">
 *     This is not Android.
 *   </ons-if>
 * </ons-page>
 */

var IfElement = function (_BaseElement) {
  inherits(IfElement, _BaseElement);

  function IfElement() {
    classCallCheck(this, IfElement);
    return possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).apply(this, arguments));
  }

  createClass(IfElement, [{
    key: 'init',


    /**
     * @attribute platform
     * @initonly
     * @type {string}
     * @description
     *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute orientation
     * @type {string}
     * @description
     *  [en]Either `"portrait"` or `"landscape"`.[/en]
     *  [ja]portraitもしくはlandscapeを指定します[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        if (platform._renderPlatform !== null) {
          _this2._platformUpdate();
        } else if (!_this2._isAllowedPlatform()) {
          while (_this2.childNodes[0]) {
            _this2.childNodes[0].remove();
          }
          _this2._platformUpdate();
        }
      });

      this._onOrientationChange();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      orientation.on('change', this._onOrientationChange.bind(this));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name) {
      if (name === 'orientation') {
        this._onOrientationChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      orientation.off('change', this._onOrientationChange);
    }
  }, {
    key: '_platformUpdate',
    value: function _platformUpdate() {
      this.style.display = this._isAllowedPlatform() ? '' : 'none';
    }
  }, {
    key: '_isAllowedPlatform',
    value: function _isAllowedPlatform() {
      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
    }
  }, {
    key: '_onOrientationChange',
    value: function _onOrientationChange() {
      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['orientation'];
    }
  }]);
  return IfElement;
}(BaseElement);

customElements.define('ons-if', IfElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AlertDialogAnimator = function () {
  function AlertDialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, AlertDialogAnimator);

    this.timing = timing;
    this.delay = delay;
    this.duration = duration;
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(AlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return AlertDialogAnimator;
}();

/**
 * Android style animator for alert dialog.
 */
var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

  function AndroidAlertDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, AndroidAlertDialogAnimator);
    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidAlertDialogAnimator;
}(AlertDialogAnimator);

/**
 * iOS style animator for alert dialog.
 */
var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

  function IOSAlertDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay;

    classCallCheck(this, IOSAlertDialogAnimator);
    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /*
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSAlertDialogAnimator;
}(AlertDialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme = {
  '.alert-dialog': 'alert-dialog--*',
  '.alert-dialog-container': 'alert-dialog-container--*',
  '.alert-dialog-title': 'alert-dialog-title--*',
  '.alert-dialog-content': 'alert-dialog-content--*',
  '.alert-dialog-footer': 'alert-dialog-footer--*',
  '.alert-dialog-button': 'alert-dialog-button--*',
  '.alert-dialog-footer--one': 'alert-dialog-footer--one--*',
  '.alert-dialog-button--one': 'alert-dialog-button--one--*',
  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
  '.alert-dialog-mask': 'alert-dialog-mask--*',
  '.text-input': 'text-input--*'
};

var _animatorDict = {
  'none': AlertDialogAnimator,
  'default': function _default() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  }
};

/**
 * @element ons-alert-dialog
 * @category dialog
 * @description
 *   [en]
 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
 *   [/en]
 *   [ja][/ja]
 * @codepen Qwwxyp
 * @tutorial vanilla/Reference/dialog
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @seealso ons-dialog
 *   [en]ons-dialog component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]ons-popover component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons.notification
 *   [en]Using ons.notification utility functions.[/en]
 *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
 * @example
 * <ons-alert-dialog id="alert-dialog">
 *   <div class="alert-dialog-title">Warning!</div>
 *   <div class="alert-dialog-content">
 *     An error has occurred!
 *   </div>
 *   <div class="alert-dialog-footer">
 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
 *   </div>
 * </ons-alert-dialog>
 * <script>
 *   document.getElementById('alert-dialog').show();
 * </script>
 */

var AlertDialogElement = function (_BaseElement) {
  inherits(AlertDialogElement, _BaseElement);

  function AlertDialogElement() {
    classCallCheck(this, AlertDialogElement);
    return possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).apply(this, arguments));
  }

  createClass(AlertDialogElement, [{
    key: 'init',


    /**
     * @event preshow
     * @description
     *   [en]Fired just before the alert dialog is displayed.[/en]
     *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute to stop the dialog from showing.[/en]
     *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
     */

    /**
     * @event postshow
     * @description
     *   [en]Fired just after the alert dialog is displayed.[/en]
     *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     */

    /**
     * @event prehide
     * @description
     *   [en]Fired just before the alert dialog is hidden.[/en]
     *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute to stop the dialog from hiding.[/en]
     *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
     */

    /**
     * @event posthide
     * @description
     * [en]Fired just after the alert dialog is hidden.[/en]
     * [ja]アラートダイアログが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the dialog.[/en]
     *  [ja]ダイアログの見た目を指定します。[/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *  [en]If this attribute is set the dialog is disabled.[/en]
     *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
     *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute mask-color
     * @type {String}
     * @default rgba(0, 0, 0, 0.2)
     * @description
     *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
     *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._visible = false;
      this._doorLock = new DoorLock();
      this._boundCancel = this._cancel.bind(this);

      this._updateAnimatorFactory();
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict,
        baseClass: AlertDialogAnimator,
        baseClassName: 'AlertDialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';

      /**
       * Expected result after compile:
       *
       * <ons-alert-dialog style="none">
       *   <div class="alert-dialog-mask"></div>
       *   <div class="alert-dialog">
       *     <div class="alert-dialog-container">...</div>
       *   </div>
       * </ons-alert-dialog>
       */

      var content = document.createDocumentFragment();

      if (!this._mask && !this._dialog) {
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('alert-dialog-mask');
        this.insertBefore(mask, this.children[0]);
      }

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('alert-dialog');
        this.insertBefore(dialog, null);
      }

      if (!util.findChild(this._dialog, '.alert-dialog-container')) {
        var container = document.createElement('div');
        container.classList.add('alert-dialog-container');
        this._dialog.appendChild(container);
      }

      this._dialog.children[0].appendChild(content);

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      if (this.getAttribute('mask-color')) {
        this._mask.style.backgroundColor = this.getAttribute('mask-color');
      }

      ModifierUtil.initModifier(this, scheme);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'show',


    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクトです。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Show the alert dialog.[/en]
     *   [ja]ダイアログを表示します。[/ja]
     * @return {Promise}
     *   [en]A `Promise` object that resolves to the displayed element.[/en]
     *   [ja][/ja]
     */
    value: function show() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel2 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'preshow', {
        alertDialog: this,
        cancel: function cancel() {
          _cancel2 = true;
        }
      });

      if (!_cancel2) {
        var _ret = function () {
          var tryShow = function tryShow() {
            var unlock = _this3._doorLock.lock();
            var animator = _this3._animatorFactory.newAnimator(options);

            _this3.style.display = 'block';
            _this3._mask.style.opacity = '1';

            return new Promise(function (resolve) {
              contentReady(_this3, function () {
                animator.show(_this3, function () {
                  _this3._visible = true;
                  unlock();

                  util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

                  callback();
                  resolve(_this3);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this3._doorLock.waitUnlock(function () {
                return resolve(tryShow());
              });
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      } else {
        return Promise.reject('Canceled in preshow event.');
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been hidden.[/en]
     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Hide the alert dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel3 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'prehide', {
        alertDialog: this,
        cancel: function cancel() {
          _cancel3 = true;
        }
      });

      if (!_cancel3) {
        var _ret2 = function () {
          var tryHide = function tryHide() {
            var unlock = _this4._doorLock.lock();
            var animator = _this4._animatorFactory.newAnimator(options);

            return new Promise(function (resolve) {
              contentReady(_this4, function () {
                animator.hide(_this4, function () {
                  _this4.style.display = 'none';
                  _this4._visible = false;
                  unlock();

                  util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

                  callback();
                  resolve(_this4);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this4._doorLock.waitUnlock(function () {
                return resolve(tryHide());
              });
            })
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      } else {
        return Promise.reject('Canceled in prehide event.');
      }
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this5 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this5._running = false;
          util.triggerElementEvent(_this5, 'dialog-cancel');
        }, function () {
          return _this5._running = false;
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this.onDeviceBackButton = function (e) {
        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
      };

      contentReady(this, function () {
        _this6._mask.addEventListener('click', _this6._boundCancel, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme);
      } else if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_mask',
    get: function get() {
      return util.findChild(this, '.alert-dialog-mask');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_dialog',
    get: function get() {
      return util.findChild(this, '.alert-dialog');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_titleElement',
    get: function get() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-title');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_contentElement',
    get: function get() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-content');
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
      }
      _animatorDict[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'animation'];
    }
  }, {
    key: 'AlertDialogAnimator',
    get: function get() {
      return AlertDialogAnimator;
    }
  }]);
  return AlertDialogElement;
}(BaseElement);

customElements.define('ons-alert-dialog', AlertDialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$1 = {
  '': 'back-button--*',
  '.back-button__icon': 'back-button--*__icon',
  '.back-button__label': 'back-button--*__label'
};

/**
 * @element ons-back-button
 * @category navigation
 * @description
 *   [en]
 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
 *
 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/navigator
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]ons-toolbar component[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-navigator
 *   [en]ons-navigator component[/en]
 *   [ja]ons-navigatorコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-back-button>Back</ons-back-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   <div>
 * </ons-toolbar>
 */

var BackButtonElement = function (_BaseElement) {
  inherits(BackButtonElement, _BaseElement);

  function BackButtonElement() {
    classCallCheck(this, BackButtonElement);
    return possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).apply(this, arguments));
  }

  createClass(BackButtonElement, [{
    key: 'init',

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the back button.[/en]
     *  [ja]バックボタンの見た目を指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._options = {};
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add('back-button');

      if (!util.findChild(this, '.back-button__label')) {
        var label = util.create('span.back-button__label');

        while (this.childNodes[0]) {
          label.appendChild(this.childNodes[0]);
        }
        this.appendChild(label);
      }

      if (!util.findChild(this, '.back-button__icon')) {
        var icon = util.create('span.back-button__icon');

        this.insertBefore(icon, this.children[0]);
      }

      ModifierUtil.initModifier(this, scheme$1);
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Options object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @property options.refresh
     * @description
     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
     */

  }, {
    key: '_onClick',


    /**
     * @property onClick
     * @type {Function}
     * @description
     *   [en]Used to override the default back button behavior.[/en]
     *   [ja][/ja]
     */
    value: function _onClick() {
      if (this.onClick) {
        this.onClick.apply(this);
      } else {
        var navigator = util.findParent(this, 'ons-navigator');
        if (navigator) {
          navigator.popPage(this.options);
        }
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$1);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'show',
    value: function show() {
      this.style.display = 'inline-block';
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.style.display = 'none';
    }
  }, {
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(object) {
      this._options = object;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return BackButtonElement;
}(BaseElement);

customElements.define('ons-back-button', BackButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$2 = { '': 'bottom-bar--*' };

/**
 * @element ons-bottom-toolbar
 * @category page
 * @description
 *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
 *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
 * @modifier transparent
 *   [en]Make the toolbar transparent.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
 * @example
 * <ons-bottom-toolbar>
 *   Content
 * </ons-bottom-toolbar>
 */

var BottomToolbarElement = function (_BaseElement) {
  inherits(BottomToolbarElement, _BaseElement);

  function BottomToolbarElement() {
    classCallCheck(this, BottomToolbarElement);
    return possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).apply(this, arguments));
  }

  createClass(BottomToolbarElement, [{
    key: 'init',

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the toolbar.[/en]
     *   [ja]ツールバーの見た目の表現を指定します。[/ja]
     */

    value: function init() {
      this.classList.add('bottom-bar');
      ModifierUtil.initModifier(this, scheme$2);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (util.match(this.parentNode, 'ons-page')) {
        this.parentNode.classList.add('page-with-bottom-toolbar');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$2);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return BottomToolbarElement;
}(BaseElement);

customElements.define('ons-bottom-toolbar', BottomToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$3 = { '': 'button--*' };

/**
 * @element ons-button
 * @category form
 * @modifier outline
 *   [en]Button with outline and transparent background[/en]
 *   [ja]アウトラインを持ったボタンを表示します。[/ja]
 * @modifier light
 *   [en]Button that doesn't stand out.[/en]
 *   [ja]目立たないボタンを表示します。[/ja]
 * @modifier quiet
 *   [en]Button with no outline and or background..[/en]
 *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
 * @modifier cta
 *   [en]Button that really stands out.[/en]
 *   [ja]目立つボタンを表示します。[/ja]
 * @modifier large
 *   [en]Large button that covers the width of the screen.[/en]
 *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
 * @modifier large--quiet
 *   [en]Large quiet button.[/en]
 *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
 * @modifier large--cta
 *   [en]Large call to action button.[/en]
 *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
 * @modifier material
 *   [en]Material Design button[/en]
 *   [ja]マテリアルデザインのボタン[/ja]
 * @modifier material--flat
 *   [en]Material Design flat button[/en]
 *   [ja]マテリアルデザインのフラットボタン[/ja]
 * @description
 *   [en]
 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
 *
 *     Will automatically display as a Material Design button with a ripple effect on Android.
 *   [/en]
 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/button
 * @guide Button [en]Guide for `<ons-button>`[/en][ja]<ons-button>の使い方[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-button modifier="large--cta">
 *   Tap Me
 * </ons-button>
 */

var ButtonElement = function (_BaseElement) {
  inherits(ButtonElement, _BaseElement);

  function ButtonElement() {
    classCallCheck(this, ButtonElement);
    return possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).apply(this, arguments));
  }

  createClass(ButtonElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add('button');

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$3);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple'];
    }
  }]);
  return ButtonElement;
}(BaseElement);

customElements.define('ons-button', ButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$4 = { '': 'carousel-item--*' };

/**
 * @element ons-carousel-item
 * @category carousel
 * @description
 *   [en]
 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel
 *   [en]`<ons-carousel>` components[/en]
 *   [ja]<ons-carousel>コンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselItemElement = function (_BaseElement) {
  inherits(CarouselItemElement, _BaseElement);

  function CarouselItemElement() {
    classCallCheck(this, CarouselItemElement);
    return possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).apply(this, arguments));
  }

  createClass(CarouselItemElement, [{
    key: 'init',
    value: function init() {
      this.style.width = '100%';
      ModifierUtil.initModifier(this, scheme$4);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$4);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return CarouselItemElement;
}(BaseElement);

customElements.define('ons-carousel-item', CarouselItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var VerticalModeTrait = {

  _getScrollDelta: function _getScrollDelta(event) {
    return event.gesture.deltaY;
  },

  _getScrollVelocity: function _getScrollVelocity(event) {
    return event.gesture.velocityY;
  },

  _getElementSize: function _getElementSize() {
    if (!this._currentElementSize) {
      this._currentElementSize = this.getBoundingClientRect().height;
    }

    return this._currentElementSize;
  },

  _generateScrollTransform: function _generateScrollTransform(scroll) {
    return 'translate3d(0px, ' + -scroll + 'px, 0px)';
  },

  _updateDimensionData: function _updateDimensionData() {
    this._style = window.getComputedStyle(this);
    this._dimensions = this.getBoundingClientRect();
  },

  _updateOffset: function _updateOffset() {
    if (this.centered) {
      var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
      this._offset = -(height - this._getCarouselItemSize()) / 2;
    }
  },

  _layoutCarouselItems: function _layoutCarouselItems() {
    var children = this._getCarouselItemElements();

    var sizeAttr = this._getCarouselItemSizeAttr();
    var sizeInfo = this._decomposeSizeString(sizeAttr);

    for (var i = 0; i < children.length; i++) {
      children[i].style.position = 'absolute';
      children[i].style.height = sizeAttr;
      children[i].style.visibility = 'visible';
      children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
    }
  },

  _setup: function _setup() {
    this._updateDimensionData();
    this._updateOffset();
    this._layoutCarouselItems();
  }
};

var HorizontalModeTrait = {

  _getScrollDelta: function _getScrollDelta(event) {
    return event.gesture.deltaX;
  },

  _getScrollVelocity: function _getScrollVelocity(event) {
    return event.gesture.velocityX;
  },

  _getElementSize: function _getElementSize() {
    if (!this._currentElementSize) {
      this._currentElementSize = this.getBoundingClientRect().width;
    }

    return this._currentElementSize;
  },

  _generateScrollTransform: function _generateScrollTransform(scroll) {
    return 'translate3d(' + -scroll + 'px, 0px, 0px)';
  },

  _updateDimensionData: function _updateDimensionData() {
    this._style = window.getComputedStyle(this);
    this._dimensions = this.getBoundingClientRect();
  },

  _updateOffset: function _updateOffset() {
    if (this.centered) {
      var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
      this._offset = -(width - this._getCarouselItemSize()) / 2;
    }
  },

  _layoutCarouselItems: function _layoutCarouselItems() {
    var children = this._getCarouselItemElements();

    var sizeAttr = this._getCarouselItemSizeAttr();
    var sizeInfo = this._decomposeSizeString(sizeAttr);

    for (var i = 0; i < children.length; i++) {
      children[i].style.position = 'absolute';
      children[i].style.width = sizeAttr;
      children[i].style.visibility = 'visible';
      children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
    }
  },

  _setup: function _setup() {
    this._updateDimensionData();
    this._updateOffset();
    this._layoutCarouselItems();
  }
};

/**
 * @element ons-carousel
 * @category carousel
 * @description
 *   [en]
 *     Carousel component. A carousel can be used to display several items in the same space.
 *
 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel-item
 *   [en]`<ons-carousel-item>` component[/en]
 *   [ja]ons-carousel-itemコンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselElement = function (_BaseElement) {
  inherits(CarouselElement, _BaseElement);

  function CarouselElement() {
    classCallCheck(this, CarouselElement);
    return possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).apply(this, arguments));
  }

  createClass(CarouselElement, [{
    key: 'init',


    /**
     * @event postchange
     * @description
     *   [en]Fired just after the current carousel item has changed.[/en]
     *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.carousel
     *   [en]Carousel object.[/en]
     *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
     * @param {Number} event.activeIndex
     *   [en]Current active index.[/en]
     *   [ja]現在アクティブになっている要素のインデックス。[/ja]
     * @param {Number} event.lastActiveIndex
     *   [en]Previous active index.[/en]
     *   [ja]以前アクティブだった要素のインデックス。[/ja]
     */

    /**
     * @event refresh
     * @description
     *   [en]Fired when the carousel has been refreshed.[/en]
     *   [ja]カルーセルが更新された時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.carousel
     *   [en]Carousel object.[/en]
     *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
     */

    /**
     * @event overscroll
     * @description
     *   [en]Fired when the carousel has been overscrolled.[/en]
     *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.carousel
     *   [en]Fired when the carousel has been refreshed.[/en]
     *   [ja]カルーセルが更新された時に発火します。[/ja]
     * @param {Number} event.activeIndex
     *   [en]Current active index.[/en]
     *   [ja]現在アクティブになっている要素のインデックス。[/ja]
     * @param {String} event.direction
     *   [en]Can be one of either "up", "down", "left" or "right".[/en]
     *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
     * @param {Function} event.waitToReturn
     *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
     *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
     *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
     */

    /**
     * @attribute fullscreen
     * @description
     *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
     *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
     */

    /**
     * @attribute overscrollable
     * @description
     *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
     *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
     */

    /**
     * @attribute centered
     * @description
     *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
     *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
     */

    /**
     * @attribute item-width
     * @type {String}
     * @description
     *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
     *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
     */

    /**
     * @attribute item-height
     * @type {String}
     * @description
     *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
     *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
     */

    /**
     * @attribute auto-scroll
     * @description
     *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
     *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
     */

    /**
     * @attribute auto-scroll-ratio
     * @type {Number}
     * @description
     *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
     *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @description
     *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
     *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set the carousel is disabled.[/en]
     *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
     */

    /**
     * @attribute initial-index
     * @initonly
     * @type {Number}
     * @description
     *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
     *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
     */

    /**
     * @attribute auto-refresh
     * @description
     *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
     *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    value: function init() {
      this._doorLock = new DoorLock();
      this._scroll = 0;
      this._offset = 0;
      this._lastActiveIndex = 0;

      this._boundOnDrag = this._onDrag.bind(this);
      this._boundOnDragEnd = this._onDragEnd.bind(this);
      this._boundOnResize = this._onResize.bind(this);

      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
    }
  }, {
    key: '_onResize',
    value: function _onResize() {
      var i = this._scroll / this._currentElementSize;
      delete this._currentElementSize;
      this.setActiveIndex(i);
    }
  }, {
    key: '_onDirectionChange',
    value: function _onDirectionChange() {
      if (this._isVertical()) {
        this.style.overflowX = 'auto';
        this.style.overflowY = '';
      } else {
        this.style.overflowX = '';
        this.style.overflowY = 'auto';
      }

      this.refresh();
    }
  }, {
    key: '_saveLastState',
    value: function _saveLastState() {
      this._lastState = {
        elementSize: this._getCarouselItemSize(),
        carouselElementCount: this.itemCount,
        width: this._getCarouselItemSize() * this.itemCount
      };
    }

    /**
     * @return {Number}
     */

  }, {
    key: '_getCarouselItemSize',
    value: function _getCarouselItemSize() {
      var sizeAttr = this._getCarouselItemSizeAttr();
      var sizeInfo = this._decomposeSizeString(sizeAttr);
      var elementSize = this._getElementSize();

      if (sizeInfo.unit === '%') {
        return Math.round(sizeInfo.number / 100 * elementSize);
      } else if (sizeInfo.unit === 'px') {
        return sizeInfo.number;
      } else {
        throw new Error('Invalid state');
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: '_getInitialIndex',
    value: function _getInitialIndex() {
      var index = parseInt(this.getAttribute('initial-index'), 10);

      if (typeof index === 'number' && !isNaN(index)) {
        return Math.max(Math.min(index, this.itemCount - 1), 0);
      } else {
        return 0;
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: '_getCarouselItemSizeAttr',
    value: function _getCarouselItemSizeAttr() {
      var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
      var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_decomposeSizeString',
    value: function _decomposeSizeString(size) {
      var matches = size.match(/^(\d+)(px|%)/);

      return {
        number: parseInt(matches[1], 10),
        unit: matches[2]
      };
    }
  }, {
    key: '_setupInitialIndex',
    value: function _setupInitialIndex() {
      this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
      this._lastActiveIndex = this._getInitialIndex();
      this._scrollTo(this._scroll);
    }

    /**
     * @method setActiveIndex
     * @signature setActiveIndex(index, [options])
     * @param {Number} index
     *   [en]The index that the carousel should be set to.[/en]
     *   [ja]carousel要素のインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be called after the animation is finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

      index = Math.max(0, Math.min(index, this.itemCount - 1));
      var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
      var max = this._calculateMaxScroll();

      this._scroll = Math.max(0, Math.min(max, scroll));
      return this._scrollTo(this._scroll, options).then(function () {
        _this2._tryFirePostChangeEvent();
        return _this2;
      });
    }

    /**
     * @method getActiveIndex
     * @signature getActiveIndex()
     * @return {Number}
     *   [en]The current carousel item index.[/en]
     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
     * @description
     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
     */

  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      var scroll = this._scroll - (this._offset || 0);
      var count = this.itemCount;
      var size = this._getCarouselItemSize();

      if (scroll < 0) {
        return 0;
      }

      var i = void 0;
      for (i = 0; i < count; i++) {
        if (size * i <= scroll && size * (i + 1) > scroll) {
          return i;
        }
      }

      // max carousel index
      return i;
    }

    /**
     * @method next
     * @signature next([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show next `<ons-carousel-item>`.[/en]
     *   [ja]次のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'next',
    value: function next(options) {
      return this.setActiveIndex(this.getActiveIndex() + 1, options);
    }

    /**
     * @method prev
     * @signature prev([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show previous `<ons-carousel-item>`.[/en]
     *   [ja]前のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'prev',
    value: function prev(options) {
      return this.setActiveIndex(this.getActiveIndex() - 1, options);
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_isEnabledChangeEvent',
    value: function _isEnabledChangeEvent() {
      var elementSize = this._getElementSize();
      var carouselItemSize = this._getCarouselItemSize();

      return this.autoScroll && Math.abs(elementSize - carouselItemSize) < 0.5;
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_isVertical',
    value: function _isVertical() {
      return this.getAttribute('direction') === 'vertical';
    }
  }, {
    key: '_prepareEventListeners',
    value: function _prepareEventListeners() {
      var _this3 = this;

      this._gestureDetector = new GestureDetector(this, {
        dragMinDistance: 1,
        dragLockToAxis: true
      });
      this._mutationObserver = new MutationObserver(function () {
        return _this3.refresh();
      });

      this._updateSwipeable();
      this._updateAutoRefresh();

      window.addEventListener('resize', this._boundOnResize, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._gestureDetector.dispose();
      this._gestureDetector = null;

      this._mutationObserver.disconnect();
      this._mutationObserver = null;

      window.removeEventListener('resize', this._boundOnResize, true);
    }
  }, {
    key: '_updateSwipeable',
    value: function _updateSwipeable() {
      if (this._gestureDetector) {
        if (this.swipeable) {
          this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
          this._gestureDetector.on('dragend', this._boundOnDragEnd);
        } else {
          this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
          this._gestureDetector.off('dragend', this._boundOnDragEnd);
        }
      }
    }
  }, {
    key: '_updateAutoRefresh',
    value: function _updateAutoRefresh() {
      if (this._mutationObserver) {
        if (this.hasAttribute('auto-refresh')) {
          this._mutationObserver.observe(this, { childList: true });
        } else {
          this._mutationObserver.disconnect();
        }
      }
    }
  }, {
    key: '_tryFirePostChangeEvent',
    value: function _tryFirePostChangeEvent() {
      var currentIndex = this.getActiveIndex();

      if (this._lastActiveIndex !== currentIndex) {
        var lastActiveIndex = this._lastActiveIndex;
        this._lastActiveIndex = currentIndex;

        util.triggerElementEvent(this, 'postchange', {
          carousel: this,
          activeIndex: currentIndex,
          lastActiveIndex: lastActiveIndex
        });
      }
    }
  }, {
    key: '_isWrongDirection',
    value: function _isWrongDirection(d) {
      // this._lastDragDirection = d;
      return this._isVertical() ? d === 'left' || d === 'right' : d === 'up' || d === 'down';
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      if (this._isWrongDirection(event.gesture.direction)) {
        return;
      }

      event.stopPropagation();

      this._lastDragEvent = event;

      var scroll = this._scroll - this._getScrollDelta(event);
      this._scrollTo(scroll);
      event.gesture.preventDefault();

      this._tryFirePostChangeEvent();
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      var _this4 = this;

      if (!this._lastDragEvent) {
        return;
      }
      this._currentElementSize = undefined;
      this._scroll = this._scroll - this._getScrollDelta(event);

      // if (!this._isWrongDirection(this._lastDragDirection) && this._getScrollDelta(event) !== 0) {
      //   event.stopPropagation();
      // }

      if (this._isOverScroll(this._scroll)) {
        var waitForAction = false;
        util.triggerElementEvent(this, 'overscroll', {
          carousel: this,
          activeIndex: this.getActiveIndex(),
          direction: this._getOverScrollDirection(),
          waitToReturn: function waitToReturn(promise) {
            waitForAction = true;
            promise.then(function () {
              return _this4._scrollToKillOverScroll();
            });
          }
        });

        if (!waitForAction) {
          this._scrollToKillOverScroll();
        }
      } else {
        this._startMomentumScroll();
      }
      this._lastDragEvent = null;

      event.gesture.preventDefault();
    }

    /**
     * @param {Object} trait
     */

  }, {
    key: '_mixin',
    value: function _mixin(trait) {
      Object.keys(trait).forEach(function (key) {
        this[key] = trait[key];
      }.bind(this));
    }
  }, {
    key: '_startMomentumScroll',
    value: function _startMomentumScroll() {
      if (this._lastDragEvent) {
        var velocity = this._getScrollVelocity(this._lastDragEvent);
        var duration = 0.3;
        var scrollDelta = duration * 100 * velocity;
        var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

        this._scroll = scroll;

        animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(this._scroll)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .7, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
      }
    }
  }, {
    key: '_normalizeScrollPosition',
    value: function _normalizeScrollPosition(scroll) {
      var max = this._calculateMaxScroll();

      if (!this.autoScroll) {
        return Math.max(0, Math.min(max, scroll));
      }
      var arr = [];
      var size = this._getCarouselItemSize();
      var nbrOfItems = this.itemCount;

      for (var i = 0; i < nbrOfItems; i++) {
        if (i * size + this._offset < max) {
          arr.push(i * size + this._offset);
        }
      }
      arr.push(max);

      arr.sort(function (left, right) {
        left = Math.abs(left - scroll);
        right = Math.abs(right - scroll);

        return left - right;
      });

      arr = arr.filter(function (item, pos) {
        return !pos || item != arr[pos - 1];
      });

      var lastScroll = this._lastActiveIndex * size + this._offset;
      var scrollRatio = Math.abs(scroll - lastScroll) / size;
      var result = arr[0];

      if (scrollRatio <= this.autoScrollRatio) {
        result = lastScroll;
      } else if (scrollRatio < 1.0) {
        if (arr[0] === lastScroll && arr.length > 1) {
          result = arr[1];
        }
      }

      return Math.max(0, Math.min(max, result));
    }

    /**
     * @return {Array}
     */

  }, {
    key: '_getCarouselItemElements',
    value: function _getCarouselItemElements() {
      return util.arrayFrom(this.children).filter(function (child) {
        return child.nodeName.toLowerCase() === 'ons-carousel-item';
      });
    }

    /**
     * @param {Number} scroll
     * @param {Object} [options]
     * @return {Promise} Resolves to the carousel element
     */

  }, {
    key: '_scrollTo',
    value: function _scrollTo(scroll) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isOverscrollable = this.overscrollable;

      var normalizeScroll = function normalizeScroll(scroll) {
        var ratio = 0.35;

        if (scroll < 0) {
          return isOverscrollable ? Math.round(scroll * ratio) : 0;
        }

        var maxScroll = _this5._calculateMaxScroll();
        if (maxScroll < scroll) {
          return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
        }

        return scroll;
      };

      return new Promise(function (resolve) {
        animit(_this5._getCarouselItemElements()).queue({
          transform: _this5._generateScrollTransform(normalizeScroll(scroll))
        }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
          if (options.callback instanceof Function) {
            options.callback();
          }
          resolve();
        });
      });
    }
  }, {
    key: '_calculateMaxScroll',
    value: function _calculateMaxScroll() {
      var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
    }
  }, {
    key: '_isOverScroll',
    value: function _isOverScroll(scroll) {
      if (scroll < 0 || scroll > this._calculateMaxScroll()) {
        return true;
      }
      return false;
    }
  }, {
    key: '_getOverScrollDirection',
    value: function _getOverScrollDirection() {
      if (this._isVertical()) {
        return this._scroll <= 0 ? 'up' : 'down';
      } else {
        return this._scroll <= 0 ? 'left' : 'right';
      }
    }
  }, {
    key: '_scrollToKillOverScroll',
    value: function _scrollToKillOverScroll() {
      var duration = 0.4;

      if (this._scroll < 0) {
        animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(0)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .4, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
        this._scroll = 0;
        return;
      }

      var maxScroll = this._calculateMaxScroll();

      if (maxScroll < this._scroll) {
        animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(maxScroll)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .4, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
        this._scroll = maxScroll;
        return;
      }

      return;
    }

    /**
     * @property itemCount
     * @readonly
     * @type {Number}
     * @description
     *   [en]The number of carousel items.[/en]
     *   [ja]カルーセル要素の数です。[/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
     */
    value: function refresh() {
      // Bug fix
      if (this._getCarouselItemSize() === 0) {
        return;
      }

      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
      this._setup();

      if (this._lastState && this._lastState.width > 0) {
        var scroll = this._scroll; // - this._offset;

        if (this._isOverScroll(scroll)) {
          this._scrollToKillOverScroll();
        } else {
          if (this.autoScroll) {
            scroll = this._normalizeScrollPosition(scroll);
          }

          this._scrollTo(scroll);
        }
      }

      this._saveLastState();

      util.triggerElementEvent(this, 'refresh', { carousel: this });
    }

    /**
     * @method first
     * @signature first()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show first `<ons-carousel-item>`.[/en]
     *   [ja]最初のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'first',
    value: function first(options) {
      return this.setActiveIndex(0, options);
    }

    /**
     * @method last
     * @signature last()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja]Resolves to the carousel element[/ja]
     * @description
     *   [en]Show last ons-carousel item.[/en]
     *   [ja]最後のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'last',
    value: function last(options) {
      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this._prepareEventListeners();

      this._setup();
      this._setupInitialIndex();

      this._saveLastState();

      // Fix rendering glitch on Android 4.1
      if (this.offsetHeight === 0) {
        setImmediate(function () {
          return _this6.refresh();
        });
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'swipeable':
          this._updateSwipeable();
          break;
        case 'auto-refresh':
          this._updateAutoRefresh();
          break;
        case 'direction':
          this._onDirectionChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._removeEventListeners();
    }

    /**
     * @property autoScrollRatio
     * @type {Number}
     * @description
     *   [en]The current auto scroll ratio. [/en]
     *   [ja]現在のオートスクロールのratio値。[/ja]
     */

  }, {
    key: 'itemCount',
    get: function get() {
      return this._getCarouselItemElements().length;
    }
  }, {
    key: 'autoScrollRatio',
    get: function get() {
      var attr = this.getAttribute('auto-scroll-ratio');

      if (!attr) {
        return 0.5;
      }

      var scrollRatio = parseFloat(attr);
      if (scrollRatio < 0.0 || scrollRatio > 1.0) {
        throw new Error('Invalid ratio.');
      }

      return isNaN(scrollRatio) ? 0.5 : scrollRatio;
    },
    set: function set(ratio) {
      if (ratio < 0.0 || ratio > 1.0) {
        throw new Error('Invalid ratio.');
      }

      this.setAttribute('auto-scroll-ratio', ratio);
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]true if the carousel is swipeable.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get() {
      return this.hasAttribute('swipeable');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property autoScroll
     * @type {Boolean}
     * @description
     *   [en]true if auto scroll is enabled.[/en]
     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
     */

  }, {
    key: 'autoScroll',
    get: function get() {
      return this.hasAttribute('auto-scroll');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'auto-scroll', value);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get() {
      return this.hasAttribute('disabled');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    }

    /**
     * @property overscrollable
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is overscrollable or not.[/en]
     *   [ja]overscrollできればtrueを返します。[/ja]
     */

  }, {
    key: 'overscrollable',
    get: function get() {
      return this.hasAttribute('overscrollable');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'overscrollable', value);
    }

    /**
     * @property centered
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is centered or not.[/en]
     *   [ja]centered状態になっていればtrueを返します。[/ja]
     */

  }, {
    key: 'centered',
    get: function get() {
      return this.hasAttribute('centered');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'centered', value);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['swipeable', 'auto-refresh', 'direction'];
    }
  }]);
  return CarouselElement;
}(BaseElement);

customElements.define('ons-carousel', CarouselElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-col
 * @category grid
 * @description
 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
 *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
 * @codepen GgujC {wide}
 * @guide layouting [en]Layouting guide[/en][ja]レイアウト機能[/ja]
 * @seealso ons-row
 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
 *   [ja]ons-rowコンポーネント[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
 *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
 */

/**
 * @attribute width
 * @type {String}
 * @description
 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
 *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
 */

var ColElement = function (_BaseElement) {
  inherits(ColElement, _BaseElement);

  function ColElement() {
    classCallCheck(this, ColElement);
    return possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).apply(this, arguments));
  }

  createClass(ColElement, [{
    key: 'init',
    value: function init() {
      if (this.getAttribute('width')) {
        this._updateWidth();
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'width') {
        this._updateWidth();
      }
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      var width = this.getAttribute('width');
      if (typeof width === 'string') {
        width = ('' + width).trim();
        width = width.match(/^\d+$/) ? width + '%' : width;

        this.style.webkitBoxFlex = '0';
        this.style.webkitFlex = '0 0 ' + width;
        this.style.mozBoxFlex = '0';
        this.style.mozFlex = '0 0 ' + width;
        this.style.msFlex = '0 0 ' + width;
        this.style.flex = '0 0 ' + width;
        this.style.maxWidth = width;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['width'];
    }
  }]);
  return ColElement;
}(BaseElement);

customElements.define('ons-col', ColElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var DialogAnimator = function () {
  function DialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, DialogAnimator);

    this.timing = timing;
    this.delay = delay;
    this.duration = duration;
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(DialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return DialogAnimator;
}();

/**
 * Android style animator for dialog.
 */
var AndroidDialogAnimator = function (_DialogAnimator) {
  inherits(AndroidDialogAnimator, _DialogAnimator);

  function AndroidDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;

    classCallCheck(this, AndroidDialogAnimator);
    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidDialogAnimator;
}(DialogAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSDialogAnimator = function (_DialogAnimator2) {
  inherits(IOSDialogAnimator, _DialogAnimator2);

  function IOSDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;

    classCallCheck(this, IOSDialogAnimator);
    return possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, 300%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, 300%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSDialogAnimator;
}(DialogAnimator);

/**
 * Slide animator for dialog.
 */
var SlideDialogAnimator = function (_DialogAnimator3) {
  inherits(SlideDialogAnimator, _DialogAnimator3);

  function SlideDialogAnimator() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$timing = _ref4.timing,
        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;

    classCallCheck(this, SlideDialogAnimator);
    return possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(SlideDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3D(-50%, -350%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      animit.runAll(animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-50%, -350%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return SlideDialogAnimator;
}(DialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$5 = {
  '.dialog': 'dialog--*',
  '.dialog-container': 'dialog-container--*',
  '.dialog-mask': 'dialog-mask--*'
};

var _animatorDict$1 = {
  'default': function _default() {
    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
  },
  'slide': SlideDialogAnimator,
  'none': DialogAnimator
};

/**
 * @element ons-dialog
 * @category dialog
 * @description
 *   [en]
 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<ons-template>` tag.
 *
 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
 *
 *     It will automatically be displayed as Material Design when running on an Android device.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design dialog.[/en]
 *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
 * @codepen zxxaGa
 * @tutorial vanilla/Reference/dialog
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-alert-dialog
 *   [en]`<ons-alert-dialog>` component[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-dialog id="dialog">
 *   <p>This is a dialog!</p>
 * </ons-dialog>
 *
 * <script>
 *   document.getElementById('dialog').show();
 * </script>
 */

var DialogElement = function (_BaseElement) {
  inherits(DialogElement, _BaseElement);

  function DialogElement() {
    classCallCheck(this, DialogElement);
    return possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).apply(this, arguments));
  }

  createClass(DialogElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._visible = false;
      this._doorLock = new DoorLock();
      this._boundCancel = this._cancel.bind(this);

      this._updateAnimatorFactory();
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$1,
        baseClass: DialogAnimator,
        baseClassName: 'DialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';

      /* Expected result:
       *   <ons-dialog>
       *     <div class="dialog-mask"></div>
       *     <div class="dialog">
       *       <div class="dialog-container">...</div>
       *     </div>
       *   </ons-dialog>
       */

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('dialog');

        var container = document.createElement('div');
        dialog.classList.add('dialog-container');

        dialog.appendChild(container);

        while (this.firstChild) {
          container.appendChild(this.firstChild);
        }

        this.appendChild(dialog);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('dialog-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      this.setAttribute('status-bar-fill', '');

      ModifierUtil.initModifier(this, scheme$5);
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this3 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this3._running = false;
          util.triggerElementEvent(_this3, 'dialog-cancel');
        }, function () {
          return _this3._running = false;
        });
      }
    }

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the dialog.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

  }, {
    key: 'show',
    value: function show() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel2 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'preshow', {
        dialog: this,
        cancel: function cancel() {
          _cancel2 = true;
        }
      });

      if (!_cancel2) {
        var _ret = function () {
          var tryShow = function tryShow() {
            var unlock = _this4._doorLock.lock();
            var animator = _this4._animatorFactory.newAnimator(options);

            _this4.style.display = 'block';
            _this4._mask.style.opacity = '1';

            return new Promise(function (resolve) {
              contentReady(_this4, function () {
                animator.show(_this4, function () {
                  _this4._visible = true;
                  unlock();

                  util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

                  callback();
                  resolve(_this4);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this4._doorLock.waitUnlock(function () {
                return resolve(tryShow());
              });
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      } else {
        return Promise.reject('Canceled in preshow event.');
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the dialog has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel3 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'prehide', {
        dialog: this,
        cancel: function cancel() {
          _cancel3 = true;
        }
      });

      if (!_cancel3) {
        var _ret2 = function () {
          var tryHide = function tryHide() {
            var unlock = _this5._doorLock.lock();
            var animator = _this5._animatorFactory.newAnimator(options);

            return new Promise(function (resolve) {
              contentReady(_this5, function () {
                animator.hide(_this5, function () {
                  _this5.style.display = 'none';
                  _this5._visible = false;
                  unlock();

                  util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

                  callback();
                  resolve(_this5);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this5._doorLock.waitUnlock(function () {
                return resolve(tryHide());
              });
            })
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      } else {
        return Promise.reject('Canceled in prehide event.');
      }
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this.onDeviceBackButton = function (e) {
        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
      };

      contentReady(this, function () {
        _this6._mask.addEventListener('click', _this6._boundCancel, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
      } else if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_mask',


    /**
     * @event preshow
     * @description
     * [en]Fired just before the dialog is displayed.[/en]
     * [ja]ダイアログが表示される直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute this function to stop the dialog from being shown.[/en]
     *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
     */

    /**
     * @event postshow
     * @description
     * [en]Fired just after the dialog is displayed.[/en]
     * [ja]ダイアログが表示された直後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event prehide
     * @description
     * [en]Fired just before the dialog is hidden.[/en]
     * [ja]ダイアログが隠れる直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute this function to stop the dialog from being hidden.[/en]
     *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
     */

    /**
     * @event posthide
     * @description
     * [en]Fired just after the dialog is hidden.[/en]
     * [ja]ダイアログが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the dialog.[/en]
     *  [ja]ダイアログの表現を指定します。[/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *  [en]If this attribute is set the dialog is disabled.[/en]
     *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
     *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @attribute mask-color
     * @type {String}
     * @default rgba(0, 0, 0, 0.2)
     * @description
     *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
     *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
     */

    get: function get() {
      return util.findChild(this, '.dialog-mask');
    }
  }, {
    key: '_dialog',
    get: function get() {
      return util.findChild(this, '.dialog');
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof DialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
      }
      _animatorDict$1[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'animation'];
    }
  }, {
    key: 'DialogAnimator',
    get: function get() {
      return DialogAnimator;
    }
  }]);
  return DialogElement;
}(BaseElement);

customElements.define('ons-dialog', DialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$6 = {
  '': 'fab--*'
};

/**
 * @element ons-fab
 * @category form
 * @description
 *   [en]
 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
 *
 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/fab
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
 *   [ja][/ja]
 */

var FabElement = function (_BaseElement) {
  inherits(FabElement, _BaseElement);

  function FabElement() {
    classCallCheck(this, FabElement);
    return possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).apply(this, arguments));
  }

  createClass(FabElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute position
     * @type {String}
     * @description
     *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this3 = this;

      autoStyle.prepare(this);

      this.classList.add('fab');

      if (!util.findChild(this, '.fab__icon')) {
        (function () {
          var content = document.createElement('span');
          content.classList.add('fab__icon');

          util.arrayFrom(_this3.childNodes).forEach(function (element) {
            if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
              content.appendChild(element);
            }
          });
          _this3.appendChild(content);
        })();
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$6);

      this._updatePosition();

      this.show();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$6);
          break;
        case 'ripple':
          this._updateRipple();
          break;
        case 'position':
          this._updatePosition();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.hide();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *  [en]Show the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.style.transform = 'scale(1)';
      this.style.webkitTransform = 'scale(1)';
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *  [en]Hide the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.style.transform = 'scale(0)';
      this.style.webkitTransform = 'scale(0)';
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'toggle',


    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle the visibility of the button.[/en]
     *   [ja][/ja]
     */
    value: function toggle() {
      this.visible ? this.hide() : this.show();
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get() {
      return this.style.transform === 'scale(1)' && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'position'];
    }
  }]);
  return FabElement;
}(BaseElement);

customElements.define('ons-fab', FabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-gesture-detector
 * @category gesture
 * @description
 *   [en]
 *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
 *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
 *     - Hold gestures: `hold`, `release`
 *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
 *     - Tap gestures: `tap`, `doubletap`
 *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
 *     - Other gestures: `touch`, `transform`, `rotate`
 *   [/en]
 *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
 * @guide gesture-detector
 *   [en]Detecting finger gestures[/en]
 *   [ja]ジェスチャー操作の検知[/ja]
 * @example
 * <ons-gesture-detector>
 *   <div id="detect-area" style="width: 100px; height: 100px;">
 *     Swipe Here
 *   </div>
 * </ons-gesture-detector>
 *
 * <script>
 *   document.addEventListener('swipeleft', function(event) {
 *     if (event.target.matches('#detect-area')) {
 *       console.log('Swipe left is detected.');
 *     }
 *   });
 * </script>
 */

var GestureDetectorElement = function (_BaseElement) {
  inherits(GestureDetectorElement, _BaseElement);

  function GestureDetectorElement() {
    classCallCheck(this, GestureDetectorElement);
    return possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).apply(this, arguments));
  }

  createClass(GestureDetectorElement, [{
    key: 'init',
    value: function init() {
      this._gestureDetector = new GestureDetector(this);
    }
  }]);
  return GestureDetectorElement;
}(BaseElement);

customElements.define('ons-gesture-detector', GestureDetectorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-icon
 * @category visual
 * @description
 *   [en]
 *     Displays an icon. The following icon suites are available:
 *
 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
 *     * [Ionicons](http://ionicons.com/)
 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
 *   [/en]
 *   [ja][/ja]
 * @codepen xAhvg
 * @tutorial vanilla/Reference/icon
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-icon
 *   icon="md-car"
 *   size="20px"
 *   style="color: red">
 * </ons-icon>
 *
 * <ons-button>
 *   <ons-icon icon="md-car"></ons-icon>
 *   Car
 * </ons-button>
 */

var IconElement = function (_BaseElement) {
  inherits(IconElement, _BaseElement);

  function IconElement() {
    classCallCheck(this, IconElement);
    return possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).apply(this, arguments));
  }

  createClass(IconElement, [{
    key: 'init',


    /**
     * @attribute icon
     * @type {String}
     * @description
     *   [en]
     *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
     *
     *     See all available icons on their respective sites:
     *
     *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
     *     * [Ionicons](http://ionicons.com)
     *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
     *
     *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
     *
     *     The code:
     *
     *     ```
     *     <ons-icon
     *       icon="ion-edit, material:md-edit">
     *     </ons-icon>
     *     ```
     *
     *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute size
     * @type {String}
     * @description
     *   [en]
     *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
     *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
     *
     *     The code:
     *
     *     ```
     *     <ons-icon
     *       icon="ion-edit"
     *       size="32px, material:24px">
     *     </ons-icon>
     *     ```
     *
     *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute rotate
     * @type {Number}
     * @description
     *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
     *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
     */

    /**
     * @attribute fixed-width
     * @type {Boolean}
     * @default false
     * @description
     *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute spin
     * @description
     *   [en]Specify whether the icon should be spinning.[/en]
     *   [ja]アイコンを回転するかどうかを指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
        this._update();
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._update();
    }
  }, {
    key: '_update',
    value: function _update() {
      var _this2 = this;

      this._cleanClassAttribute();

      var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size')),
          classList = _buildClassAndStyle2.classList,
          style = _buildClassAndStyle2.style;

      util.extend(this.style, style);

      classList.forEach(function (className) {
        return _this2.classList.add(className);
      });
    }
  }, {
    key: '_getAttribute',
    value: function _getAttribute(attr) {
      var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
      var def = parts[0];
      var md = parts[1];
      md = (md || '').split(/\s*:\s*/);
      return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
    }

    /**
     * Remove unneeded class value.
     */

  }, {
    key: '_cleanClassAttribute',
    value: function _cleanClassAttribute() {
      var _this3 = this;

      util.arrayFrom(this.classList).filter(function (className) {
        return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
        );
      }).forEach(function (className) {
        return _this3.classList.remove(className);
      });

      this.classList.remove('zmdi');
      this.classList.remove('ons-icon--ion');
    }
  }, {
    key: '_buildClassAndStyle',
    value: function _buildClassAndStyle(iconName, size) {
      var classList = ['ons-icon'];
      var style = {};

      // Icon
      if (iconName.indexOf('ion-') === 0) {
        classList.push(iconName);
        classList.push('ons-icon--ion');
      } else if (iconName.indexOf('fa-') === 0) {
        classList.push(iconName);
        classList.push('fa');
      } else if (iconName.indexOf('md-') === 0) {
        classList.push('zmdi');
        classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
      } else {
        classList.push('fa');
        classList.push('fa-' + iconName);
      }

      // Size
      if (size.match(/^[1-5]x|lg$/)) {
        classList.push('fa-' + size);
        this.style.removeProperty('font-size');
      } else {
        style.fontSize = size;
      }

      return {
        classList: classList,
        style: style
      };
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['icon', 'size', 'modifier'];
    }
  }]);
  return IconElement;
}(BaseElement);

customElements.define('ons-icon', IconElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @element ons-lazy-repeat
 * @category list
 * @description
 *   [en]
 *     Using this component a list with millions of items can be rendered without a drop in performance.
 *     It does that by "lazily" loading elements into the DOM when they come into view and
 *     removing items from the DOM when they are not visible.
 *   [/en]
 *   [ja]
 *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
 *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
 *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
 *   [/ja]
 * @codepen QwrGBm
 * @tutorial vanilla/Reference/lazy-repeat
 * @seealso ons-list
 *   [en]The `<ons-list>` element is used to render a list.[/en]
 *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
 * @guide infinite-scroll
 *   [en]Loading more items on infinite scroll[/en]
 *   [ja]Loading more items on infinite scroll[/ja]
 * @example
 * <script>
 *   window.addEventListener('load', function() {
 *     var lazyRepeat = document.querySelector('#list');
 *     lazyRepeat.delegate = {
 *      createItemContent: function(i, template) {
 *        var dom = template.cloneNode(true);
 *        dom.innerText = i;
 *
 *        return dom;
 *      },
 *      countItems: function() {
 *        return 10000000;
 *      },
 *      destroyItem: function(index, item) {
 *        console.log('Destroyed item with index: ' + index);
 *      }
 *     };
 *   });
 * </script>
 *
 * <ons-list id="list">
 *   <ons-lazy-repeat>
 *     <ons-list-item></ons-list-item>
 *   </ons-lazy-repeat>
 * </ons-list>
 */

var LazyRepeatElement = function (_BaseElement) {
  inherits(LazyRepeatElement, _BaseElement);

  function LazyRepeatElement() {
    classCallCheck(this, LazyRepeatElement);
    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
  }

  createClass(LazyRepeatElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      util.updateParentPosition(this);

      // not very good idea and also not documented
      if (this.hasAttribute('delegate')) {
        this.delegate = window[this.getAttribute('delegate')];
      }
    }

    /**
     * @property delegate
     * @type {Object}
     * @description
     *  [en]Specify a delegate object to load and unload item elements.[/en]
     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
     */

    /**
     * @property delegate.createItemContent
     * @type {Function}
     * @description
     *   [en]
     *     This function should return a `HTMLElement`.
     *
     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
     *   [/en]
     *   [ja]
     *     この関数は`HTMLElement`を返してください。
     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
     *   [/ja]
     */

    /**
     * @property delegate.countItems
     * @type {Function}
     * @description
     *   [en]Should return the number of items in the list.[/en]
     *   [ja]リスト内のアイテム数を返してください。[/ja]
     */

    /**
     * @property delegate.calculateItemHeight
     * @type {Function}
     * @description
     *   [en]
     *     Should return the height of an item. The index is provided as an argument.
     *
     *     This is important when rendering lists where the items have different height.
     *
     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
     *   [/en]
     *   [ja]
     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
     *     この関数はオプショナルです。もしこの関数が無い場合には、
     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
     *   [/ja]
     */

    /**
     * @property delegate.destroyItem
     * @type {Function}
     * @description
     *   [en]
     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
     *
     *     The function is optional but may be important in order to avoid memory leaks.
     *   [/en]
     *   [ja]
     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
     *     アイテムのインデックス値とDOM要素が引数として渡されます。
     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
     *   [/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Refresh the list. Use this method when the data has changed.[/en]
     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
     */
    value: function refresh() {
      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._lazyRepeatProvider) {
        this._lazyRepeatProvider.destroy();
        this._lazyRepeatProvider = null;
      }
    }
  }, {
    key: 'delegate',
    set: function set(userDelegate) {
      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

      if (!this._templateElement && this.children[0]) {
        this._templateElement = this.removeChild(this.children[0]);
      }

      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
    },
    get: function get() {
      throw new Error('This property can only be used to set the delegate object.');
    }
  }]);
  return LazyRepeatElement;
}(BaseElement);

customElements.define('ons-lazy-repeat', LazyRepeatElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$7 = { '': 'list__header--*' };

/**
 * @element ons-list-header
 * @category list
 * @description
 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
 *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
 * @seealso ons-list
 *   [en]The `<ons-list>` component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @guide lists [en]Using lists[/en][ja]リストを使う[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @modifier material
 *   [en]Display a Material Design list header.[/en]
 *   [ja][/ja]
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListHeaderElement = function (_BaseElement) {
  inherits(ListHeaderElement, _BaseElement);

  function ListHeaderElement() {
    classCallCheck(this, ListHeaderElement);
    return possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).apply(this, arguments));
  }

  createClass(ListHeaderElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list header.[/en]
     *   [ja]ヘッダーの表現を指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add('list__header');
      ModifierUtil.initModifier(this, scheme$7);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$7);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return ListHeaderElement;
}(BaseElement);

customElements.define('ons-list-header', ListHeaderElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$8 = {
  '.list__item': 'list__item--*',
  '.list__item__left': 'list__item--*__left',
  '.list__item__center': 'list__item--*__center',
  '.list__item__right': 'list__item--*__right',
  '.list__item__label': 'list__item--*__label',
  '.list__item__title': 'list__item--*__title',
  '.list__item__subtitle': 'list__item--*__subtitle',
  '.list__item__thumbnail': 'list__item--*__thumbnail',
  '.list__item__icon': 'list__item--*__icon'
};

/**
 * @element ons-list-item
 * @category list
 * @modifier tappable
 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
 *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
 * @modifier chevron
 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
 *   [ja][/ja]
 * @modifier longdivider
 *   [en]Displays a long horizontal divider between items.[/en]
 *   [ja][/ja]
 * @modifier nodivider
 *   [en]Removes the divider between list items.[/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design list item.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
 *
 *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
 *
 *     ```
 *     <ons-list-item>
 *       <div class="left">Left</div>
 *       <div class="center">Center</div>
 *       <div class="right">Right</div>
 *     </ons-list-item>
 *     ```
 *
 *     There is also a number of classes (prefixed with `list__item__*`) that help when putting things like icons and thumbnails into the list items.
 *   [/en]
 *   [ja][/ja]
 * @seealso ons-list
 *   [en]ons-list component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @guide lists
 *   [en]Using lists[/en]
 *   [ja]リストを使う[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list-item>
 *   <div class="left">
 *     <ons-icon icon="md-face" class="list__item__icon"></ons-icon>
 *   </div>
 *   <div class="center">
 *     <div class="list__item__title">Title</div>
 *     <div class="list__item__subtitle">Subtitle</div>
 *   </div>
 *   <div class="right">
 *     <ons-switch></ons-switch>
 *   </div>
 * </ons-list-item>
 */

var ListItemElement = function (_BaseElement) {
  inherits(ListItemElement, _BaseElement);

  function ListItemElement() {
    classCallCheck(this, ListItemElement);
    return possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).apply(this, arguments));
  }

  createClass(ListItemElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list item.[/en]
     *   [ja]各要素の表現を指定します。[/ja]
     */

    /**
     * @attribute lock-on-drag
     * @type {String}
     * @description
     *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
     *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
     */

    /**
     * @attribute tappable
     * @type {Boolean}
     * @description
     *   [en]Makes the element react to taps.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute tap-background-color
     * @type {Color}
     * @description
     *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add('list__item');

      var left = void 0,
          center = void 0,
          right = void 0;

      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('left')) {
          el.classList.add('list__item__left');
          left = el;
        } else if (el.classList.contains('center')) {
          center = el;
        } else if (el.classList.contains('right')) {
          el.classList.add('list__item__right');
          right = el;
        }
      }

      if (!center) {
        center = document.createElement('div');

        if (!left && !right) {
          while (this.childNodes[0]) {
            center.appendChild(this.childNodes[0]);
          }
        } else {
          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
            var _el = this.childNodes[_i];
            if (_el !== left && _el !== right) {
              center.insertBefore(_el, center.firstChild);
            }
          }
        }

        this.insertBefore(center, right || null);
      }

      center.classList.add('center');
      center.classList.add('list__item__center');

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$8);

      autoStyle.prepare(this);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$8);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('drag', this._onDrag);
      this.addEventListener('touchstart', this._onTouch);
      this.addEventListener('mousedown', this._onTouch);
      this.addEventListener('touchend', this._onRelease);
      this.addEventListener('touchmove', this._onRelease);
      this.addEventListener('touchcancel', this._onRelease);
      this.addEventListener('mouseup', this._onRelease);
      this.addEventListener('mouseout', this._onRelease);
      this.addEventListener('touchleave', this._onRelease);

      this._originalBackgroundColor = this.style.backgroundColor;

      this.tapped = false;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('drag', this._onDrag);
      this.removeEventListener('touchstart', this._onTouch);
      this.removeEventListener('mousedown', this._onTouch);
      this.removeEventListener('touchend', this._onRelease);
      this.removeEventListener('touchmove', this._onRelease);
      this.removeEventListener('touchcancel', this._onRelease);
      this.removeEventListener('mouseup', this._onRelease);
      this.removeEventListener('mouseout', this._onRelease);
      this.removeEventListener('touchleave', this._onRelease);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var gesture = event.gesture;
      // Prevent vertical scrolling if the users pans left or right.
      if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
        gesture.preventDefault();
      }
    }
  }, {
    key: '_onTouch',
    value: function _onTouch() {
      if (this.tapped) {
        return;
      }

      this.tapped = true;

      this.style.transition = this._transition;
      this.style.webkitTransition = this._transition;
      this.style.MozTransition = this._transition;

      if (this._tappable) {
        if (this.style.backgroundColor) {
          this._originalBackgroundColor = this.style.backgroundColor;
        }

        this.style.backgroundColor = this._tapBackgroundColor;
        this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease() {
      this.tapped = false;

      this.style.transition = '';
      this.style.webkitTransition = '';
      this.style.MozTransition = '';

      this.style.backgroundColor = this._originalBackgroundColor || '';
      this.style.boxShadow = '';
    }
  }, {
    key: '_shouldLockOnDrag',
    value: function _shouldLockOnDrag() {
      return this.hasAttribute('lock-on-drag');
    }
  }, {
    key: '_transition',
    get: function get() {
      return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
    }
  }, {
    key: '_tappable',
    get: function get() {
      return this.hasAttribute('tappable');
    }
  }, {
    key: '_tapBackgroundColor',
    get: function get() {
      return this.getAttribute('tap-background-color') || '#d9d9d9';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple'];
    }
  }]);
  return ListItemElement;
}(BaseElement);

customElements.define('ons-list-item', ListItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$9 = { '': 'list--*' };

/**
 * @element ons-list
 * @category list
 * @modifier inset
 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
 *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
 * @modifier noborder
 *   [en]A list with no borders at the top and bottom.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
 *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
 * @seealso ons-list-item
 *   [en]ons-list-item component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @seealso ons-lazy-repeat
 *   [en]ons-lazy-repeat component[/en]
 *   [ja]ons-lazy-repeatコンポーネント[/ja]
 * @guide lists
 *   [en]Using lists[/en]
 *   [ja]リストを使う[/ja]
 * @guide infinite-scroll
 *   [en]Loading more items on infinite scroll[/en]
 *   [ja]Loading more items on infinite scroll[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListElement = function (_BaseElement) {
  inherits(ListElement, _BaseElement);

  function ListElement() {
    classCallCheck(this, ListElement);
    return possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).apply(this, arguments));
  }

  createClass(ListElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list.[/en]
     *   [ja]リストの表現を指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add('list');
      ModifierUtil.initModifier(this, scheme$9);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$9);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return ListElement;
}(BaseElement);

customElements.define('ons-list', ListElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$10 = {
  '.text-input': 'text-input--*',
  '.text-input__label': 'text-input--*__label',
  '.radio-button': 'radio-button--*',
  '.radio-button__input': 'radio-button--*__input',
  '.radio-button__checkmark': 'radio-button--*__checkmark',
  '.checkbox': 'checkbox--*',
  '.checkbox__input': 'checkbox--*__input',
  '.checkbox__checkmark': 'checkbox--*__checkmark'
};

var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

/**
 * @element ons-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a text input.[/en]
 *  [ja][/ja]
 * @modifier transparent
 *  [en]Displays a transparent input. Works for Material Design.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
 *
 *    The component will automatically render as a Material Design input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @codepen ojQxLj
 * @tutorial vanilla/Reference/input
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @guide adding-page-content
 *   [en]Using form components[/en]
 *   [ja]フォームを使う[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-input placeholder="Username" float></ons-input>
 * <ons-input type="checkbox" checked></ons-input>
 */

var InputElement = function (_BaseElement) {
  inherits(InputElement, _BaseElement);

  function InputElement() {
    classCallCheck(this, InputElement);
    return possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).apply(this, arguments));
  }

  createClass(InputElement, [{
    key: 'init',


    /**
     * @attribute placeholder
     * @type {String}
     * @description
     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute float
     * @description
     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
     */

    /**
     * @attribute type
     * @type {String}
     * @description
     *  [en]
     *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
     *
     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
     *  [/en]
     *  [ja][/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using <label for="..."> elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute content-left
     * @description
     *  [en]The HTML content of `<ons-input>` is placed before the actual input as a label. Omit this to display it after the input.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
      });

      this._boundOnInput = this._onInput.bind(this);
      this._boundOnFocusin = this._onFocusin.bind(this);
      this._boundDelegateEvent = this._delegateEvent.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this.children.length !== 0) {
        return;
      }

      var helper = document.createElement('span');
      helper.classList.add('_helper');

      var container = document.createElement('label');
      container.appendChild(document.createElement('input'));
      container.appendChild(helper);

      var label = document.createElement('span');
      label.classList.add('input-label');

      util.arrayFrom(this.childNodes).forEach(function (element) {
        return label.appendChild(element);
      });
      this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

      this.appendChild(container);

      switch (this.getAttribute('type')) {
        case 'checkbox':
          this.classList.add('checkbox');
          this._input.classList.add('checkbox__input');
          this._helper.classList.add('checkbox__checkmark');
          this._updateBoundAttributes();
          break;

        case 'radio':
          this.classList.add('radio-button');
          this._input.classList.add('radio-button__input');
          this._helper.classList.add('radio-button__checkmark');
          this._updateBoundAttributes();
          break;

        default:
          this._input.classList.add('text-input');
          this._helper.classList.add('text-input__label');
          this._input.parentElement.classList.add('text-input__container');

          this._updateLabel();
          this._updateBoundAttributes();
          this._updateLabelClass();
          break;
      }

      if (this.hasAttribute('input-id')) {
        this._input.id = this.getAttribute('input-id');
      }

      ModifierUtil.initModifier(this, scheme$10);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      if (name === 'modifier') {
        return contentReady(this, function () {
          return ModifierUtil.onModifierChanged(last, current, _this3, scheme$10);
        });
      } else if (name === 'placeholder') {
        return contentReady(this, function () {
          return _this3._updateLabel();
        });
      }if (name === 'input-id') {
        contentReady(this, function () {
          return _this3._input.id = current;
        });
      }if (name === 'checked') {
        this.checked = current !== null;
      } else if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
        return contentReady(this, function () {
          return _this3._updateBoundAttributes();
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
          _this4._input.addEventListener('input', _this4._boundOnInput);
          _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
          _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
        }

        _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
        _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this5 = this;

      contentReady(this, function () {
        _this5._input.removeEventListener('input', _this5._boundOnInput);
        _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
        _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
        _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
      });
    }
  }, {
    key: '_setLabel',
    value: function _setLabel(value) {
      if (typeof this._helper.textContent !== 'undefined') {
        this._helper.textContent = value;
      } else {
        this._helper.innerText = value;
      }
    }
  }, {
    key: '_updateLabel',
    value: function _updateLabel() {
      this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this6 = this;

      INPUT_ATTRIBUTES.forEach(function (attr) {
        if (_this6.hasAttribute(attr)) {
          _this6._input.setAttribute(attr, _this6.getAttribute(attr));
        } else {
          _this6._input.removeAttribute(attr);
        }
      });
    }
  }, {
    key: '_updateLabelClass',
    value: function _updateLabelClass() {
      if (this.value === '') {
        this._helper.classList.remove('text-input--material__label--active');
      } else if (['checkbox', 'radio'].indexOf(this.getAttribute('type')) === -1) {
        this._helper.classList.add('text-input--material__label--active');
      }
    }
  }, {
    key: '_delegateEvent',
    value: function _delegateEvent(event) {
      var e = new CustomEvent(event.type, {
        bubbles: false,
        cancelable: true
      });

      return this.dispatchEvent(e);
    }
  }, {
    key: '_onInput',
    value: function _onInput(event) {
      this._updateLabelClass();
    }
  }, {
    key: '_onFocusin',
    value: function _onFocusin(event) {
      this._updateLabelClass();
    }
  }, {
    key: '_input',
    get: function get() {
      return this.querySelector('input');
    }
  }, {
    key: '_helper',
    get: function get() {
      return this.querySelector('._helper');
    }

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'value',
    get: function get() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set(val) {
      var _this7 = this;

      contentReady(this, function () {
        _this7._input.value = val;
        _this7._onInput();
      });
    }

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'checked',
    get: function get() {
      return this._input.checked;
    },
    set: function set(val) {
      var _this8 = this;

      contentReady(this, function () {
        _this8._input.checked = val;
      });
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: '_isTextInput',
    get: function get() {
      return this.type !== 'radio' && this.type !== 'checkbox';
    }
  }, {
    key: 'type',
    get: function get() {
      return this.getAttribute('type');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'placeholder', 'input-id', 'checked'].concat(INPUT_ATTRIBUTES);
    }
  }]);
  return InputElement;
}(BaseElement);

customElements.define('ons-input', InputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModalAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ModalAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, ModalAnimator);

    this.delay = 0;
    this.duration = 0.2;

    this.timing = options.timing || this.timing;
    this.duration = options.duration !== undefined ? options.duration : this.duration;
    this.delay = options.delay !== undefined ? options.delay : this.delay;
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ModalAnimator, [{
    key: "show",
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: "hide",
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ModalAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeModalAnimator = function (_ModalAnimator) {
  inherits(FadeModalAnimator, _ModalAnimator);

  function FadeModalAnimator(options) {
    classCallCheck(this, FadeModalAnimator);

    options.timing = options.timing || 'linear';
    options.duration = options.duration || '0.3';
    options.delay = options.delay || 0;

    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, options));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(FadeModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      animit(modal).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      animit(modal).queue({
        opacity: 1
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$11 = {
  '': 'modal--*',
  'modal__content': 'modal--*__content'
};

var _animatorDict$2 = {
  'default': ModalAnimator,
  'fade': FadeModalAnimator,
  'none': ModalAnimator
};

/**
 * @element ons-modal
 * @category dialog
 * @description
 *   [en]
 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
 *
 *     This component can be used to block user input while some operation is running or to show some information to the user.
 *   [/en]
 *   [ja]
 *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
 *     モーダルが表示されている間はイベント通知が行われません。
 *   [/ja]
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @seealso ons-dialog
 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
 *   [ja][/ja]
 * @codepen devIg
 * @example
 * <ons-modal id="modal">
 *   Modal content
 * </ons-modal>
 * <script>
 *   var modal = document.getElementById('modal');
 *   modal.show();
 * </script>
 */

var ModalElement = function (_BaseElement) {
  inherits(ModalElement, _BaseElement);

  function ModalElement() {
    classCallCheck(this, ModalElement);
    return possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).apply(this, arguments));
  }

  createClass(ModalElement, [{
    key: 'init',


    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
     *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade"を指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._doorLock = new DoorLock();

      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$2,
        baseClass: ModalAnimator,
        baseClassName: 'ModalAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      this.style.display = 'none';
      this.style.zIndex = 10001;
      this.classList.add('modal');

      if (!util.findChild(this, '.modal__content')) {
        var content = document.createElement('div');
        content.classList.add('modal__content');

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          content.insertBefore(node, null);
        }

        this.appendChild(content);
      }

      ModifierUtil.initModifier(this, scheme$11);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = function () {
        return undefined;
      };
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'show',


    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show modal.[/en]
     *   [ja]モーダルを表示します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */
    value: function show() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var callback = options.callback || function () {};

      var tryShow = function tryShow() {
        var unlock = _this3._doorLock.lock();
        var animator = _this3._animatorFactory.newAnimator(options);

        return new Promise(function (resolve) {
          contentReady(_this3, function () {
            _this3.style.display = 'table';
            animator.show(_this3, function () {
              unlock();

              util.propagateAction(_this3, '_show');
              callback();
              resolve(_this3);
            });
          });
        });
      };

      return new Promise(function (resolve) {
        _this3._doorLock.waitUnlock(function () {
          return resolve(tryShow());
        });
      });
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Toggle modal visibility.[/en]
     *   [ja]モーダルの表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      if (this.visible) {
        return this.hide.apply(this, arguments);
      } else {
        return this.show.apply(this, arguments);
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Hide modal.[/en]
     *   [ja]モーダルを非表示にします。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var callback = options.callback || function () {};

      var tryHide = function tryHide() {
        var unlock = _this4._doorLock.lock();
        var animator = _this4._animatorFactory.newAnimator(options);

        return new Promise(function (resolve) {
          contentReady(_this4, function () {
            animator.hide(_this4, function () {
              _this4.style.display = 'none';
              unlock();

              util.propagateAction(_this4, '_hide');
              callback();
              resolve(_this4);
            });
          });
        });
      };

      return new Promise(function (resolve) {
        _this4._doorLock.waitUnlock(function () {
          return resolve(tryHide());
        });
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
      }
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(handler) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this.style.display !== 'none';
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ModalAnimator)) {
        throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
      }
      _animatorDict$2[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }, {
    key: 'ModalAnimator',
    get: function get() {
      return ModalAnimator;
    }
  }]);
  return ModalElement;
}(BaseElement);

customElements.define('ons-modal', ModalElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NavigatorTransitionAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function NavigatorTransitionAnimator(options) {
    classCallCheck(this, NavigatorTransitionAnimator);

    options = util.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    this.timing = options.timing;
    this.duration = options.duration;
    this.delay = options.delay;
  }

  createClass(NavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }], [{
    key: 'extend',
    value: function extend() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


      var extendedAnimator = this;
      var newAnimator = function newAnimator() {
        extendedAnimator.apply(this, arguments);
        util.extend(this, properties);
      };

      newAnimator.prototype = this.prototype;

      return newAnimator;
    }
  }]);
  return NavigatorTransitionAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition like iOS's screen slide transition.
 */

var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSSlideNavigatorTransitionAnimator(options) {
    classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

    options = util.extend({
      duration: 0.4,
      timing: 'ease',
      delay: 0
    }, options || {});

    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator)).call(this, options));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');
    return _this;
  }

  createClass(IOSSlideNavigatorTransitionAnimator, [{
    key: '_decompose',
    value: function _decompose(page) {
      var toolbar = page._getToolbarElement();
      var left = toolbar._getToolbarLeftItemsElement();
      var right = toolbar._getToolbarRightItemsElement();

      var excludeBackButton = function excludeBackButton(elements) {
        var result = [];

        for (var i = 0; i < elements.length; i++) {
          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
            result.push(elements[i]);
          }
        }

        return result;
      };

      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

      return {
        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
        other: other,
        content: page._getContentElement(),
        background: page._getBackgroundElement(),
        toolbar: toolbar,
        bottomToolbar: page._getBottomToolbarElement()
      };
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar(enterPage, leavePage) {
      var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

      var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

      return bothPageHasToolbar && noMaterialToolbar;
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta(element, decomposition) {
      var title = void 0,
          label = void 0;

      var pageRect = element.getBoundingClientRect();
      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
      } else {
        title = Math.round(pageRect.width / 2 * 0.6);
      }

      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
      }

      return { title: title, label: label };
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

      contentReady(enterPage, function () {
        var enterPageDecomposition = _this2._decompose(enterPage);
        var leavePageDecomposition = _this2._decompose(leavePage);

        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

        var maskClear = animit(_this2.backgroundMask).saveStyle().queue({
          opacity: 0,
          transform: 'translate3d(0, 0, 0)'
        }).wait(_this2.delay).queue({
          opacity: 0.05
        }, {
          duration: _this2.duration,
          timing: _this2.timing
        }).restoreStyle().queue(function (done) {
          _this2.backgroundMask.remove();
          done();
        });

        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPage, leavePage);

        if (shouldAnimateToolbar) {
          // TODO: Remove this fix
          var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
          _this2.backgroundMask.style.top = enterPageToolbarHeight;

          animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(enterPageDecomposition.toolbar).saveStyle().queue({
            css: {
              opacity: 0
            },
            duration: 0
          }).queue({
            css: {
              opacity: 1
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(enterPageDecomposition.background).queue({
            css: {
              top: enterPageToolbarHeight
            },
            duration: 0
          }), animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(125%, 0, 0)',
              opacity: 1
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
            css: { opacity: 0 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 1 },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            callback();
            done();
          }), animit(leavePageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(leavePageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.label + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(leavePageDecomposition.other).saveStyle().queue({
            css: { opacity: 1 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 0 },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle());
        } else {

          animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), animit(leavePage).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            callback();
            done();
          }));
        }
      });
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, done) {
      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var enterPageDecomposition = this._decompose(enterPage);
      var leavePageDecomposition = this._decompose(leavePage);

      var delta = this._calculateDelta(leavePage, leavePageDecomposition);

      var maskClear = animit(this.backgroundMask).saveStyle().queue({
        opacity: 0.1,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        done();
      });

      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

      if (shouldAnimateToolbar) {
        var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
        this.backgroundMask.style.top = enterPageToolbarHeight;

        animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.label + 'px, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
          css: { opacity: 0 },
          duration: 0
        }).wait(this.delay).queue({
          css: { opacity: 1 },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), animit(leavePageDecomposition.background).queue({
          css: {
            top: enterPageToolbarHeight
          },
          duration: 0
        }), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).wait(0).queue(function (finish) {
          this.backgroundMask.remove();
          done();
          finish();
        }.bind(this)), animit(leavePageDecomposition.toolbar).queue({
          css: {
            opacity: 1
          },
          duration: 0
        }).queue({
          css: {
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }), animit(leavePageDecomposition.toolbarCenter).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(125%, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }), animit(leavePageDecomposition.backButtonLabel).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }));
      } else {
        animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), animit(leavePage).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).queue(function (finish) {
          this.backgroundMask.remove();
          done();
          finish();
        }.bind(this)));
      }
    }
  }]);
  return IOSSlideNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSLiftNavigatorTransitionAnimator(options) {
    classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

    options = util.extend({
      duration: 0.4,
      timing: 'cubic-bezier(.1, .7, .1, 1)',
      delay: 0
    }, options || {});

    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator)).call(this, options));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSLiftNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }), animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }), animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSLiftNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in screen transition.
 */

var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSFadeNavigatorTransitionAnimator(options) {
    classCallCheck(this, IOSFadeNavigatorTransitionAnimator);

    options = util.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (IOSFadeNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator)).call(this, options));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSFadeNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {

      animit.runAll(animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }), animit(enterPage._getToolbarElement()).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      animit.runAll(animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }), animit(leavePage._getToolbarElement()).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSFadeNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition.
 */

var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDSlideNavigatorTransitionAnimator(options) {
    classCallCheck(this, MDSlideNavigatorTransitionAnimator);

    options = util.extend({
      duration: 0.3,
      timing: 'cubic-bezier(.1, .7, .4, 1)',
      delay: 0
    }, options || {});

    var _this = possibleConstructorReturn(this, (MDSlideNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator)).call(this, options));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
    _this.blackMaskOpacity = 0.4;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDSlideNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

      animit.runAll(animit(this.backgroundMask).saveStyle().queue({
        opacity: 0,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: this.blackMaskOpacity
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      }), animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(100%, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), animit(leavePage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().wait(0.2).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, done) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      animit.runAll(animit(this.backgroundMask).saveStyle().queue({
        opacity: this.blackMaskOpacity,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), animit(leavePage).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(100%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).wait(0.2).queue(function (finish) {
        done();
        finish();
      }));
    }
  }]);
  return MDSlideNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDLiftNavigatorTransitionAnimator(options) {
    classCallCheck(this, MDLiftNavigatorTransitionAnimator);

    options = util.extend({
      duration: 0.4,
      timing: 'cubic-bezier(.1, .7, .1, 1)',
      delay: 0.05
    }, options || {});

    var _this = possibleConstructorReturn(this, (MDLiftNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator)).call(this, options));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDLiftNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }), animit(leavePage).queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).queue({
        css: {
          opacity: 0.4
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0.4
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }), animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDLiftNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in + Lift screen transition.
 */

var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDFadeNavigatorTransitionAnimator(options) {
    classCallCheck(this, MDFadeNavigatorTransitionAnimator);

    options = util.extend({
      timing: 'ease-out',
      duration: '0.25',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (MDFadeNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator)).call(this, options));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDFadeNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {

      animit.runAll(animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 42px, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      animit.runAll(animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(0.15).queue({
        css: {
          transform: 'translate3D(0, 38px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }), animit(leavePage).queue({
        css: {
          opacity: 1
        },
        duration: 0
      }).wait(0.04).queue({
        css: {
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDFadeNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

  function NoneNavigatorTransitionAnimator(options) {
    classCallCheck(this, NoneNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (NoneNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorTransitionAnimator)).call(this, options));
  }

  createClass(NoneNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }]);
  return NoneNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$3 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
  },
  'slide': function slide() {
    return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
  },
  'lift': function lift() {
    return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
  },
  'slide-ios': IOSSlideNavigatorTransitionAnimator,
  'slide-md': MDSlideNavigatorTransitionAnimator,
  'lift-ios': IOSLiftNavigatorTransitionAnimator,
  'lift-md': MDLiftNavigatorTransitionAnimator,
  'fade-ios': IOSFadeNavigatorTransitionAnimator,
  'fade-md': MDFadeNavigatorTransitionAnimator,
  'none': NoneNavigatorTransitionAnimator
};

var rewritables = {
  /**
   * @param {Element} navigatorSideElement
   * @param {Function} callback
   */
  ready: function ready(navigatorElement, callback) {
    callback();
  }
};

/**
 * @element ons-navigator
 * @category navigation
 * @description
 *   [en]
 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
 *
 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
 *   [/en]
 *   [ja][/ja]
 * @codepen yrhtv
 * @tutorial vanilla/Reference/navigator
 * @guide multiple-page-navigation
 *   [en]Guide for page navigation[/en]
 *   [ja]ページナビゲーションの概要[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @guide creating-a-page
 *   [en]Setting up a page in its `init` event[/en]
 *   [ja]Setting up a page in its `init` event[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
 *   [ja][/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-navigator id="navigator">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="center">
 *         Title
 *       </div>
 *     </ons-toolbar>
 *     <p>
 *       <ons-button
 *         onclick="document.getElementById('navigator').pushPage('page.html')">
 *         Push page
 *       </ons-button>
 *     </p>
 *   </ons-page>
 * </ons-navigator>
 *
 * <ons-template id="page.html">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="left">
 *         <ons-back-button>Back</ons-back-button>
 *       </div>
 *       <div class="center">
 *         Another page
 *       </div>
 *     </ons-toolbar>
 *   </ons-page>
 * </ons-template>
 */

var NavigatorElement = function (_BaseElement) {
  inherits(NavigatorElement, _BaseElement);

  function NavigatorElement() {
    classCallCheck(this, NavigatorElement);
    return possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).apply(this, arguments));
  }

  createClass(NavigatorElement, [{
    key: 'init',
    value: function init() {
      this._isRunning = false;
      this._pageLoader = defaultPageLoader;

      this._updateAnimatorFactory();
    }

    /**
     * @property pageLoader
     * @type {PageLoader}
     * @description
     *   [en][/en]
     *   [ja]PageLoaderインスタンスを格納しています。[/ja]
     */

  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en][/en]
     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

      rewritables.ready(this, function () {
        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
          _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
        } else if (_this2.pages.length > 0) {
          for (var i = 0; i < _this2.pages.length; i++) {
            if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
              throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
            }
          }

          if (_this2.topPage) {
            contentReady(_this2.topPage, function () {
              return setTimeout(function () {
                _this2.topPage._show();
                _this2._updateLastPageBackButton();
              }, 0);
            });
          }
        } else {
          contentReady(_this2, function () {
            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
              _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
            }
          });
        }
      });
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$3,
        baseClass: NavigatorTransitionAnimator,
        baseClassName: 'NavigatorTransitionAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }

    /**
     * @method popPage
     * @signature popPage([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Boolean} [options.refresh]
     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
     */

  }, {
    key: 'popPage',
    value: function popPage() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _preparePageAndOption = this._preparePageAndOptions(null, options);

      options = _preparePageAndOption.options;


      var popUpdate = function popUpdate() {
        return new Promise(function (resolve) {
          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
          resolve();
        });
      };

      if (!options.refresh) {
        return this._popPage(options, popUpdate);
      }

      var index = this.pages.length - 2;
      var oldPage = this.pages[index];

      if (!oldPage.name) {
        throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
      }

      return new Promise(function (resolve) {
        var options = { page: oldPage.name, parent: _this3, params: oldPage.pushedOptions.data };
        _this3._pageLoader.load(options, function (pageElement) {
          pageElement = util.extend(pageElement, {
            name: oldPage.name,
            data: oldPage.data,
            pushedOptions: oldPage.pushedOptions
          });

          _this3.insertBefore(pageElement, oldPage ? oldPage : null);
          _this3._pageLoader.unload(oldPage);
          resolve();
        });
      }).then(function () {
        return _this3._popPage(options, popUpdate);
      });
    }
  }, {
    key: '_popPage',
    value: function _popPage(options) {
      var _this4 = this;

      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('popPage is already running.');
      }

      if (this.pages.length <= 1) {
        return Promise.reject('ons-navigator\'s page stack is empty.');
      }

      if (this._emitPrePopEvent()) {
        return Promise.reject('Canceled in prepop event.');
      }

      var length = this.pages.length;

      this._isRunning = true;

      this.pages[length - 2].updateBackButton(length - 2 > 0);

      return new Promise(function (resolve) {
        var leavePage = _this4.pages[length - 1];
        var enterPage = _this4.pages[length - 2];
        enterPage.style.display = 'block';

        options.animation = options.animation || leavePage.pushedOptions.animation;
        options.animationOptions = util.extend({}, leavePage.pushedOptions.animationOptions, options.animationOptions || {});

        if (options.data) {
          enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        }

        var callback = function callback() {
          update().then(function () {
            _this4._isRunning = false;

            enterPage._show();
            util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          });
        };

        leavePage._hide();
        var animator = _this4._animatorFactory.newAnimator(options);
        animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], callback);
      }).catch(function () {
        return _this4._isRunning = false;
      });
    }

    /**
     * @method pushPage
     * @signature pushPage(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
     *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.page]
     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
     *   [ja][/ja]
     * @param {String} [options.pageHTML]
     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the pushed page.[/en]
     *   [ja]追加したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pushes the specified page into the stack.[/en]
     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
     */

  }, {
    key: 'pushPage',
    value: function pushPage(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption2.page;
      options = _preparePageAndOption2.options;


      var prepare = function prepare(pageElement) {
        _this5._verifyPageElement(pageElement);
        pageElement = util.extend(pageElement, {
          name: options.page,
          data: options.data
        });
        pageElement.style.display = 'none';
      };

      if (options.pageHTML) {
        return this._pushPage(options, function () {
          return new Promise(function (resolve) {
            instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (pageElement) {
              prepare(pageElement);
              resolve();
            });
          });
        });
      }

      return this._pushPage(options, function () {
        return new Promise(function (resolve) {
          _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (pageElement) {
            prepare(pageElement);
            resolve();
          });
        });
      });
    }
  }, {
    key: '_pushPage',
    value: function _pushPage() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }

      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      this._isRunning = true;

      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
      options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

      var animator = this._animatorFactory.newAnimator(options);

      return update().then(function () {
        var pageLength = _this6.pages.length;

        var enterPage = _this6.pages[pageLength - 1];
        var leavePage = _this6.pages[pageLength - 2];

        if (enterPage.nodeName !== 'ONS-PAGE') {
          throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
        }

        enterPage.updateBackButton(pageLength - 1);

        enterPage.pushedOptions = util.extend({}, enterPage.pushedOptions || {}, options || {});
        enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        enterPage.name = enterPage.name || options.page;
        enterPage.unload = enterPage.unload || options.unload;

        return new Promise(function (resolve) {
          var done = function done() {
            _this6._isRunning = false;

            if (leavePage) {
              leavePage.style.display = 'none';
            }

            setImmediate(function () {
              return enterPage._show();
            });
            util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          };

          enterPage.style.display = 'block';
          if (leavePage) {
            leavePage._hide();
            animator.push(enterPage, leavePage, done);
          } else {
            done();
          }
        });
      }).catch(function (error) {
        _this6._isRunning = false;
        throw error;
      });
    }

    /**
     * @method replacePage
     * @signature replacePage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new page.[/en]
     *   [ja]新しいページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
     */

  }, {
    key: 'replacePage',
    value: function replacePage(page) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.pushPage(page, options).then(function (resolvedValue) {
        if (_this7.pages.length > 1) {
          _this7._pageLoader.unload(_this7.pages[_this7.pages.length - 2]);
        }
        _this7._updateLastPageBackButton();

        return Promise.resolve(resolvedValue);
      });
    }

    /**
     * @method insertPage
     * @signature insertPage(index, page, [options])
     * @param {Number} index
     *   [en]The index where it should be inserted.[/en]
     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the inserted page.[/en]
     *   [ja]指定したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
     */

  }, {
    key: 'insertPage',
    value: function insertPage(index, page) {
      var _this8 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption3.page;
      options = _preparePageAndOption3.options;

      index = this._normalizeIndex(index);

      if (index >= this.pages.length) {
        return this.pushPage(page, options);
      }

      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

      return new Promise(function (resolve) {
        loader.load({ page: page, parent: _this8 }, function (pageElement) {
          _this8._verifyPageElement(pageElement);
          pageElement = util.extend(pageElement, {
            name: options.page,
            data: options.data,
            pushedOptions: options
          });

          options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

          pageElement.style.display = 'none';
          _this8.insertBefore(pageElement, _this8.pages[index]);
          _this8.topPage.updateBackButton(true);

          setTimeout(function () {
            pageElement = null;
            resolve(_this8.pages[index]);
          }, 1000 / 60);
        });
      });
    }

    /**
     * @method resetToPage
     * @signature resetToPage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
     */

  }, {
    key: 'resetToPage',
    value: function resetToPage(page) {
      var _this9 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption4.page;
      options = _preparePageAndOption4.options;


      if (!options.animator && !options.animation) {
        options.animation = 'none';
      }

      var callback = options.callback;

      options.callback = function () {
        while (_this9.pages.length > 1) {
          _this9._pageLoader.unload(_this9.pages[0]);
        }

        _this9.pages[0].updateBackButton(false);
        callback && callback();
      };

      if (!options.page && !options.pageHTML && this._getPageTarget()) {
        page = options.page = this._getPageTarget();
      }

      return this.pushPage(page, options);
    }

    /**
     * @method bringPageTop
     * @signature bringPageTop(item, [options])
     * @param {String|Number} item
     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
     */

  }, {
    key: 'bringPageTop',
    value: function bringPageTop(item) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
        throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
      }
      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
      var page = this.pages[index];

      if (index < 0) {
        return this.pushPage(item, options);
      }

      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

      options = _preparePageAndOption5.options;


      if (index === this.pages.length - 1) {
        return Promise.resolve(page);
      }
      if (!page) {
        throw new Error('Failed to find item ' + item);
      }
      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }
      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      util.extend(options, {
        page: page.name
      });
      page.style.display = 'none';
      page.setAttribute('_skipinit', '');
      page.parentNode.appendChild(page);
      return this._pushPage(options);
    }
  }, {
    key: '_preparePageAndOptions',
    value: function _preparePageAndOptions(page) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      if ((page === null || page === undefined) && options.page) {
        page = options.page;
      }

      options = util.extend({}, this.options || {}, options, { page: page });

      return { page: page, options: options };
    }
  }, {
    key: '_updateLastPageBackButton',
    value: function _updateLastPageBackButton() {
      var index = this.pages.length - 1;
      if (index >= 0) {
        this.pages[index].updateBackButton(index > 0);
      }
    }
  }, {
    key: '_normalizeIndex',
    value: function _normalizeIndex(index) {
      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
    }
  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      if (this.pages.length > 1) {
        this.popPage();
      } else {
        event.callParentHandler();
      }
    }
  }, {
    key: '_lastIndexOfPage',
    value: function _lastIndexOfPage(pageName) {
      var index = void 0;
      for (index = this.pages.length - 1; index >= 0; index--) {
        if (this.pages[index].name === pageName) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_emitPreEvent',
    value: function _emitPreEvent(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isCanceled = false;

      util.triggerElementEvent(this, 'pre' + name, util.extend({
        navigator: this,
        currentPage: this.pages[this.pages.length - 1],
        cancel: function cancel() {
          return isCanceled = true;
        }
      }, data));

      return isCanceled;
    }
  }, {
    key: '_emitPrePushEvent',
    value: function _emitPrePushEvent() {
      return this._emitPreEvent('push');
    }
  }, {
    key: '_emitPrePopEvent',
    value: function _emitPrePopEvent() {
      var l = this.pages.length;
      return this._emitPreEvent('pop', {
        leavePage: this.pages[l - 1],
        enterPage: this.pages[l - 2]
      });
    }

    // TODO: 書き直す

  }, {
    key: '_createPageElement',
    value: function _createPageElement(templateHTML) {
      var pageElement = util.createElement(internal$1.normalizePageHTML(templateHTML));
      this._verifyPageElement(pageElement);
      return pageElement;
    }

    /**
     * @param {Element} element
     */

  }, {
    key: '_verifyPageElement',
    value: function _verifyPageElement(element) {
      if (element.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('You must supply an "ons-page" element to "ons-navigator".');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      if (this.topPage) {
        this.topPage._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this.topPage) {
        this.topPage._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      for (var i = this.pages.length - 1; i >= 0; i--) {
        this._pageLoader.unload(this.pages[i]);
      }

      this.remove();
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'animatorFactory',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]First page to show when navigator is initialized.[/en]
     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @event prepush
     * @description
     *   [en]Fired just before a page is pushed.[/en]
     *   [ja]pageがpushされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the push.[/en]
     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
     */

    /**
     * @event prepop
     * @description
     *   [en]Fired just before a page is popped.[/en]
     *   [ja]pageがpopされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the pop.[/en]
     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
     */

    /**
     * @event postpush
     * @description
     *   [en]Fired just after a page is pushed.[/en]
     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pushされたpageオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]以前のpageオブジェクト。[/ja]
     */

    /**
     * @event postpop
     * @description
     *   [en]Fired just after a page is popped.[/en]
     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]popされて表示されるページのオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]popされて消えるページのオブジェクト。[/ja]
     */

    get: function get() {
      return this._animatorFactory;
    }
  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(pageLoader) {
      if (!(pageLoader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = pageLoader;
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    },
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }

    /**
     * @property topPage
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
     */

  }, {
    key: 'topPage',
    get: function get() {
      return this.pages[this.pages.length - 1] || null;
    }

    /**
     * @property pages
     * @readonly
     * @type {Array}
     * @description
     *   [en]Copy of the navigator's page stack.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pages',
    get: function get() {
      return util.arrayFrom(this.children).filter(function (n) {
        return n.tagName === 'ONS-PAGE';
      });
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Default options object. Attributes have priority over this property.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @property options.refresh
     * @default  false
     * @type {Boolean}
     * @description
     *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
     */

  }, {
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(object) {
      this._options = object;
    }
  }, {
    key: '_isRunning',
    set: function set(value) {
      this.setAttribute('_is-running', value ? 'true' : 'false');
    },
    get: function get() {
      return JSON.parse(this.getAttribute('_is-running'));
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
        throw new Error('"Animator" param must inherit NavigatorElement.NavigatorTransitionAnimator');
      }

      _animatorDict$3[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['animation'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$3;
    }
  }, {
    key: 'NavigatorTransitionAnimator',
    get: function get() {
      return NavigatorTransitionAnimator;
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables;
    }
  }]);
  return NavigatorElement;
}(BaseElement);

customElements.define('ons-navigator', NavigatorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$13 = {
  '': 'navigation-bar--*',
  '.navigation-bar__left': 'navigation-bar--*__left',
  '.navigation-bar__center': 'navigation-bar--*__center',
  '.navigation-bar__right': 'navigation-bar--*__right'
};

/**
 * @element ons-toolbar
 * @category page
 * @modifier material
 *   [en]Material Design toolbar.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Transparent toolbar[/en]
 *   [ja]透明な背景を持つツールバーを表示します。[/ja]
 * @modifier noshadow
 *   [en]Toolbar without shadow[/en]
 *   [ja]どうしよう[/ja]
 * @description
 *   [en]
 *     Toolbar component that can be used with navigation.
 *
 *     Left, center and right container can be specified by class names.
 *
 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
 *   [/en]
 *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide adding-a-toolbar [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
 * @seealso ons-bottom-toolbar
 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
 *   [ja]ons-bottom-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @seealso ons-toolbar-button
 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
 *   [ja]ons-toolbar-buttonコンポーネント[/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>
 *         Back
 *       </ons-back-button>
 *     </div>
 *     <div class="center">
 *       Title
 *     </div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 * </ons-page>
 */

var ToolbarElement = function (_BaseElement) {
  inherits(ToolbarElement, _BaseElement);

  function ToolbarElement() {
    classCallCheck(this, ToolbarElement);
    return possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).apply(this, arguments));
  }

  createClass(ToolbarElement, [{
    key: 'init',


    /**
     * @attribute inline
     * @initonly
     * @description
     *   [en]Display the toolbar as an inline element.[/en]
     *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
     */

    /**
     * @attribute modifier
     * @description
     *   [en]The appearance of the toolbar.[/en]
     *   [ja]ツールバーの表現を指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$13);
      }
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarLeftItemsElement',
    value: function _getToolbarLeftItemsElement() {
      return this.querySelector('.left') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarCenterItemsElement',
    value: function _getToolbarCenterItemsElement() {
      return this.querySelector('.center') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarRightItemsElement',
    value: function _getToolbarRightItemsElement() {
      return this.querySelector('.right') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonLabelElement',
    value: function _getToolbarBackButtonLabelElement() {
      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonIconElement',
    value: function _getToolbarBackButtonIconElement() {
      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add('navigation-bar');
      this._ensureToolbarItemElements();
      ModifierUtil.initModifier(this, scheme$13);
    }
  }, {
    key: '_ensureToolbarItemElements',
    value: function _ensureToolbarItemElements() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        // case of not element
        if (this.childNodes[i].nodeType != 1) {
          this.removeChild(this.childNodes[i]);
        }
      }

      var center = this._ensureToolbarElement('center');
      center.classList.add('navigation-bar__title');

      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
        var left = this._ensureToolbarElement('left');
        var right = this._ensureToolbarElement('right');

        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
          this.appendChild(left);
          this.appendChild(center);
          this.appendChild(right);
        }
      }
    }
  }, {
    key: '_ensureToolbarElement',
    value: function _ensureToolbarElement(name) {
      if (util.findChild(this, '.navigation-bar__' + name)) {
        var _element = util.findChild(this, '.navigation-bar__' + name);
        _element.classList.add(name);
        return _element;
      }

      var element = util.findChild(this, '.' + name) || util.create('.' + name);
      element.classList.add('navigation-bar__' + name);

      return element;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return ToolbarElement;
}(BaseElement);

customElements.define('ons-toolbar', ToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$12 = {
  '': 'page--*',
  '.page__content': 'page--*__content',
  '.page__background': 'page--*__background'
};

var nullToolbarElement = document.createElement('ons-toolbar'); // requires that 'ons-toolbar' element is registered

/**
 * @element ons-page
 * @category page
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     This component defines the root of each page. If the content is large it will become scrollable.
 *
 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
 *   [/en]
 *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
 * @tutorial vanilla/Reference/page
 * @guide creating-a-page
 *   [en]Setting up a page in its `init` event[/en]
 *   [ja]Setting up a page in its `init` event[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @guide multiple-page-navigation
 *   [en]Managing multiple pages[/en]
 *   [ja]複数のページを管理する[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-toolbar
 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>Back</ons-back-button>
 *     </div>
 *     <div class="center">Title</div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 *
 *   <p>Page content</p>
 * </ons-page>
 *
 * @example
 * <script>
 *   myApp.handler = function(done) {
 *     loadMore().then(done);
 *   }
 * </script>
 *
 * <ons-page on-infinite-scroll="myApp.handler">
 *   <ons-toolbar>
 *     <div class="center">List</div>
 *   </ons-toolbar>
 *
 *   <ons-list>
 *     <ons-list-item>#1</ons-list-item>
 *     <ons-list-item>#2</ons-list-item>
 *     <ons-list-item>#3</ons-list-item>
 *     ...
 *   </ons-list>
 * </ons-page>
 */

var PageElement = function (_BaseElement) {
  inherits(PageElement, _BaseElement);

  function PageElement() {
    classCallCheck(this, PageElement);
    return possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).apply(this, arguments));
  }

  createClass(PageElement, [{
    key: 'init',


    /**
     * @event init
     * @description
     *   [en]Fired right after the page is attached.[/en]
     *   [ja]ページがアタッチされた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event show
     * @description
     *   [en]Fired right after the page is shown.[/en]
     *   [ja]ページが表示された後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event hide
     * @description
     *   [en]Fired right after the page is hidden.[/en]
     *   [ja]ページが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event destroy
     * @description
     *   [en]Fired right before the page is destroyed.[/en]
     *   [ja]ページが破棄される前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Specify modifier name to specify custom styles.[/en]
     *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
     */

    /**
     * @attribute on-infinite-scroll
     * @type {String}
     * @description
     *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      this.classList.add('page');

      contentReady(this, function () {
        _this2._compile();

        _this2._isShown = false;
        _this2._contentElement = _this2._getContentElement();
        _this2._isMuted = _this2.hasAttribute('_muted');
        _this2._skipInit = _this2.hasAttribute('_skipinit');
        _this2.pushedOptions = {};
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        if (!_this3._isMuted) {
          if (_this3._skipInit) {
            _this3.removeAttribute('_skipinit');
          } else {
            setImmediate(function () {
              return util.triggerElementEvent(_this3, 'init');
            });
          }
        }

        if (!util.hasAnyComponentAsParent(_this3)) {
          setImmediate(function () {
            return _this3._show();
          });
        }

        _this3._tryToFillStatusBar();

        if (_this3.hasAttribute('on-infinite-scroll')) {
          _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
        }
      });
    }
  }, {
    key: 'updateBackButton',
    value: function updateBackButton(show) {
      if (this.backButton) {
        show ? this.backButton.show() : this.backButton.hide();
      }
    }
  }, {
    key: '_tryToFillStatusBar',
    value: function _tryToFillStatusBar() {
      var _this4 = this;

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this4, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
      });
    }
  }, {
    key: '_hasAPageControlChild',
    value: function _hasAPageControlChild() {
      return util.findChild(this._contentElement, function (e) {
        return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
      });
    }

    /**
     * @property onInfiniteScroll
     * @description
     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
     *  [ja][/ja]
     */

  }, {
    key: '_onScroll',
    value: function _onScroll() {
      var _this5 = this;

      var c = this._contentElement,
          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
        this._loadingContent = true;
        this._onInfiniteScroll(function () {
          return _this5._loadingContent = false;
        });
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_getContentElement',


    /**
     * @return {HTMLElement}
     */
    value: function _getContentElement() {
      var result = util.findChild(this, '.page__content');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__content" element.');
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_canAnimateToolbar',
    value: function _canAnimateToolbar() {
      if (util.findChild(this, 'ons-toolbar')) {
        return true;
      }
      return !!util.findChild(this._contentElement, function (el) {
        return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
      });
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getBackgroundElement',
    value: function _getBackgroundElement() {
      var result = util.findChild(this, '.page__background');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__background" element.');
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getBottomToolbarElement',
    value: function _getBottomToolbarElement() {
      return util.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarElement',
    value: function _getToolbarElement() {
      return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this6 = this;

      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$12);
      } else if (name === '_muted') {
        this._isMuted = this.hasAttribute('_muted');
      } else if (name === '_skipinit') {
        this._skipInit = this.hasAttribute('_skipinit');
      } else if (name === 'on-infinite-scroll') {
        if (current === null) {
          this.onInfiniteScroll = null;
        } else {
          this.onInfiniteScroll = function (done) {
            var f = util.findFromPath(current);
            _this6.onInfiniteScroll = f;
            f(done);
          };
        }
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this7 = this;

      autoStyle.prepare(this);

      if (util.findChild(this, '.content')) {
        util.findChild(this, '.content').classList.add('page__content');
      }

      if (util.findChild(this, '.background')) {
        util.findChild(this, '.background').classList.add('page__background');
      }

      if (!util.findChild(this, '.page__content')) {
        (function () {
          var content = util.create('.page__content');

          util.arrayFrom(_this7.childNodes).forEach(function (node) {
            if (node.nodeType !== 1 || _this7._elementShouldBeMoved(node)) {
              content.appendChild(node);
            }
          });

          var prevNode = util.findChild(_this7, '.page__background') || util.findChild(_this7, 'ons-toolbar');

          _this7.insertBefore(content, prevNode && prevNode.nextSibling);
        })();
      }

      if (!util.findChild(this, '.page__background')) {
        var background = util.create('.page__background');
        this.insertBefore(background, util.findChild(this, '.page__content'));
      }

      ModifierUtil.initModifier(this, scheme$12);
    }
  }, {
    key: '_elementShouldBeMoved',
    value: function _elementShouldBeMoved(el) {
      if (el.classList.contains('page__background')) {
        return false;
      }
      var tagName = el.tagName.toLowerCase();
      if (tagName === 'ons-fab') {
        return !el.hasAttribute('position');
      }
      var fixedElements = ['ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial'];
      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this._isShown && util.isAttached(this)) {
        this._isShown = true;

        if (!this._isMuted) {
          util.triggerElementEvent(this, 'show');
        }

        util.propagateAction(this._contentElement, '_show');
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._isShown) {
        this._isShown = false;

        if (!this._isMuted) {
          util.triggerElementEvent(this, 'hide');
        }

        util.propagateAction(this._contentElement, '_hide');
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._hide();

      if (!this._isMuted) {
        util.triggerElementEvent(this, 'destroy');
      }

      if (this.onDeviceBackButton) {
        this.onDeviceBackButton.destroy();
      }

      util.propagateAction(this._contentElement, '_destroy');

      this.remove();
    }

    /**
     * @property data
     * @type {*}
     * @description
     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'name',
    set: function set(str) {
      this.setAttribute('name', str);
    },
    get: function get() {
      return this.getAttribute('name');
    }
  }, {
    key: 'backButton',
    get: function get() {
      return this.querySelector('ons-back-button');
    }
  }, {
    key: 'onInfiniteScroll',
    set: function set(value) {
      var _this8 = this;

      if (value === null) {
        this._onInfiniteScroll = null;
        this._contentElement.removeEventListener('scroll', this._boundOnScroll);
        return;
      }
      if (!(value instanceof Function)) {
        throw new Error('onInfiniteScroll must be a function or null');
      }
      if (!this._onInfiniteScroll) {
        this._infiniteScrollLimit = 0.9;
        this._boundOnScroll = this._onScroll.bind(this);
        setImmediate(function () {
          return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
        });
      }
      this._onInfiniteScroll = value;
    },
    get: function get() {
      return this._onInfiniteScroll;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', '_muted', '_skipinit', 'on-infinite-scroll'];
    }
  }]);
  return PageElement;
}(BaseElement);

customElements.define('ons-page', PageElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var PopoverAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function PopoverAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, PopoverAnimator);

    this.options = util.extend({
      timing: 'cubic-bezier(.1, .7, .4, 1)',
      duration: 0.2,
      delay: 0
    }, options);
  }

  createClass(PopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      callback();
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      callback();
    }
  }, {
    key: '_animate',
    value: function _animate(element, _ref) {
      var from = _ref.from,
          to = _ref.to,
          options = _ref.options,
          callback = _ref.callback,
          _ref$restore = _ref.restore,
          restore = _ref$restore === undefined ? false : _ref$restore,
          animation = _ref.animation;

      options = util.extend({}, this.options, options);

      if (animation) {
        from = animation.from;
        to = animation.to;
      }

      animation = animit(element);
      if (restore) {
        animation = animation.saveStyle();
      }
      animation = animation.queue(from).wait(options.delay).queue({
        css: to,
        duration: options.duration,
        timing: options.timing
      });
      if (restore) {
        animation = animation.restoreStyle();
      }
      if (callback) {
        animation = animation.queue(function (done) {
          callback();
          done();
        });
      }
      return animation;
    }
  }, {
    key: '_animateAll',
    value: function _animateAll(element, animations) {
      var _this = this;

      Object.keys(animations).forEach(function (key) {
        return _this._animate(element[key], animations[key]).play();
      });
    }
  }]);
  return PopoverAnimator;
}();

var fade$1 = {
  out: {
    from: { opacity: 1.0 },
    to: { opacity: 0 }
  },
  in: {
    from: { opacity: 0 },
    to: { opacity: 1.0 }
  }
};

var MDFadePopoverAnimator = function (_PopoverAnimator) {
  inherits(MDFadePopoverAnimator, _PopoverAnimator);

  function MDFadePopoverAnimator() {
    classCallCheck(this, MDFadePopoverAnimator);
    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(MDFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.in,
        _popover: { animation: fade$1.in, restore: true, callback: callback }
      });
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.out,
        _popover: { animation: fade$1.out, restore: true, callback: callback }
      });
    }
  }]);
  return MDFadePopoverAnimator;
}(PopoverAnimator);

var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

  function IOSFadePopoverAnimator() {
    classCallCheck(this, IOSFadePopoverAnimator);
    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(IOSFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.in,
        _popover: {
          from: {
            transform: 'scale3d(1.3, 1.3, 1.0)',
            opacity: 0
          },
          to: {
            transform: 'scale3d(1.0, 1.0,  1.0)',
            opacity: 1.0
          },
          restore: true,
          callback: callback
        }
      });
    }
  }]);
  return IOSFadePopoverAnimator;
}(MDFadePopoverAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$14 = {
  '.popover': 'popover--*',
  '.popover-mask': 'popover-mask--*',
  '.popover__container': 'popover__container--*',
  '.popover__content': 'popover__content--*',
  '.popover__arrow': 'popover__arrow--*'
};

var _animatorDict$4 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
  },
  'none': PopoverAnimator,
  'fade-ios': IOSFadePopoverAnimator,
  'fade-md': MDFadePopoverAnimator
};

var templateSource = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

var positions = {
  up: 'bottom',
  left: 'right',
  down: 'top',
  right: 'left'
};

/**
 * @element ons-popover
 * @category dialog
 * @description
 *  [en]
 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
 *
 *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<ons-template>` tag.
 *
 *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
 *  [/en]
 *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
 * @codepen ZYYRKo
 * @tutorial vanilla/Reference/popover
 * @guide dialogs
 *  [en]Dialog components[/en]
 *  [ja]Dialog components[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-button onclick="showPopover(this)">
 *   Click me!
 * </ons-button>
 *
 * <ons-popover direction="down" id="popover">
 *   <p>This is a popover!</p>
 * </ons-popover>
 *
 * <script>
 *   var showPopover = function(element) {
 *     var popover = document.getElementById('popover');
 *     popover.show(element);
 *   };
 * </script>
 */

var PopoverElement = function (_BaseElement) {
  inherits(PopoverElement, _BaseElement);

  function PopoverElement() {
    classCallCheck(this, PopoverElement);
    return possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).apply(this, arguments));
  }

  createClass(PopoverElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2._initAnimatorFactory();
      });

      this._doorLock = new DoorLock();
      this._boundOnChange = this._onChange.bind(this);
      this._boundCancel = this._cancel.bind(this);
    }
  }, {
    key: '_initAnimatorFactory',
    value: function _initAnimatorFactory() {
      var factory = new AnimatorFactory({
        animators: _animatorDict$4,
        baseClass: PopoverAnimator,
        baseClassName: 'PopoverAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
      this._animator = function (options) {
        return factory.newAnimator(options);
      };
    }
  }, {
    key: '_positionPopover',
    value: function _positionPopover(target) {
      var radius = this._radius,
          el = this._content,
          margin = this._margin;

      var pos = target.getBoundingClientRect();
      var isMD = util.hasModifier(this, 'material');
      var cover = isMD && this.hasAttribute('cover-target');

      var distance = {
        top: pos.top - margin,
        left: pos.left - margin,
        right: window.innerWidth - pos.right - margin,
        bottom: window.innerHeight - pos.bottom - margin
      };

      var _calculateDirections2 = this._calculateDirections(distance),
          vertical = _calculateDirections2.vertical,
          primary = _calculateDirections2.primary,
          secondary = _calculateDirections2.secondary;

      this._popover.classList.add('popover--' + primary);

      var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
      this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
      el.style[primary] = 0;

      var l = vertical ? 'width' : 'height';
      var sizes = function (style) {
        return {
          width: parseInt(style.getPropertyValue('width')),
          height: parseInt(style.getPropertyValue('height'))
        };
      }(window.getComputedStyle(el));

      el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
      this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

      this._setTransformOrigin(distance, sizes, pos, primary);

      // Prevent animit from restoring the style.
      el.removeAttribute('data-animit-orig-style');
    }
  }, {
    key: '_setTransformOrigin',
    value: function _setTransformOrigin(distance, sizes, pos, primary) {
      var calc = function calc(a, o, l) {
        return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
      };
      var x = calc('left', 'right', 'width') + 'px',
          y = calc('top', 'bottom', 'height') + 'px';

      util.extend(this._popover.style, {
        transformOrigin: x + ' ' + y,
        webkitTransformOriginX: x,
        webkitTransformOriginY: y
      });
    }
  }, {
    key: '_calculateDirections',
    value: function _calculateDirections(distance) {
      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
        return positions[e];
      });
      var primary = options.sort(function (a, b) {
        return distance[a] - distance[b];
      })[0];
      var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
      var secondary = void 0;

      if (vertical) {
        secondary = distance.left < distance.right ? 'left' : 'right';
      } else {
        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
      }

      return { vertical: vertical, primary: primary, secondary: secondary };
    }
  }, {
    key: '_clearStyles',
    value: function _clearStyles() {
      var _this3 = this;

      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
        _this3._arrow.style[e] = _this3._content.style[e] = _this3.style[e] = '';
        _this3._popover.classList.remove('popover--' + e);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      var _this4 = this;

      setImmediate(function () {
        if (_this4._currentTarget) {
          _this4._positionPopover(_this4._currentTarget);
        }
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this.classList.contains('popover')) {
        return;
      }

      this.classList.add('popover');

      var hasDefaultContainer = this._popover && this._content;

      if (hasDefaultContainer) {

        if (!this._mask) {
          var mask = document.createElement('div');
          mask.classList.add('popover-mask');
          this.insertBefore(mask, this.firstChild);
        }

        if (!this._arrow) {
          var arrow = document.createElement('div');
          arrow.classList.add('popover__arrow');
          this._popover.appendChild(arrow);
        }
      } else {

        var template = templateSource.cloneNode(true);
        var content = template.querySelector('.popover__content');

        while (this.childNodes[0]) {
          content.appendChild(this.childNodes[0]);
        }

        this.appendChild(template);
      }

      if (this.hasAttribute('style')) {
        this._popover.setAttribute('style', this.getAttribute('style'));
        this.removeAttribute('style');
      }

      if (this.hasAttribute('mask-color')) {
        this._mask.style.backgroundColor = this.getAttribute('mask-color');
      }

      ModifierUtil.initModifier(this, scheme$14);
    }
  }, {
    key: '_prepareAnimationOptions',
    value: function _prepareAnimationOptions(options) {
      if (options.animation && !(options.animation in _animatorDict$4)) {
        throw new Error('Animator ' + options.animation + ' is not registered.');
      }

      options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
    }
  }, {
    key: '_executeAction',
    value: function _executeAction(actions) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var callback = options.callback;
      var action = actions.action,
          before = actions.before,
          after = actions.after;


      this._prepareAnimationOptions(options);

      var canceled = false;
      util.triggerElementEvent(this, 'pre' + action, { // synchronous
        popover: this,
        cancel: function cancel() {
          return canceled = true;
        }
      });

      if (canceled) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      return new Promise(function (resolve) {
        _this5._doorLock.waitUnlock(function () {
          var unlock = _this5._doorLock.lock();

          before && before();

          contentReady(_this5, function () {
            _this5._animator(options)[action](_this5, function () {
              after && after();

              unlock();

              util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

              callback && callback();
              resolve(_this5);
            });
          });
        });
      });
    }

    /**
     * @method show
     * @signature show(target, [options])
     * @param {String|Event|HTMLElement} target
     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element.[/en]
     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the popover has been revealed.[/en]
     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show(target) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (typeof target === 'string') {
        target = document.querySelector(target);
      } else if (target instanceof Event) {
        target = target.target;
      }

      if (typeof target === 'undefined') {
        throw new Error('A target argument must be defined for the popover.');
      }

      if (!(target instanceof HTMLElement)) {
        throw new Error('Invalid target');
      }

      return this._executeAction({
        action: 'show',
        before: function before() {
          _this6.style.display = 'block';
          _this6._currentTarget = target;
          _this6._positionPopover(target);
        }
      }, options);
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the popover has been hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close the popover.[/en]
     *   [ja]ポップオーバーを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._executeAction({
        action: 'hide',
        after: function after() {
          _this7.style.display = 'none';
          _this7._clearStyles();
        }
      }, options);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: '_resetBackButtonHandler',
    value: function _resetBackButtonHandler() {
      var _this8 = this;

      // do we need this twice?
      this.onDeviceBackButton = function (e) {
        return _this8.cancelable ? _this8._cancel() : e.callParentHandler();
      };
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this9 = this;

      this._resetBackButtonHandler();

      contentReady(this, function () {
        _this9._margin = _this9._margin || parseInt(window.getComputedStyle(_this9).getPropertyValue('top'));

        // Fix for iframes
        if (!_this9._margin) {
          _this9._margin = 6;
        }

        _this9._radius = parseInt(window.getComputedStyle(_this9._content).getPropertyValue('border-top-left-radius'));

        _this9._mask.addEventListener('click', _this9._boundCancel, false);

        _this9._resetBackButtonHandler();

        window.addEventListener('resize', _this9._boundOnChange, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this10 = this;

      contentReady(this, function () {
        _this10._mask.removeEventListener('click', _this10._boundCancel, false);

        _this10._backButtonHandler.destroy();
        _this10._backButtonHandler = null;

        window.removeEventListener('resize', _this10._boundOnChange, false);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$14);
      }
      if (name === 'direction') {
        return this._boundOnChange();
      }
      if (name === 'animation') {
        this._initAnimatorFactory();
      }
    }
  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this11 = this;

      if (this.cancelable) {
        this.hide({
          callback: function callback() {
            util.triggerElementEvent(_this11, 'dialog-cancel');
          }
        });
      }
    }

    /**
     * @param {String} name
     * @param {PopoverAnimator} Animator
     */

  }, {
    key: '_mask',


    /**
     * @event preshow
     * @description
     *   [en]Fired just before the popover is displayed.[/en]
     *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to stop the popover from being shown.[/en]
     *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
     */

    /**
     * @event postshow
     * @description
     *   [en]Fired just after the popover is displayed.[/en]
     *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event prehide
     * @description
     *   [en]Fired just before the popover is hidden.[/en]
     *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to stop the popover from being hidden.[/en]
     *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
     */

    /**
     * @event posthide
     * @description
     *   [en]Fired just after the popover is hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the popover.[/en]
     *  [ja]ポップオーバーの表現を指定します。[/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *  [en]
     *    A space separated list of directions. If more than one direction is specified,
     *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
     *  [/en]
     *  [ja]
     *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
     *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
     *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
     *  [/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
     *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
     */

    /**
     * @attribute cover-target
     * @description
     *   [en]If set the popover will cover the target on the screen.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @description
     *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
     *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute mask-color
     * @type {Color}
     * @description
     *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
     *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
     */

    get: function get() {
      return util.findChild(this, '.popover-mask');
    }
  }, {
    key: '_popover',
    get: function get() {
      return util.findChild(this, '.popover__container');
    }
  }, {
    key: '_content',
    get: function get() {
      return util.findChild(this._popover, '.popover__content');
    }
  }, {
    key: '_arrow',
    get: function get() {
      return util.findChild(this._popover, '.popover__arrow');
    }
  }, {
    key: 'visible',
    get: function get() {
      return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]
     *     A boolean value that specifies whether the popover is cancelable or not.
     *
     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
     *   [/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof PopoverAnimator)) {
        throw new Error('"Animator" param must inherit PopoverAnimator');
      }
      _animatorDict$4[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'direction', 'animation'];
    }
  }, {
    key: 'PopoverAnimator',
    get: function get() {
      return PopoverAnimator;
    }
  }]);
  return PopoverElement;
}(BaseElement);

customElements.define('ons-popover', PopoverElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$15 = {
  '.progress-bar': 'progress-bar--*',
  '.progress-bar__primary': 'progress-bar__primary--*',
  '.progress-bar__secondary': 'progress-bar__secondary--*'
};

var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

/**
 * @element ons-progress-bar
 * @category visual
 * @description
 *   [en]
 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
 *   [/en]
 *   [ja][/ja]
 * @codepen zvQbGj
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-circular
 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-bar
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-bar>
 *
 * <ons-progress-bar
 *  indeterminate>
 * </ons-progress-bar>
 */

var ProgressBarElement = function (_BaseElement) {
  inherits(ProgressBarElement, _BaseElement);

  function ProgressBarElement() {
    classCallCheck(this, ProgressBarElement);
    return possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).apply(this, arguments));
  }

  createClass(ProgressBarElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Change the appearance of the progress indicator.[/en]
     *   [ja]プログレスインジケータの見た目を変更します。[/ja]
     */

    /**
     * @attribute value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute secondary-value
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute indeterminate
     * @description
     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this._isCompiled()) {
        this._template = template.cloneNode(true);
      } else {
        this._template = util.findChild(this, '.progress-bar');
      }

      this._primary = util.findChild(this._template, '.progress-bar__primary');
      this._secondary = util.findChild(this._template, '.progress-bar__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      ModifierUtil.initModifier(this, scheme$15);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-bar')) {
        return false;
      }

      var barElement = util.findChild(this, '.progress-bar');

      if (!util.findChild(barElement, '.progress-bar__secondary')) {
        return false;
      }

      if (!util.findChild(barElement, '.progress-bar__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === 'indeterminate') {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this3 = this;

      if (this.hasAttribute('indeterminate')) {
        contentReady(this, function () {
          _this3._template.classList.add('progress-bar--indeterminate');
          _this3._template.classList.remove('progress-bar--determinate');
        });
      } else {
        contentReady(this, function () {
          _this3._template.classList.add('progress-bar--determinate');
          _this3._template.classList.remove('progress-bar--indeterminate');
        });
      }
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._primary.style.width = _this4.hasAttribute('value') ? _this4.getAttribute('value') + '%' : '0%';
        _this4._secondary.style.width = _this4.hasAttribute('secondary-value') ? _this4.getAttribute('secondary-value') + '%' : '0%';
      });
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'value',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    },
    get: function get() {
      return this.hasAttribute('indeterminate');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'value', 'secondary-value', 'indeterminate'];
    }
  }]);
  return ProgressBarElement;
}(BaseElement);

customElements.define('ons-progress-bar', ProgressBarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$16 = {
  '.progress-circular': 'progress-circular--*',
  '.progress-circular__primary': 'progress-circular__primary--*',
  '.progress-circular__secondary': 'progress-circular__secondary--*'
};

var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

/**
 * @element ons-progress-circular
 * @category visual
 * @description
 *   [en]
 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
 *   [/en]
 *   [ja][/ja]
 * @codepen EVzMjR
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-bar
 *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-circular
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-circular>
 *
 * <ons-progress-circular
 *  indeterminate>
 * </ons-progress-circular>
 */

var ProgressCircularElement = function (_BaseElement) {
  inherits(ProgressCircularElement, _BaseElement);

  function ProgressCircularElement() {
    classCallCheck(this, ProgressCircularElement);
    return possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).apply(this, arguments));
  }

  createClass(ProgressCircularElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Change the appearance of the progress indicator.[/en]
     *   [ja]プログレスインジケータの見た目を変更します。[/ja]
     */

    /**
     * @attribute value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute secondary-value
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute indeterminate
     * @description
     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$16);
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === 'indeterminate') {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this3 = this;

      if (this.hasAttribute('indeterminate')) {
        contentReady(this, function () {
          _this3._template.classList.add('progress-circular--indeterminate');
          _this3._template.classList.remove('progress-circular--determinate');
        });
      } else {
        contentReady(this, function () {
          _this3._template.classList.add('progress-circular--determinate');
          _this3._template.classList.remove('progress-circular--indeterminate');
        });
      }
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this4 = this;

      if (this.hasAttribute('value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this4.getAttribute('value') * 251.32 * 0.01);
          _this4._primary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
      if (this.hasAttribute('secondary-value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this4.getAttribute('secondary-value') * 251.32 * 0.01);
          _this4._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      if (this._isCompiled()) {
        this._template = util.findChild(this, '.progress-circular');
      } else {
        this._template = template$1.cloneNode(true);
      }

      this._primary = util.findChild(this._template, '.progress-circular__primary');
      this._secondary = util.findChild(this._template, '.progress-circular__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      ModifierUtil.initModifier(this, scheme$16);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-circular')) {
        return false;
      }

      var svg = util.findChild(this, '.progress-circular');

      if (!util.findChild(svg, '.progress-circular__secondary')) {
        return false;
      }

      if (!util.findChild(svg, '.progress-circular__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'value',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    },
    get: function get() {
      return this.hasAttribute('indeterminate');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'value', 'secondary-value', 'indeterminate'];
    }
  }]);
  return ProgressCircularElement;
}(BaseElement);

customElements.define('ons-progress-circular', ProgressCircularElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var STATE_INITIAL = 'initial';
var STATE_PREACTION = 'preaction';
var STATE_ACTION = 'action';

var removeTransform = function removeTransform(el) {
  el.style.transform = '';
  el.style.WebkitTransform = '';
  el.style.transition = '';
  el.style.WebkitTransition = '';
};

/**
 * @element ons-pull-hook
 * @category control
 * @description
 *   [en]
 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
 *
 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
 *   [/en]
 *   [ja][/ja]
 * @codepen WbJogM
 * @tutorial vanilla/Reference/pull-hook
 * @example
 * <ons-page>
 *   <ons-pull-hook>
 *     Release to refresh
 *   </ons-pull-hook>
 * </ons-page>
 *
 * <script>
 *   document.querySelector('ons-pull-hook').onAction = function(done) {
 *     setTimeout(done, 1000);
 *   };
 * </script>
 */

var PullHookElement = function (_BaseElement) {
  inherits(PullHookElement, _BaseElement);

  function PullHookElement() {
    classCallCheck(this, PullHookElement);
    return possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).apply(this, arguments));
  }

  createClass(PullHookElement, [{
    key: 'init',


    /**
     * @event changestate
     * @description
     *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
     *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.pullHook
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {String} event.state
     *   [en]Current state.[/en]
     *   [ja]現在の状態名を参照できます。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
     *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
     */

    /**
     * @attribute height
     * @type {String}
     * @description
     *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
     *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
     */

    /**
     * @attribute threshold-height
     * @type {String}
     * @description
     *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
     *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
     */

    /**
     * @attribute fixed-content
     * @description
     *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
     *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
     */

    value: function init() {
      this._boundOnDrag = this._onDrag.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnDragEnd = this._onDragEnd.bind(this);
      this._boundOnScroll = this._onScroll.bind(this);

      this._setState(STATE_INITIAL, true);
    }
  }, {
    key: '_setStyle',
    value: function _setStyle() {
      var height = this.height;

      this.style.height = height + 'px';
      this.style.lineHeight = height + 'px';
      this.style.marginTop = '-1px';
      this._pageElement.style.marginTop = '-' + height + 'px';
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      var element = this._pageElement;

      if (element.scrollTop < 0) {
        element.scrollTop = 0;
      }
    }
  }, {
    key: '_generateTranslationTransform',
    value: function _generateTranslationTransform(scroll) {
      return 'translate3d(0px, ' + scroll + 'px, 0px)';
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var _this2 = this;

      if (this.disabled) {
        return;
      }

      // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
      // there will be no inertial scroll when scrolling down. Allowing default scrolling will
      // kill all 'touchmove' events.
      if (platform.isAndroid()) {
        var element = this._pageElement;
        element.scrollTop = this._startScroll - event.gesture.deltaY;
        if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
          event.gesture.preventDefault();
        }
      }

      if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
        this._transitionDragLength = event.gesture.deltaY;

        var direction = event.gesture.interimDirection;
        if (direction === 'down') {
          this._transitionDragLength -= 1;
        } else {
          this._transitionDragLength += 1;
        }
      }

      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

      if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
        event.gesture.stopDetect();

        setImmediate(function () {
          return _this2._finish();
        });
      } else if (scroll >= this.height) {
        this._setState(STATE_PREACTION);
      } else {
        this._setState(STATE_INITIAL);
      }

      // By stopping propagation only of `dragup` and `dragdown`,
      // allowing ancestor elements to detect `dragleft` and `dragright`.
      // If we comment out the following `if` block, `ons-splitter` with `ons-pull-hook` will be broken.
      if (event.gesture.direction === 'up' || event.gesture.direction === 'down') {
        event.stopPropagation();
      }
      this._translateTo(scroll);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      if (this.disabled) {
        return;
      }

      this._startScroll = this._getCurrentScroll();
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      if (this.disabled) {
        return;
      }

      if (this._currentTranslation > 0) {
        var scroll = this._currentTranslation;

        if (scroll > this.height) {
          this._finish();
        } else {
          this._translateTo(0, { animate: true });
        }
      }
    }

    /**
     * @property onAction
     * @type {Function}
     * @description
     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_finish',
    value: function _finish() {
      var _this3 = this;

      this._setState(STATE_ACTION);
      this._translateTo(this.height, { animate: true });
      var action = this.onAction || function (done) {
        return done();
      };
      action(function () {
        _this3._translateTo(0, { animate: true });
        _this3._setState(STATE_INITIAL);
      });
    }

    /**
     * @property height
     * @type {Number}
     * @description
     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_thresholdHeightEnabled',
    value: function _thresholdHeightEnabled() {
      var th = this.thresholdHeight;
      return th > 0 && th >= this.height;
    }
  }, {
    key: '_setState',
    value: function _setState(state, noEvent) {
      var lastState = this._getState();

      this.setAttribute('state', state);

      if (!noEvent && lastState !== this._getState()) {
        util.triggerElementEvent(this, 'changestate', {
          pullHook: this,
          state: state,
          lastState: lastState
        });
      }
    }
  }, {
    key: '_getState',
    value: function _getState() {
      return this.getAttribute('state');
    }

    /**
     * @property state
     * @readonly
     * @type {String}
     * @description
     *   [en]Current state of the element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_getCurrentScroll',
    value: function _getCurrentScroll() {
      return this._pageElement.scrollTop;
    }

    /**
     * @property pullDistance
     * @readonly
     * @type {Number}
     * @description
     *   [en]The current number of pixels the pull hook has moved.[/en]
     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
     */

  }, {
    key: '_isContentFixed',
    value: function _isContentFixed() {
      return this.hasAttribute('fixed-content');
    }
  }, {
    key: '_getScrollableElement',
    value: function _getScrollableElement() {
      if (this._isContentFixed()) {
        return this;
      } else {
        return this._pageElement;
      }
    }

    /**
     * @param {Number} scroll
     * @param {Object} options
     * @param {Function} [options.callback]
     */

  }, {
    key: '_translateTo',
    value: function _translateTo(scroll) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._currentTranslation == 0 && scroll == 0) {
        return;
      }

      var done = function done() {
        if (scroll === 0) {
          var el = _this4._getScrollableElement();
          removeTransform(el);
        }

        if (options.callback) {
          options.callback();
        }
      };

      this._currentTranslation = scroll;

      if (options.animate) {
        animit(this._getScrollableElement()).queue({
          transform: this._generateTranslationTransform(scroll)
        }, {
          duration: 0.3,
          timing: 'cubic-bezier(.1, .7, .1, 1)'
        }).play(done);
      } else {
        animit(this._getScrollableElement()).queue({
          transform: this._generateTranslationTransform(scroll)
        }).play(done);
      }
    }
  }, {
    key: '_disableDragLock',
    value: function _disableDragLock() {
      // e2e tests need it
      this._dragLockDisabled = true;
      this._destroyEventListeners();
      this._createEventListeners();
    }
  }, {
    key: '_createEventListeners',
    value: function _createEventListeners() {
      this._gestureDetector = new GestureDetector(this._pageElement, {
        dragMinDistance: 1,
        dragDistanceCorrection: false,
        dragLockToAxis: !this._dragLockDisabled
      });

      // Bind listeners
      //
      // Note:
      // If we swipe up/down a screen too fast,
      // the gesture detector occasionally dispatches a `dragleft` or `dragright`,
      // so we need to have the pull hook listen to `dragleft` and `dragright` as well as `dragup` and `dragdown`.
      this._gestureDetector.on('dragup dragdown dragleft dragright', this._boundOnDrag);
      this._gestureDetector.on('dragstart', this._boundOnDragStart);
      this._gestureDetector.on('dragend', this._boundOnDragEnd);

      this._pageElement.addEventListener('scroll', this._boundOnScroll, false);
    }
  }, {
    key: '_destroyEventListeners',
    value: function _destroyEventListeners() {
      if (this._gestureDetector) {
        this._gestureDetector.off('dragup dragdown dragleft dragright', this._boundOnDrag);
        this._gestureDetector.off('dragstart', this._boundOnDragStart);
        this._gestureDetector.off('dragend', this._boundOnDragEnd);

        this._gestureDetector.dispose();
        this._gestureDetector = null;
      }

      this._pageElement.removeEventListener('scroll', this._boundOnScroll, false);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._currentTranslation = 0;
      this._pageElement = this.parentNode;

      this._createEventListeners();
      this._setStyle();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._pageElement.style.marginTop = '';

      this._destroyEventListeners();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'height') {
        this._setStyle();
      }
    }
  }, {
    key: 'height',
    set: function set(value) {
      if (!util.isInteger(value)) {
        throw new Error('The height must be an integer');
      }

      this.setAttribute('height', value + 'px');
    },
    get: function get() {
      return parseInt(this.getAttribute('height') || '64', 10);
    }

    /**
     * @property thresholdHeight
     * @type {Number}
     * @description
     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'thresholdHeight',
    set: function set(value) {
      if (!util.isInteger(value)) {
        throw new Error('The threshold height must be an integer');
      }

      this.setAttribute('threshold-height', value + 'px');
    },
    get: function get() {
      return parseInt(this.getAttribute('threshold-height') || '96', 10);
    }
  }, {
    key: 'state',
    get: function get() {
      return this._getState();
    }
  }, {
    key: 'pullDistance',
    get: function get() {
      return this._currentTranslation;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['height'];
    }
  }, {
    key: 'STATE_INITIAL',
    get: function get() {
      return STATE_INITIAL;
    }
  }, {
    key: 'STATE_PREACTION',
    get: function get() {
      return STATE_PREACTION;
    }
  }, {
    key: 'STATE_ACTION',
    get: function get() {
      return STATE_ACTION;
    }
  }]);
  return PullHookElement;
}(BaseElement);

customElements.define('ons-pull-hook', PullHookElement);

/*
Copyright 2013-2016 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @class AnimatorCSS - implementation of Animator class using css transitions
 */

var AnimatorCSS = function () {
  createClass(AnimatorCSS, [{
    key: 'animate',


    /**
     * @method animate
     * @desc main animation function
     * @param {Element} element
     * @param {Object} finalCSS
     * @param {number} [duration=200] - duration in milliseconds
     * @return {Object} result
     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
     * @example
     * ````
     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
     *
     *  el.addEventListener('click', function(e){
     *    result.speed(200).then(function(){
     *      console.log('done');
     *    });
     *  }, 300);
     * ````
     */
    value: function animate(el, final) {
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var start = new Date().getTime(),
          initial = {},
          stopped = false,
          next = false,
          timeout = false,
          properties = Object.keys(final);

      var updateStyles = function updateStyles() {
        var s = window.getComputedStyle(el);
        properties.forEach(s.getPropertyValue.bind(s));
        s = el.offsetHeight;
      };

      var result = {
        stop: function stop() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          timeout && clearTimeout(timeout);
          var k = Math.min(1, (new Date().getTime() - start) / duration);
          properties.forEach(function (i) {
            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
          });
          el.style.transitionDuration = '0s';

          if (options.stopNext) {
            next = false;
          } else if (!stopped) {
            stopped = true;
            next && next();
          }
          return result;
        },
        then: function then(cb) {
          next = cb;
          if (stopped) {
            next && next();
          }
          return result;
        },
        speed: function speed(newDuration) {
          if (internal$1.config.animationsDisabled) {
            newDuration = 0;
          }
          if (!stopped) {
            (function () {
              timeout && clearTimeout(timeout);

              var passed = new Date().getTime() - start;
              var k = passed / duration;
              var remaining = newDuration * (1 - k);

              properties.forEach(function (i) {
                el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
              });

              updateStyles();

              start = el.speedUpTime;
              duration = remaining;

              el.style.transitionDuration = duration / 1000 + 's';

              properties.forEach(function (i) {
                el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
              });

              timeout = setTimeout(result.stop, remaining);
            })();
          }
          return result;
        },
        finish: function finish() {
          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

          var k = (new Date().getTime() - start) / duration;

          result.speed(milliseconds / (1 - k));
          return result;
        }
      };

      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
        return result;
      }

      var style = window.getComputedStyle(el);
      properties.forEach(function (e) {
        var v = parseFloat(style.getPropertyValue(e));
        initial[e] = isNaN(v) ? 0 : v;
      });

      if (!stopped) {
        el.style.transitionProperty = properties.join(',');
        el.style.transitionDuration = duration / 1000 + 's';

        properties.forEach(function (e) {
          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
        });
      }

      timeout = setTimeout(result.stop, duration);
      this._onStopAnimations(el, result.stop);

      return result;
    }
  }]);

  function AnimatorCSS() {
    classCallCheck(this, AnimatorCSS);

    this._queue = [];
    this._index = 0;
  }

  createClass(AnimatorCSS, [{
    key: '_onStopAnimations',
    value: function _onStopAnimations(el, listener) {
      var queue = this._queue;
      var i = this._index++;
      queue[el] = queue[el] || [];
      queue[el][i] = function (options) {
        delete queue[el][i];
        if (queue[el] && queue[el].length == 0) {
          delete queue[el];
        }
        return listener(options);
      };
    }

    /**
    * @method stopAnimations
    * @desc stops active animations on a specified element
    * @param {Element|Array} element - element or array of elements
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAnimations',
    value: function stopAnimations(el) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(el)) {
        return el.forEach(function (el) {
          _this.stopAnimations(el, options);
        });
      }

      (this._queue[el] || []).forEach(function (e) {
        e(options || {});
      });
    }

    /**
    * @method stopAll
    * @desc stops all active animations
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAll',
    value: function stopAll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stopAnimations(Object.keys(this._queue), options);
    }

    /**
    * @method fade
    * @desc fades the element (short version for animate(el, {opacity: 0}))
    * @param {Element} element
    * @param {number} [duration=200]
    */

  }, {
    key: 'fade',
    value: function fade(el) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

      return this.animate(el, { opacity: 0 }, duration);
    }
  }]);
  return AnimatorCSS;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-ripple
 * @category visual
 * @description
 *   [en]
 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
 *
 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
 *   [/en]
 *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
 * @codepen wKQWdZ
 * @tutorial vanilla/Reference/ripple
 * @guide cross-platform-styling
 *  [en]Cross platform styling[/en]
 *  [ja]Cross platform styling[/ja]
 * @example
 * <div class="my-div">
 *  <ons-ripple></ons-ripple>
 * </div>
 *
 * @example
 * <ons-button ripple>Click me!</ons-button>
 */

var RippleElement = function (_BaseElement) {
  inherits(RippleElement, _BaseElement);

  function RippleElement() {
    classCallCheck(this, RippleElement);
    return possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).apply(this, arguments));
  }

  createClass(RippleElement, [{
    key: 'init',


    /**
     * @attribute color
     * @type {String}
     * @description
     *   [en]Color of the ripple effect.[/en]
     *   [ja]リップルエフェクトの色を指定します。[/ja]
     */

    /**
     * @attribute background
     * @type {String}
     * @description
     *   [en]Color of the background.[/en]
     *   [ja]背景の色を設定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
     *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._animator = new AnimatorCSS();

      ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
        _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add('ripple');

      this._wave = this.getElementsByClassName('ripple__wave')[0];
      this._background = this.getElementsByClassName('ripple__background')[0];

      if (!(this._background && this._wave)) {
        this._wave = util.create('.ripple__wave');
        this._background = util.create('.ripple__background');

        this.appendChild(this._wave);
        this.appendChild(this._background);
      }
    }
  }, {
    key: '_calculateCoords',
    value: function _calculateCoords(e) {
      var x, y, h, w, r;
      var b = this.getBoundingClientRect();
      if (this._center) {
        x = b.width / 2;
        y = b.height / 2;
        r = Math.sqrt(x * x + y * y);
      } else {
        x = (e.clientX || e.changedTouches[0].clientX) - b.left;
        y = (e.clientY || e.changedTouches[0].clientY) - b.top;
        h = Math.max(y, b.height - y);
        w = Math.max(x, b.width - x);
        r = Math.sqrt(h * h + w * w);
      }
      return { x: x, y: y, r: r };
    }
  }, {
    key: '_rippleAnimation',
    value: function _rippleAnimation(e) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

      var _animator = this._animator,
          _wave = this._wave,
          _background = this._background,
          _minR = this._minR,
          _calculateCoords2 = this._calculateCoords(e),
          x = _calculateCoords2.x,
          y = _calculateCoords2.y,
          r = _calculateCoords2.r;

      _animator.stopAll({ stopNext: 1 });
      _animator.animate(_background, { opacity: 1 }, duration);

      util.extend(_wave.style, {
        opacity: 1,
        top: y - _minR + 'px',
        left: x - _minR + 'px',
        width: 2 * _minR + 'px',
        height: 2 * _minR + 'px'
      });

      return _animator.animate(_wave, {
        top: y - r,
        left: x - r,
        height: 2 * r,
        width: 2 * r
      }, duration);
    }
  }, {
    key: '_updateParent',
    value: function _updateParent() {
      if (!this._parentUpdated && this.parentNode) {
        var computedStyle = window.getComputedStyle(this.parentNode);
        if (computedStyle.getPropertyValue('position') === 'static') {
          this.parentNode.style.position = 'relative';
        }
        this._parentUpdated = true;
      }
    }
  }, {
    key: '_onTap',
    value: function _onTap(e) {
      var _this3 = this;

      if (!this.disabled) {
        this._updateParent();
        this._rippleAnimation(e.gesture.srcEvent).then(function () {
          _this3._animator.fade(_this3._wave);
          _this3._animator.fade(_this3._background);
        });
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        this._updateParent();
        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var _this4 = this;

      if (this._holding) {
        this._holding.speed(300).then(function () {
          _this4._animator.stopAll({ stopNext: true });
          _this4._animator.fade(_this4._wave);
          _this4._animator.fade(_this4._background);
        });

        this._holding = false;
      }

      document.removeEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this._holding) {
        return this._onRelease(e);
      }
      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
        this._onTap(e);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._parentNode = this.parentNode;
      this._boundOnTap = this._onTap.bind(this);
      this._boundOnHold = this._onHold.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnRelease = this._onRelease.bind(this);

      if (internal$1.config.animationsDisabled) {
        this.disabled = true;
      } else {
        this._parentNode.addEventListener('tap', this._boundOnTap);
        this._parentNode.addEventListener('hold', this._boundOnHold);
        this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var pn = this._parentNode || this.parentNode;
      pn.removeEventListener('tap', this._boundOnTap);
      pn.removeEventListener('hold', this._boundOnHold);
      pn.removeEventListener('dragstart', this._boundOnDragStart);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      if (name === 'start-radius') {
        this._minR = Math.max(0, parseFloat(current) || 0);
      }
      if (name === 'color' && current) {
        contentReady(this, function () {
          _this5._wave.style.background = current;
          if (!_this5.hasAttribute('background')) {
            _this5._background.style.background = current;
          }
        });
      }
      if (name === 'background' && (current || last)) {
        if (current === 'none') {
          contentReady(this, function () {
            _this5._background.setAttribute('disabled', 'disabled');
            _this5._background.style.background = 'transparent';
          });
        } else {
          contentReady(this, function () {
            if (_this5._background.hasAttribute('disabled')) {
              _this5._background.removeAttribute('disabled');
            }
            _this5._background.style.background = current;
          });
        }
      }
      if (name === 'center') {
        this._center = current != null && current != 'false';
      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['start-radius', 'color', 'background', 'center'];
    }
  }]);
  return RippleElement;
}(BaseElement);

customElements.define('ons-ripple', RippleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-row
 * @category grid
 * @description
 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
 *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
 * @codepen GgujC {wide}
 * @guide layouting
 *   [en]Layouting guide[/en]
 *   [ja]レイアウト調整[/ja]
 * @seealso ons-col
 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
 *   [ja]ons-colコンポーネント[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
 *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
 */

var RowElement = function (_BaseElement) {
  inherits(RowElement, _BaseElement);

  function RowElement() {
    classCallCheck(this, RowElement);
    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
  }

  return RowElement;
}(BaseElement);

customElements.define('ons-row', RowElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$17 = {
  '': 'speed-dial__item--*'
};

/**
 * @element ons-speed-dial-item
 * @category control
 * @description
 *   [en]
 *     This component displays the child elements of the Material Design Speed dial component.
 *   [/en]
 *   [ja]
 *     Material DesignのSpeed dialの子要素を表現する要素です。
 *   [/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component.[/en]
 *   [ja]ons-speed-dialコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialItemElement = function (_BaseElement) {
  inherits(SpeedDialItemElement, _BaseElement);

  function SpeedDialItemElement() {
    classCallCheck(this, SpeedDialItemElement);
    return possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).apply(this, arguments));
  }

  createClass(SpeedDialItemElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the component.[/en]
     *   [ja]このコンポーネントの表現を指定します。[/ja]
     */

    value: function init() {
      this._compile();
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      e.stopPropagation();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add('fab');
      this.classList.add('fab--mini');
      this.classList.add('speed-dial__item');

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$17);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple'];
    }
  }]);
  return SpeedDialItemElement;
}(BaseElement);

customElements.define('ons-speed-dial-item', SpeedDialItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal utility library for manipulating element's style.
 */
var styler = function styler(element, style) {
  return styler.css.apply(styler, arguments);
};

/**
 * Set element's style.
 *
 * @param {Element} element
 * @param {Object} styles
 * @return {Element}
 */
styler.css = function (element, styles) {
  var keys = Object.keys(styles);
  keys.forEach(function (key) {
    if (key in element.style) {
      element.style[key] = styles[key];
    } else if (styler._prefix(key) in element.style) {
      element.style[styler._prefix(key)] = styles[key];
    } else {
      console.warn('No such style property: ' + key);
    }
  });
  return element;
};

/**
 * Add vendor prefix.
 *
 * @param {String} name
 * @return {String}
 */
styler._prefix = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  return function (name) {
    return prefix + name.substr(0, 1).toUpperCase() + name.substr(1);
  };
}();

/**
 * @param {Element} element
 */
styler.clear = function (element) {
  styler._clear(element);
};

/**
 * @param {Element} element
 */
styler._clear = function (element) {
  var len = element.style.length;
  var style = element.style;
  var keys = [];
  for (var i = 0; i < len; i++) {
    keys.push(style[i]);
  }

  keys.forEach(function (key) {
    style[key] = '';
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$18 = {
  '': 'speed-dial--*'
};

/**
 * @element ons-speed-dial
 * @category control
 * @description
 *   [en]
 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
 *
 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
 *   [/en]
 *   [ja][/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial-item
 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
 *   [ja]ons-speed-dial-itemコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialElement = function (_BaseElement) {
  inherits(SpeedDialElement, _BaseElement);

  function SpeedDialElement() {
    classCallCheck(this, SpeedDialElement);
    return possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).apply(this, arguments));
  }

  createClass(SpeedDialElement, [{
    key: 'init',


    /**
     * @event open
     * @description
     *   [en]Fired when the menu items are shown.[/en]
     *   [ja][/ja]
     */

    /**
     * @event close
     * @description
     *   [en]Fired when the menu items are hidden.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the component.[/en]
     *   [ja]このコンポーネントの表現を指定します。[/ja]
     */

    /**
     * @attribute position
     * @type {String}
     * @description
     *   [en]
     *     Specify the vertical and horizontal position of the component.
     *     I.e. to display it in the top right corner specify "right top".
     *     Choose from "right", "left", "top" and "bottom".
     *   [/en]
     *   [ja]
     *     この要素を表示する左右と上下の位置を指定します。
     *     例えば、右上に表示する場合には"right top"を指定します。
     *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
     *   [/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
     *   [ja]
     *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
     *   [/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]無効化する場合に指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._shown = true;
      this._itemShown = false;
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this.classList.contains('speed__dial')) {
        this.classList.add('speed__dial');
        autoStyle.prepare(this);
        this._updateRipple();
        ModifierUtil.initModifier(this, scheme$18);

        if (this.hasAttribute('direction')) {
          this._updateDirection(this.getAttribute('direction'));
        } else {
          this._updateDirection('up');
        }
      }

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this3._updateRipple();
          });
          break;
        case 'direction':
          contentReady(this, function () {
            return _this3._updateDirection(current);
          });
          break;
        case 'position':
          contentReady(this, function () {
            return _this3._updatePosition();
          });
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      if (!this.disabled && this._shown) {
        this.toggleItems();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this.inline) {
        this.show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (!this.inline) {
        this.hide();
      }
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      var fab = util.findChild(this, 'ons-fab');

      if (fab) {
        this.hasAttribute('ripple') ? fab.setAttribute('ripple', '') : fab.removeAttribute('ripple');
      }
    }
  }, {
    key: '_updateDirection',
    value: function _updateDirection(direction) {
      var children = this.items;
      for (var i = 0; i < children.length; i++) {
        styler(children[i], {
          transitionDelay: 25 * i + 'ms',
          bottom: 'auto',
          right: 'auto',
          top: 'auto',
          left: 'auto'
        });
      }
      switch (direction) {
        case 'up':
          for (var _i = 0; _i < children.length; _i++) {
            children[_i].style.bottom = 72 + 56 * _i + 'px';
            children[_i].style.right = '8px';
          }
          break;
        case 'down':
          for (var _i2 = 0; _i2 < children.length; _i2++) {
            children[_i2].style.top = 72 + 56 * _i2 + 'px';
            children[_i2].style.left = '8px';
          }
          break;
        case 'left':
          for (var _i3 = 0; _i3 < children.length; _i3++) {
            children[_i3].style.top = '8px';
            children[_i3].style.right = 72 + 56 * _i3 + 'px';
          }
          break;
        case 'right':
          for (var _i4 = 0; _i4 < children.length; _i4++) {
            children[_i4].style.top = '8px';
            children[_i4].style.left = 72 + 56 * _i4 + 'px';
          }
          break;
        default:
          throw new Error('Argument must be one of up, down, left or right.');
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *   [en]Show the speed dial.[/en]
     *   [ja]Speed dialを表示します。[/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.querySelector('ons-fab').show();
      this._shown = true;
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *   [en]Hide the speed dial.[/en]
     *   [ja]Speed dialを非表示にします。[/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.hideItems();
      setTimeout(function () {
        _this4.querySelector('ons-fab').hide();
      }, 200);
      this._shown = false;
    }

    /**
     * @method showItems
     * @signature showItems()
     * @description
     *   [en]Show the speed dial items.[/en]
     *   [ja]Speed dialの子要素を表示します。[/ja]
     */

  }, {
    key: 'showItems',
    value: function showItems() {

      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      if (!this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          styler(children[i], {
            transform: 'scale(1)',
            transitionDelay: 25 * i + 'ms'
          });
        }
      }
      this._itemShown = true;

      util.triggerElementEvent(this, 'open');
    }

    /**
     * @method hideItems
     * @signature hideItems()
     * @description
     *   [en]Hide the speed dial items.[/en]
     *   [ja]Speed dialの子要素を非表示にします。[/ja]
     */

  }, {
    key: 'hideItems',
    value: function hideItems() {
      if (this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          styler(children[i], {
            transform: 'scale(0)',
            transitionDelay: 25 * (children.length - i) + 'ms'
          });
        }
      }
      this._itemShown = false;
      util.triggerElementEvent(this, 'close');
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'isOpen',


    /**
     * @method isOpen
     * @signature isOpen()
     * @description
     *   [en]Returns whether the menu is open or not.[/en]
     *   [ja][/ja]
     */
    value: function isOpen() {
      return this._itemShown;
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle visibility.[/en]
     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      this.visible ? this.hide() : this.show();
    }

    /**
     * @method toggleItems
     * @signature toggleItems()
     * @description
     *   [en]Toggle item visibility.[/en]
     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggleItems',
    value: function toggleItems() {
      if (this.isOpen()) {
        this.hideItems();
      } else {
        this.showItems();
      }
    }
  }, {
    key: 'items',
    get: function get() {
      return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      if (value) {
        this.hideItems();
      }
      util.arrayFrom(this.children).forEach(function (e) {
        util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
      });

      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property inline
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is inline or not.[/en]
     *   [ja]インライン要素の場合に`true`。[/ja]
     */

  }, {
    key: 'inline',
    get: function get() {
      return this.hasAttribute('inline');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get() {
      return this._shown && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'direction', 'position'];
    }
  }]);
  return SpeedDialElement;
}(BaseElement);

customElements.define('ons-speed-dial', SpeedDialElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var rewritables$1 = {
  /**
   * @param {Element} element
   * @param {Function} callback
   */
  ready: function ready(element, callback) {
    setImmediate(callback);
  }
};

/**
 * @element ons-splitter-content
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
 *
 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
 *  [/en]
 *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` component is the parent element.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterContentElement = function (_BaseElement) {
  inherits(SplitterContentElement, _BaseElement);

  function SplitterContentElement() {
    classCallCheck(this, SplitterContentElement);
    return possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).apply(this, arguments));
  }

  createClass(SplitterContentElement, [{
    key: 'init',


    /**
     * @attribute page
     * @type {String}
     * @description
     *   [en]
     *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
     *
     *     It is also possible to put `<ons-page>` element as a child of the element.
     *   [/en]
     *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      this._page = null;
      this._pageLoader = defaultPageLoader;

      contentReady(this, function () {
        var page = _this2._getPageTarget();

        if (page) {
          _this2.load(page);
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}

    /**
     * @property page
     * @type {HTMLElement}
     * @description
     *   [en]The page to load in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'load',


    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page, [options]
     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in `page` in the content.[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new `<ons-page>` element[/en]
     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]
     */
    value: function load(page) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this3._content || null;

        _this3._pageLoader.load({ page: page, parent: _this3 }, function (pageElement) {
          if (oldContent) {
            _this3._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this3._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      this._content._show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._content._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._pageLoader.unload(this._content);
      this.remove();
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @type {Function}
     * @description
     *   [en]Page element loaded in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader');
      }
      this._pageLoader = loader;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return [];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$1;
    }
  }]);
  return SplitterContentElement;
}(BaseElement);

customElements.define('ons-splitter-content', SplitterContentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterMaskElement = function (_BaseElement) {
  inherits(SplitterMaskElement, _BaseElement);

  function SplitterMaskElement() {
    classCallCheck(this, SplitterMaskElement);
    return possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).apply(this, arguments));
  }

  createClass(SplitterMaskElement, [{
    key: 'init',
    value: function init() {
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (util.match(this.parentNode, 'ons-splitter')) {
        this.parentNode._sides.forEach(function (side) {
          return side.close('left').catch(function () {});
        });
      }
      event.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return [];
    }
  }]);
  return SplitterMaskElement;
}(BaseElement);

customElements.define('ons-splitter-mask', SplitterMaskElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterAnimator = function () {
  function SplitterAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, SplitterAnimator);

    this._options = {
      timing: 'cubic-bezier(.1, .7, .1, 1)',
      duration: '0.3',
      delay: '0'
    };
    this.updateOptions(options);
  }

  createClass(SplitterAnimator, [{
    key: 'updateOptions',
    value: function updateOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      util.extend(this._options, options);
      this._timing = this._options.timing;
      this._duration = this._options.duration;
      this._delay = this._options.delay;
    }

    /**
     * @param {Element} sideElement
     */

  }, {
    key: 'activate',
    value: function activate(sideElement) {
      var _this = this;

      var splitter = sideElement.parentNode;

      contentReady(splitter, function () {
        _this._side = sideElement;
        _this._content = splitter.content;
        _this._mask = splitter.mask;
      });
    }
  }, {
    key: 'inactivate',
    value: function inactivate() {
      this._content = this._side = this._mask = null;
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      animit(this._side).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      animit.runAll(animit(this._side).wait(this._delay).queue({
        transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
      }, {
        duration: this._duration,
        timing: this._timing
      }).queue(function (callback) {
        callback();
        done && done();
      }), animit(this._mask).wait(this._delay).queue({
        display: 'block'
      }).queue({
        opacity: '1'
      }, {
        duration: this._duration,
        timing: 'linear'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this2 = this;

      animit.runAll(animit(this._side).wait(this._delay).queue({
        transform: 'translate3d(0px, 0px, 0px)'
      }, {
        duration: this._duration,
        timing: this._timing
      }).queue(function (callback) {
        _this2._side.style.webkitTransition = '';
        done && done();
        callback();
      }), animit(this._mask).wait(this._delay).queue({
        opacity: '0'
      }, {
        duration: this._duration,
        timing: 'linear'
      }).queue({
        display: 'none'
      }));
    }
  }, {
    key: 'minus',
    get: function get() {
      return this._side._side === 'right' ? '-' : '';
    }
  }]);
  return SplitterAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$5 = {
  default: SplitterAnimator,
  overlay: SplitterAnimator
};

/**
 * @element ons-splitter
 * @category menu
 * @description
 *  [en]
 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
 *
 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
 *  [/en]
 *  [ja][/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter id="splitter">
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 *
 * <script>
 *   var splitter = document.getElementById('splitter');
 *   splitter.left.open();
 * </script>
 */

var SplitterElement = function (_BaseElement) {
  inherits(SplitterElement, _BaseElement);

  function SplitterElement() {
    classCallCheck(this, SplitterElement);
    return possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).apply(this, arguments));
  }

  createClass(SplitterElement, [{
    key: '_getSide',
    value: function _getSide(side) {
      var element = util.findChild(this, function (e) {
        return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
      });
      return element;
    }

    /**
     * @property left
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Left `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      this._sides.some(function (s) {
        return s.isOpen ? s.close() : false;
      }) || event.callParentHandler();
    }
  }, {
    key: '_onModeChange',
    value: function _onModeChange(e) {
      var _this2 = this;

      if (e.target.parentNode) {
        contentReady(this, function () {
          _this2._layout();
        });
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var _this3 = this;

      this._sides.forEach(function (side) {
        _this3.content.style[side.side] = side.mode === 'split' ? side._width : 0;
      });
    }
  }, {
    key: 'init',
    value: function init() {
      var _this4 = this;

      this._boundOnModeChange = this._onModeChange.bind(this);

      contentReady(this, function () {
        _this4._compile();
        _this4._layout();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this.mask) {
        this.appendChild(document.createElement('ons-splitter-mask'));
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
      this.addEventListener('modechange', this._boundOnModeChange, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
      this.removeEventListener('modechange', this._boundOnModeChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: '_show',
    value: function _show() {
      util.propagateAction(this, '_show');
    }
  }, {
    key: '_hide',
    value: function _hide() {
      util.propagateAction(this, '_hide');
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      util.propagateAction(this, '_destroy');
      this.remove();
    }
  }, {
    key: 'left',
    get: function get() {
      return this._getSide('left');
    }
    /**
     * @property right
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Right `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'right',
    get: function get() {
      return this._getSide('right');
    }
  }, {
    key: '_sides',
    get: function get() {
      return [this.left, this.right].filter(function (e) {
        return e;
      });
    }
    /**
     * @property content
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The `<ons-splitter-content>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'content',
    get: function get() {
      return util.findChild(this, 'ons-splitter-content');
    }
  }, {
    key: 'mask',
    get: function get() {
      return util.findChild(this, 'ons-splitter-mask');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator instanceof SplitterAnimator)) {
        throw new Error('Animator parameter must be an instance of SplitterAnimator.');
      }
      _animatorDict$5[name] = Animator;
    }
  }, {
    key: 'SplitterAnimator',
    get: function get() {
      return SplitterAnimator;
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$5;
    }
  }]);
  return SplitterElement;
}(BaseElement);

customElements.define('ons-splitter', SplitterElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SPLIT_MODE = 'split';
var COLLAPSE_MODE = 'collapse';
var CLOSED_STATE = 'closed';
var OPEN_STATE = 'open';
var CHANGING_STATE = 'changing';

var WATCHED_ATTRIBUTES = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold'];

var rewritables$2 = {
  /**
   * @param {Element} splitterSideElement
   * @param {Function} callback
   */
  ready: function ready(splitterSideElement, callback) {
    setImmediate(callback);
  }
};

var CollapseDetection = function () {
  function CollapseDetection(element, target) {
    classCallCheck(this, CollapseDetection);

    this._element = element;
    this._boundOnChange = this._onChange.bind(this);
    target && this.changeTarget(target);
  }

  createClass(CollapseDetection, [{
    key: 'changeTarget',
    value: function changeTarget(target) {
      this.disable();
      this._target = target;
      if (target) {
        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
        this.activate();
      }
    }
  }, {
    key: '_match',
    value: function _match(value) {
      if (this._orientation) {
        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
      }
      return value.matches;
    }
  }, {
    key: '_onChange',
    value: function _onChange(value) {
      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
    }
  }, {
    key: 'activate',
    value: function activate() {
      if (this._orientation) {
        orientation.on('change', this._boundOnChange);
        this._onChange({ isPortrait: orientation.isPortrait() });
      } else {
        this._queryResult = window.matchMedia(this._target);
        this._queryResult.addListener(this._boundOnChange);
        this._onChange(this._queryResult);
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (this._orientation) {
        orientation.off('change', this._boundOnChange);
      } else if (this._queryResult) {
        this._queryResult.removeListener(this._boundOnChange);
        this._queryResult = null;
      }
    }
  }]);
  return CollapseDetection;
}();

var widthToPx = function widthToPx(width, parent) {
  var _ref = [parseInt(width, 10), /px/.test(width)],
      value = _ref[0],
      px = _ref[1];

  return px ? value : Math.round(parent.offsetWidth * value / 100);
};

var CollapseMode = function () {
  createClass(CollapseMode, [{
    key: '_animator',
    get: function get() {
      return this._element._animator;
    }
  }]);

  function CollapseMode(element) {
    classCallCheck(this, CollapseMode);

    this._active = false;
    this._state = CLOSED_STATE;
    this._element = element;
    this._lock = new DoorLock();
  }

  createClass(CollapseMode, [{
    key: 'isOpen',
    value: function isOpen() {
      return this._active && this._state !== CLOSED_STATE;
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(e) {
      if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
        return;
      }
      if (e.type === 'dragstart') {
        this._onDragStart(e);
      } else if (!this._ignoreDrag) {
        e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      var scrolling = !/left|right/.test(event.gesture.direction);
      var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
      var area = this._element._swipeTargetWidth;
      var isOpen = this.isOpen();
      this._ignoreDrag = scrolling || area && distance > area && !isOpen;

      this._width = widthToPx(this._element._width, this._element.parentNode);
      this._startDistance = this._distance = isOpen ? this._width : 0;
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      event.gesture.preventDefault();
      var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
      if (distance !== this._distance) {
        this._animator.translate(distance);
        this._distance = distance;
        this._state = CHANGING_STATE;
      }
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      var distance = this._distance,
          width = this._width,
          el = this._element;

      var direction = event.gesture.interimDirection;
      var shouldOpen = el._side !== direction && distance > width * el._threshold;
      this.executeAction(shouldOpen ? 'open' : 'close');
      this._ignoreDrag = true;
    }
  }, {
    key: 'layout',
    value: function layout() {
      if (this._active && this._state === OPEN_STATE) {
        this._animator.open();
      }
    }

    // enter collapse mode

  }, {
    key: 'enterMode',
    value: function enterMode() {
      if (!this._active) {
        this._active = true;
        this.layout();
      }
    }

    // exit collapse mode

  }, {
    key: 'exitMode',
    value: function exitMode() {
      this._active = false;
    }
  }, {
    key: '_isOpenOtherSideMenu',
    value: function _isOpenOtherSideMenu() {
      var _this = this;

      return util.arrayFrom(this._element.parentElement.children).some(function (e) {
        return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
      });
    }

    /**
     * @param {String} name - 'open' or 'close'
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @param {Boolean} [options.withoutAnimation]
     * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
     */

  }, {
    key: 'executeAction',
    value: function executeAction(name) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

      if (!this._active) {
        return Promise.resolve(false);
      }

      if (this._state === FINAL_STATE) {
        return Promise.resolve(this._element);
      }
      if (this._lock.isLocked()) {
        return Promise.reject('Splitter side is locked.');
      }
      if (name === 'open' && this._isOpenOtherSideMenu()) {
        return Promise.reject('Another menu is already open.');
      }
      if (this._element._emitEvent('pre' + name)) {
        return Promise.reject('Canceled in pre' + name + ' event.');
      }

      var callback = options.callback;
      var unlock = this._lock.lock();
      var done = function done() {
        _this2._state = FINAL_STATE;
        _this2.layout();
        unlock();
        _this2._element._emitEvent('post' + name);
        callback && callback();
      };

      if (options.withoutAnimation) {
        done();
        return Promise.resolve(this._element);
      }
      this._state = CHANGING_STATE;
      return new Promise(function (resolve) {
        _this2._animator[name](function () {
          done();
          resolve(_this2._element);
        });
      });
    }
  }]);
  return CollapseMode;
}();

/**
 * @element ons-splitter-side
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
 *
 *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
 *
 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
 *  [/en]
 *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` is the parent component.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */


var SplitterSideElement = function (_BaseElement) {
  inherits(SplitterSideElement, _BaseElement);

  function SplitterSideElement() {
    classCallCheck(this, SplitterSideElement);
    return possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).apply(this, arguments));
  }

  createClass(SplitterSideElement, [{
    key: 'init',


    /**
     * @event modechange
     * @description
     *   [en]Fired just after the component's mode changes.[/en]
     *   [ja]この要素のモードが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {String} event.mode
     *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
     *   [ja]現在のモードを返します。[/ja]
     */

    /**
     * @event preopen
     * @description
     *   [en]Fired just before the sliding menu is opened.[/en]
     *   [ja]スライディングメニューが開く前に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Function} event.cancel
     *   [en]Call to cancel opening sliding menu.[/en]
     *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event postopen
     * @description
     *   [en]Fired just after the sliding menu is opened.[/en]
     *   [ja]スライディングメニューが開いた後に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event preclose
     * @description
     *   [en]Fired just before the sliding menu is closed.[/en]
     *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call to cancel opening sliding-menu.[/en]
     *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
     */

    /**
     * @event postclose
     * @description
     *   [en]Fired just after the sliding menu is closed.[/en]
     *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default  default
     * @description
     *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
     *  [ja]アニメーションを指定します。"overlay", "default"のいずれかを指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute open-threshold
     * @type {Number}
     * @default  0.3
     * @description
     *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
     *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
     */

    /**
     * @attribute collapse
     * @type {String}
     * @description
     *   [en]
     *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
     *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
     *     If the value is a media query, the view will collapse when the media query resolves to `true`.
     *     If the value is not defined, the view always be in `"collapse"` mode.
     *   [/en]
     *   [ja]
     *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
     *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
     *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
     *     値に何も指定しない場合には、常にcollapseモードになります。
     *   [/ja]
     */

    /**
     * @attribute swipe-target-width
     * @type {String}
     * @description
     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
     */

    /**
     * @attribute width
     * @type {String}
     * @description
     *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
     *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
     */

    /**
     * @attribute side
     * @type {String}
     * @default left
     * @description
     *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
     *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
     */

    /**
     * @attribute mode
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
     *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
     */

    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]The URL of the menu page.[/en]
     *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @type {Boolean}
     * @description
     *   [en]Whether to enable swipe interaction on collapse mode.[/en]
     *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
     */

    value: function init() {
      var _this4 = this;

      this._page = null;
      this._pageLoader = defaultPageLoader;
      this._collapseMode = new CollapseMode(this);
      this._collapseDetection = new CollapseDetection(this);

      this._animatorFactory = new AnimatorFactory({
        animators: SplitterElement.animators,
        baseClass: SplitterAnimator,
        baseClassName: 'SplitterAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
      this._boundHandleGesture = function (e) {
        return _this4._collapseMode.handleGesture(e);
      };
      this._watchedAttributes = WATCHED_ATTRIBUTES;
      contentReady(this, function () {
        rewritables$2.ready(_this4, function () {
          var page = _this4._getPageTarget();

          if (page) {
            _this4.load(page);
          }
        });
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this5 = this;

      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('Parent must be an ons-splitter element.');
      }

      this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

      contentReady(this, function () {
        _this5._watchedAttributes.forEach(function (e) {
          return _this5._update(e);
        });
      });

      if (!this.hasAttribute('side')) {
        this.setAttribute('side', 'left');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._collapseDetection.disable();
      this._gestureDetector.dispose();
      this._gestureDetector = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      this._update(name, current);
    }
  }, {
    key: '_update',
    value: function _update(name, value) {
      name = '_update' + name.split('-').map(function (e) {
        return e[0].toUpperCase() + e.slice(1);
      }).join('');
      return this[name](value);
    }
  }, {
    key: '_emitEvent',
    value: function _emitEvent(name) {
      if (name.slice(0, 3) !== 'pre') {
        return util.triggerElementEvent(this, name, { side: this });
      }
      var isCanceled = false;

      util.triggerElementEvent(this, name, {
        side: this,
        cancel: function cancel() {
          return isCanceled = true;
        }
      });

      return isCanceled;
    }
  }, {
    key: '_updateCollapse',
    value: function _updateCollapse() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');

      if (value === null || value === 'split') {
        this._collapseDetection.disable();
        return this._updateMode(SPLIT_MODE);
      }
      if (value === '' || value === 'collapse') {
        this._collapseDetection.disable();
        return this._updateMode(COLLAPSE_MODE);
      }

      this._collapseDetection.changeTarget(value);
    }

    // readonly attribute for the users

  }, {
    key: '_updateMode',
    value: function _updateMode(mode) {
      if (mode !== this._mode) {
        this._mode = mode;
        this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
        this.setAttribute('mode', mode);

        util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
      }
    }
  }, {
    key: '_updateOpenThreshold',
    value: function _updateOpenThreshold() {
      var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('open-threshold');

      this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
    }
  }, {
    key: '_updateSwipeable',
    value: function _updateSwipeable() {
      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('swipeable');

      var action = swipeable === null ? 'off' : 'on';

      if (this._gestureDetector) {
        this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
      }
    }
  }, {
    key: '_updateSwipeTargetWidth',
    value: function _updateSwipeTargetWidth() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('swipe-target-width');

      this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      this.style.width = this._width;
    }
  }, {
    key: '_updateSide',
    value: function _updateSide() {
      var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('side');

      this._side = side === 'right' ? side : 'left';
    }
  }, {
    key: '_updateAnimation',
    value: function _updateAnimation() {
      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');

      this._animator = this._animatorFactory.newAnimator({ animation: animation });
      this._animator.activate(this);
    }
  }, {
    key: '_updateAnimationOptions',
    value: function _updateAnimationOptions() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');

      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Page location to load in the splitter side.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'open',


    /**
     * @method open
     * @signature open([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been opened.[/en]
     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */
    value: function open() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._collapseMode.executeAction('open', options);
    }

    /**
     * @method close
     * @signature close([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been closed.[/en]
     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'close',
    value: function close() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._collapseMode.executeAction('close', options);
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     * @description
     *   [en]Opens if it's closed. Closes if it's open.[/en]
     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.isOpen ? this.close(options) : this.open(options);
    }

    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in pageUrl in the right section[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',
    value: function load(page) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this6._content || null;

        _this6._pageLoader.load({ page: page, parent: _this6 }, function (pageElement) {
          if (oldContent) {
            _this6._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this6._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      this._content._show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._content._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._pageLoader.unload(this._content);
      this.remove();
    }
  }, {
    key: 'side',
    get: function get() {
      return this.getAttribute('side') === 'right' ? 'right' : 'left';
    }
  }, {
    key: '_width',
    get: function get() {
      var width = this.getAttribute('width');
      return (/^\d+(px|%)$/.test(width) ? width : '80%'
      );
    },
    set: function set(value) {
      this.setAttribute('width', value);
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @description
     *   [en][/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    }

    /**
     * @property mode
     * @readonly
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'mode',
    get: function get() {
      return this._mode;
    }

    /**
     * @property isOpen
     * @type {Boolean}
     * @readonly
     * @description
     *   [en]This value is `true` when the menu is open..[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'isOpen',
    get: function get() {
      return this._collapseMode.isOpen();
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return WATCHED_ATTRIBUTES;
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$2;
    }
  }]);
  return SplitterSideElement;
}(BaseElement);

customElements.define('ons-splitter-side', SplitterSideElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$19 = {
  '': 'switch--*',
  '.switch__input': 'switch--*__input',
  '.switch__handle': 'switch--*__handle',
  '.switch__toggle': 'switch--*__toggle'
};

var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

var locations = {
  ios: [1, 21],
  material: [0, 16]
};

/**
 * @element ons-switch
 * @category form
 * @description
 *   [en]
 *     Switch component. The switch can be toggled both by dragging and tapping.
 *
 *     Will automatically displays a Material Design switch on Android devices.
 *   [/en]
 *   [ja]スイッチを表示するコンポーネントです。[/ja]
 * @modifier material
 *   [en]Material Design switch[/en]
 *   [ja][/ja]
 * @codepen LpXZQQ
 * @tutorial vanilla/Reference/switch
 * @guide adding-page-content
 *   [en]Using form components[/en]
 *   [ja]フォームを使う[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-switch checked></ons-switch>
 * <ons-switch disabled></ons-switch>
 * <ons-switch modifier="material"></ons-switch>
 */

var SwitchElement = function (_BaseElement) {
  inherits(SwitchElement, _BaseElement);

  function SwitchElement() {
    classCallCheck(this, SwitchElement);
    return possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).apply(this, arguments));
  }

  createClass(SwitchElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this._checked = false;
      this._disabled = false;

      this._boundOnChange = this._onChange.bind(this);

      contentReady(this, function () {
        _this2._compile();
        ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
          _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
        });
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add('switch');

      if (!(util.findChild(this, '.switch__input') && util.findChild(this, '.switch__toggle'))) {
        this.appendChild(template$2.cloneNode(true));
      }

      ModifierUtil.initModifier(this, scheme$19);

      this._checkbox = this.querySelector('.switch__input');
      this._handle = this.querySelector('.switch__handle');

      this._checkbox.checked = this._checked;
      this._checkbox.disabled = this._disabled;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._checkbox.removeEventListener('change', _this3._boundOnChange);
        _this3.removeEventListener('dragstart', _this3._onDragStart);
        _this3.removeEventListener('hold', _this3._onHold);
        _this3.removeEventListener('tap', _this3.click);
        _this3.removeEventListener('click', _this3._onClick);
        if (_this3._gestureDetector) {
          _this3._gestureDetector.dispose();
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._checkbox.addEventListener('change', _this4._boundOnChange);
        _this4.addEventListener('dragstart', _this4._onDragStart);
        _this4.addEventListener('hold', _this4._onHold);
        _this4.addEventListener('tap', _this4.click);
        _this4.addEventListener('click', _this4._onClick);
        _this4._gestureDetector = new GestureDetector(_this4, { dragMinDistance: 1, holdTimeout: 251 });
        _this4._boundOnRelease = _this4._onRelease.bind(_this4);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      util.toggleAttribute(this, 'checked', this.checkbox.checked);
    }
  }, {
    key: '_onClick',
    value: function _onClick(ev) {
      if (ev.target.classList.contains('switch__touch')) {
        ev.preventDefault();
      }
    }
  }, {
    key: 'click',
    value: function click() {
      if (!this._disabled) {
        this.checked = !this.checked;

        util.triggerElementEvent(this, 'change', {
          value: this.checked,
          switch: this,
          isInteractive: true
        });
      }
    }
  }, {
    key: '_getPosition',
    value: function _getPosition(e) {
      var l = this._locations;
      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        this.classList.add('switch--active');
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
        this.classList.remove('switch--active');
        return;
      }

      e.stopPropagation();

      this.classList.add('switch--active');
      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

      this.addEventListener('drag', this._onDrag);
      document.addEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.gesture.srcEvent.preventDefault();
      this._handle.style.left = this._getPosition(e) + 'px';
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var l = this._locations;
      var position = this._getPosition(e);
      var previousValue = this.checked;

      this.checked = position >= (l[0] + l[1]) / 2;

      if (this.checked !== previousValue) {
        util.triggerElementEvent(this, 'change', {
          value: this.checked,
          switch: this,
          isInteractive: true
        });
      }

      this.removeEventListener('drag', this._onDrag);
      document.removeEventListener('release', this._boundOnRelease);

      this._handle.style.left = '';
      this.classList.remove('switch--active');
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      contentReady(this, function () {
        switch (name) {
          case 'modifier':
            _this5._isMaterial = (current || '').indexOf('material') !== -1;
            _this5._locations = locations[_this5._isMaterial ? 'material' : 'ios'];
            ModifierUtil.onModifierChanged(last, current, _this5, scheme$19);
            break;
          case 'input-id':
            _this5._checkbox.id = current;
            break;
          case 'checked':
            _this5._checked = current !== null;
            _this5._checkbox.checked = current !== null;
            util.toggleAttribute(_this5._checkbox, name, current !== null);
            break;
          case 'disabled':
            _this5._disabled = current !== null;
            _this5._checkbox.disabled = current !== null;
            util.toggleAttribute(_this5._checkbox, name, current !== null);
        }
      });
    }
  }, {
    key: 'checked',


    /**
     * @event change
     * @description
     *   [en]Fired when the switch is toggled.[/en]
     *   [ja]ON/OFFが変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.switch
     *   [en]Switch object.[/en]
     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
     * @param {Boolean} event.value
     *   [en]Current value.[/en]
     *   [ja]現在の値を返します。[/ja]
     * @param {Boolean} event.isInteractive
     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the switch.[/en]
     *  [ja]スイッチの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the switch is be disabled.[/en]
     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
     */

    /**
     * @attribute checked
     * @description
     *   [en]Whether the switch is checked.[/en]
     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]This value is `true` if the switch is checked.[/en]
     *   [ja]スイッチがONの場合に`true`。[/ja]
     */

    get: function get() {
      return this._checked;
    },
    set: function set(value) {
      this._checked = !!value;
      util.toggleAttribute(this, 'checked', this._checked);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get() {
      return this._disabled;
    },
    set: function set(value) {
      this._disabled = !!value;
      util.toggleAttribute(this, 'disabled', this._disabled);
      this._checkbox.disabled = this._disabled;
    }

    /**
     * @property checkbox
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The underlying checkbox element.[/en]
     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
     */

  }, {
    key: 'checkbox',
    get: function get() {
      return this._checkbox;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'input-id', 'checked', 'disabled'];
    }
  }]);
  return SwitchElement;
}(BaseElement);

customElements.define('ons-switch', SwitchElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var TabbarAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function TabbarAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, TabbarAnimator);

    this.timing = options.timing || 'linear';
    this.duration = options.duration !== undefined ? options.duration : '0.4';
    this.delay = options.delay !== undefined ? options.delay : '0';
  }

  /**
   * @param {Element} enterPage ons-page element
   * @param {Element} leavePage ons-page element
   * @param {Number} enterPageIndex
   * @param {Number} leavePageIndex
   * @param {Function} done
   */


  createClass(TabbarAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
      throw new Error('This method must be implemented.');
    }
  }]);
  return TabbarAnimator;
}();

var TabbarNoneAnimator = function (_TabbarAnimator) {
  inherits(TabbarNoneAnimator, _TabbarAnimator);

  function TabbarNoneAnimator() {
    classCallCheck(this, TabbarNoneAnimator);
    return possibleConstructorReturn(this, (TabbarNoneAnimator.__proto__ || Object.getPrototypeOf(TabbarNoneAnimator)).apply(this, arguments));
  }

  createClass(TabbarNoneAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
      setTimeout(done, 1000 / 60);
    }
  }]);
  return TabbarNoneAnimator;
}(TabbarAnimator);

var TabbarFadeAnimator = function (_TabbarAnimator2) {
  inherits(TabbarFadeAnimator, _TabbarAnimator2);

  function TabbarFadeAnimator(options) {
    classCallCheck(this, TabbarFadeAnimator);

    options.timing = options.timing !== undefined ? options.timing : 'linear';
    options.duration = options.duration !== undefined ? options.duration : '0.4';
    options.delay = options.delay !== undefined ? options.delay : '0';

    return possibleConstructorReturn(this, (TabbarFadeAnimator.__proto__ || Object.getPrototypeOf(TabbarFadeAnimator)).call(this, options));
  }

  createClass(TabbarFadeAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
      animit.runAll(animit(enterPage).saveStyle().queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 0
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 1
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (callback) {
        done();
        callback();
      }), animit(leavePage).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 1
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return TabbarFadeAnimator;
}(TabbarAnimator);

var TabbarSlideAnimator = function (_TabbarAnimator3) {
  inherits(TabbarSlideAnimator, _TabbarAnimator3);

  function TabbarSlideAnimator(options) {
    classCallCheck(this, TabbarSlideAnimator);

    options.timing = options.timing !== undefined ? options.timing : 'ease-in';
    options.duration = options.duration !== undefined ? options.duration : '0.15';
    options.delay = options.delay !== undefined ? options.delay : '0';

    return possibleConstructorReturn(this, (TabbarSlideAnimator.__proto__ || Object.getPrototypeOf(TabbarSlideAnimator)).call(this, options));
  }

  /**
   * @param {jqLite} enterPage
   * @param {jqLite} leavePage
   */


  createClass(TabbarSlideAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
      var sgn = enterIndex > leaveIndex;

      animit.runAll(animit(enterPage).saveStyle().queue({
        transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (callback) {
        done();
        callback();
      }), animit(leavePage).queue({
        transform: 'translate3D(0, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return TabbarSlideAnimator;
}(TabbarAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$21 = {
  '.tab-bar__content': 'tab-bar--*__content',
  '.tab-bar': 'tab-bar--*'
};

var _animatorDict$6 = {
  'default': TabbarNoneAnimator,
  'fade': TabbarFadeAnimator,
  'slide': TabbarSlideAnimator,
  'none': TabbarNoneAnimator
};

var rewritables$3 = {
  /**
   * @param {Element} tabbarElement
   * @param {Function} callback
   */
  ready: function ready(tabbarElement, callback) {
    callback();
  }
};

var generateId$1 = function () {
  var i = 0;
  return function () {
    return 'ons-tabbar-gen-' + i++;
  };
}();

/**
 * @element ons-tabbar
 * @category tabbar
 * @description
 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
 *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @seealso ons-tab
 *   [en]The `<ons-tab>` component.[/en]
 *   [ja]ons-tabコンポーネント[/ja]
 * @seealso ons-page
 *   [en]The `<ons-page>` component.[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>
 */

var TabbarElement = function (_BaseElement) {
  inherits(TabbarElement, _BaseElement);

  function TabbarElement() {
    classCallCheck(this, TabbarElement);
    return possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).apply(this, arguments));
  }

  createClass(TabbarElement, [{
    key: 'init',


    /**
     * @event prechange
     * @description
     *   [en]Fires just before the tab is changed.[/en]
     *   [ja]アクティブなタブが変わる前に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItemオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the change event.[/en]
     *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
     */

    /**
     * @event postchange
     * @description
     *   [en]Fires just after the tab is changed.[/en]
     *   [ja]アクティブなタブが変わった後に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItemオブジェクト。[/ja]
     */

    /**
     * @event reactive
     * @description
     *   [en]Fires if the already open tab is tapped again.[/en]
     *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItemオブジェクト。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default none
     * @description
     *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
     *   [ja]ページ読み込み時のアニメーションを指定します。"none"、"fade"、"slide"のいずれかを選択できます。デフォルトは"none"です。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute position
     * @initonly
     * @type {String}
     * @default bottom
     * @description
     *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
     *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
     */

    value: function init() {
      var _this2 = this;

      this._tabbarId = generateId$1();

      contentReady(this, function () {
        _this2._compile();

        var content = _this2._contentElement;
        for (var i = 0; i < content.children.length; i++) {
          content.children[i].style.display = 'none';
        }

        var activeIndex = _this2.getAttribute('activeIndex');

        var tabbar = _this2._tabbarElement;
        if (activeIndex && tabbar.children.length > activeIndex) {
          tabbar.children[activeIndex].setAttribute('active', 'true');
        }

        autoStyle.prepare(_this2);
        ModifierUtil.initModifier(_this2, scheme$21);

        _this2._animatorFactory = new AnimatorFactory({
          animators: _animatorDict$6,
          baseClass: TabbarAnimator,
          baseClassName: 'TabbarAnimator',
          defaultAnimation: _this2.getAttribute('animation')
        });
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        return _this3._updatePosition();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (this._contentElement && this._tabbarElement) {
        var content = util.findChild(this, '.tab-bar__content');
        var bar = util.findChild(this, '.tab-bar');

        content.classList.add('ons-tab-bar__content');
        bar.classList.add('ons-tab-bar__footer');
      } else {

        var _content = util.create('.ons-tab-bar__content.tab-bar__content');
        var tabbar = util.create('.tab-bar.ons-tab-bar__footer');

        while (this.firstChild) {
          tabbar.appendChild(this.firstChild);
        }

        this.appendChild(_content);
        this.appendChild(tabbar);
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var _this4 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');

      var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
      var action = top ? util.addModifier : util.removeModifier;

      action(this, 'top');

      var page = util.findParent(this, 'ons-page');
      if (page) {
        this.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

        if (util.match(page.firstChild, 'ons-toolbar')) {
          action(page.firstChild, 'noshadow');
        }
      }

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this4, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this4, 'status-bar-fill', top && !filled);
      });
    }
  }, {
    key: '_getTabbarElement',
    value: function _getTabbarElement() {
      return util.findChild(this, '.tab-bar');
    }

    /**
     * @method loadPage
     * @deprecated
     * @signature loadPage(url, [options])
     * @param {String} url
     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
     *   [ja]pageのURLか、もしくはons-templateで宣言したid属性の値を利用できます。[/ja]
     * @description
     *   [en]Displays a new page without changing the active index.[/en]
     *   [ja]現在のアクティブなインデックスを変更せずに、新しいページを表示します。[/ja]
     * @param {Object} [options]
     *   [en][/en]
     *   [ja][/ja]
     * @param {Object} [options.animation]
     *   [en][/en]
     *   [ja][/ja]
     * @param {Object} [options.callback]
     *   [en][/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'loadPage',
    value: function loadPage(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      console.warn('The loadPage method has been deprecated and will be removed in the next minor version.');

      return new Promise(function (resolve) {
        var tab = _this5._tabbarElement.children[0] || new TabElement();
        tab._loadPage(page, _this5._contentElement, function (pageElement) {
          resolve(_this5._loadPageDOMAsync(pageElement, options));
        });
      });
    }

    /**
     * @param {Element} pageElement
     * @param {Object} [options]
     * @param {Object} [options.animation]
     * @param {Object} [options.callback]
     * @return {Promise} Resolves to the new page element.
     */

  }, {
    key: '_loadPageDOMAsync',
    value: function _loadPageDOMAsync(pageElement) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return new Promise(function (resolve) {
        _this6._contentElement.appendChild(pageElement);

        if (_this6.getActiveTabIndex() !== -1) {
          resolve(_this6._switchPage(pageElement, options));
        } else {
          if (options.callback instanceof Function) {
            options.callback();
          }

          _this6._oldPageElement = pageElement;
          resolve(pageElement);
        }
      });
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getTabbarId',
    value: function getTabbarId() {
      return this._tabbarId;
    }

    /**
     * @return {Element/null}
     */

  }, {
    key: '_getCurrentPageElement',
    value: function _getCurrentPageElement() {
      var pages = this._contentElement.children;
      var page = null;
      for (var i = 0; i < pages.length; i++) {
        if (pages[i].style.display !== 'none') {
          page = pages[i];
          break;
        }
      }

      if (page && page.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('Invalid state: page element must be a "ons-page" element.');
      }

      return page;
    }
  }, {
    key: '_switchPage',


    /**
     * @param {Element} element
     * @param {Object} options
     * @param {String} [options.animation]
     * @param {Function} [options.callback]
     * @param {Object} [options.animationOptions]
     * @param {Number} options.selectedTabIndex
     * @param {Number} options.previousTabIndex
     * @return {Promise} Resolves to the new page element.
     */
    value: function _switchPage(element, options) {
      var oldPageElement = this._oldPageElement || internal$1.nullElement;
      this._oldPageElement = element;
      var animator = this._animatorFactory.newAnimator(options);

      return new Promise(function (resolve) {
        if (oldPageElement !== internal$1.nullElement) {
          oldPageElement._hide();
        }

        animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
          if (oldPageElement !== internal$1.nullElement) {
            oldPageElement.style.display = 'none';
          }

          element.style.display = 'block';
          element._show();

          if (options.callback instanceof Function) {
            options.callback();
          }

          resolve(element);
        });
      });
    }

    /**
     * @method setActiveTab
     * @signature setActiveTab(index, [options])
     * @param {Number} index
     *   [en]Tab index.[/en]
     *   [ja]タブのインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Boolean} [options.keepPage]
     *   [en]If true the page will not be changed.[/en]
     *   [ja]タブバーが現在表示しているpageを変えない場合にはtrueを指定します。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。`"fade"`、`"slide"`、`"none"`のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveTab',
    value: function setActiveTab(index) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      if (!options.animation && this.hasAttribute('animation')) {
        options.animation = this.getAttribute('animation');
      }

      var previousTab = this._getActiveTabElement(),
          selectedTab = this._getTabElement(index),
          previousTabIndex = this.getActiveTabIndex(),
          selectedTabIndex = index,
          previousPageElement = this._getCurrentPageElement();

      if (!selectedTab) {
        return Promise.reject('Specified index does not match any tab.');
      }

      if (selectedTabIndex === previousTabIndex) {
        util.triggerElementEvent(this, 'reactive', {
          index: selectedTabIndex,
          tabItem: selectedTab
        });

        return Promise.resolve(previousPageElement);
      }

      var canceled = false;

      util.triggerElementEvent(this, 'prechange', {
        index: selectedTabIndex,
        tabItem: selectedTab,
        cancel: function cancel() {
          return canceled = true;
        }
      });

      if (canceled) {
        selectedTab.setInactive();
        if (previousTab) {
          previousTab.setActive();
        }
        return Promise.reject('Canceled in prechange event.');
      }

      selectedTab.setActive();

      var params = _extends({}, options, {
        previousTabIndex: previousTabIndex,
        selectedTabIndex: selectedTabIndex
      });

      if (previousTab) {
        previousTab.setInactive();
      } else {
        params.animation = 'none';
      }

      return new Promise(function (resolve) {
        selectedTab._loadPageElement(_this7._contentElement, function (pageElement) {
          pageElement.removeAttribute('style');

          _this7._switchPage(pageElement, params).then(function (page) {
            util.triggerElementEvent(_this7, 'postchange', {
              index: selectedTabIndex,
              tabItem: selectedTab
            });

            return resolve(page);
          });
        });
      });
    }

    /**
     * @method setTabbarVisibility
     * @signature setTabbarVisibility(visible)
     * @param {Boolean} visible
     * @description
     *   [en]Used to hide or show the tab bar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setTabbarVisibility',
    value: function setTabbarVisibility(visible) {
      this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
      this._getTabbarElement().style.display = visible ? '' : 'none';
    }

    /**
     * @method getActiveTabIndex
     * @signature getActiveTabIndex()
     * @return {Number}
     *   [en]The index of the currently active tab.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
     * @description
     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
     */

  }, {
    key: 'getActiveTabIndex',
    value: function getActiveTabIndex() {
      var tabs = this._getTabbarElement().children;

      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i] instanceof TabElement && tabs[i].isActive && tabs[i].isActive()) {
          return i;
        }
      }

      return -1;
    }

    /**
     * @return {Number} When active tab is not found, returns -1.
     */

  }, {
    key: '_getActiveTabElement',
    value: function _getActiveTabElement() {
      return this._getTabElement(this.getActiveTabIndex());
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_getTabElement',
    value: function _getTabElement(index) {
      return this._getTabbarElement().children[index];
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: '_show',
    value: function _show() {
      var currentPageElement = this._getCurrentPageElement();
      if (currentPageElement) {
        currentPageElement._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var currentPageElement = this._getCurrentPageElement();
      if (currentPageElement) {
        currentPageElement._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      var tabs = this._getTabbarElement().children;
      for (var i = tabs.length - 1; i >= 0; i--) {
        tabs[i].remove();
      }
      this.remove();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$21);
      }
    }
  }, {
    key: '_contentElement',
    get: function get() {
      return util.findChild(this, '.tab-bar__content');
    }
  }, {
    key: '_tabbarElement',
    get: function get() {
      return util.findChild(this, '.tab-bar');
    }
  }, {
    key: 'pages',
    get: function get() {
      return util.arrayFrom(this._contentElement.children);
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {Function} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof TabbarAnimator)) {
        throw new Error('"Animator" param must inherit TabbarElement.TabbarAnimator');
      }
      _animatorDict$6[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$3;
    }
  }, {
    key: 'TabbarAnimator',
    get: function get() {
      return TabbarAnimator;
    }
  }]);
  return TabbarElement;
}(BaseElement);

customElements.define('ons-tabbar', TabbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$20 = {
  '': 'tab-bar--*__item',
  '.tab-bar__button': 'tab-bar--*__button'
};
var templateSource$1 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button"></button>\n  </div>\n');
var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n    <div class="tab-bar__badge notification">1</div>\n  </div>\n');

/**
 * @element ons-tab
 * @category tabbar
 * @description
 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
 *   [ja]
 *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
 *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
 *   [/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide multiple-page-navigation
 *   [en]Managing multiple pages.[/en]
 *   [ja]Managing multiple pages[/ja]]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @seealso ons-tabbar
 *   [en]ons-tabbar component[/en]
 *   [ja]ons-tabbarコンポーネント[/ja]
 * @seealso ons-page
 *   [en]ons-page component[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]ons-icon component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>

 */

var TabElement = function (_BaseElement) {
  inherits(TabElement, _BaseElement);

  function TabElement() {
    classCallCheck(this, TabElement);
    return possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).apply(this, arguments));
  }

  createClass(TabElement, [{
    key: 'init',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]The page that is displayed when the tab is tapped.[/en]
     *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
     */

    /**
     * @attribute icon
     * @type {String}
     * @description
     *   [en]
     *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
     *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
     *   [/en]
     *   [ja]
     *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
     *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
     *   [/ja]
     */

    /**
     * @attribute active-icon
     * @type {String}
     * @description
     *   [en]The name of the icon when the tab is active.[/en]
     *   [ja]アクティブの際のアイコン名を指定します。[/ja]
     */

    /**
     * @attribute label
     * @type {String}
     * @description
     *   [en]The label of the tab item.[/en]
     *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
     */

    /**
     * @attribute badge
     * @type {String}
     * @description
     *   [en]Display a notification badge on top of the tab.[/en]
     *   [ja]バッジに表示する内容を指定します。[/ja]
     */

    /**
     * @attribute active
     * @description
     *   [en]This attribute should be set to the tab that is active by default.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      this._pageLoader = defaultPageLoader;
      this._page = null;

      if (this.hasAttribute('label') || this.hasAttribute('icon') || this.hasAttribute('badge')) {
        this._compile();
      } else {
        contentReady(this, function () {
          _this2._compile();
        });
      }

      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this.page || this.getAttribute('page');
    }
  }, {
    key: '_templateLoaded',
    value: function _templateLoaded() {
      if (this.children.length == 0) {
        return false;
      }

      var hasInput = this.children[0].getAttribute('type') === 'radio';
      var hasButton = util.findChild(this, '.tab-bar__button');

      return hasInput && hasButton;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add('tab-bar__item');

      if (!this._templateLoaded()) {
        var fragment = document.createDocumentFragment();
        var hasChildren = false;

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          fragment.appendChild(node);

          if (node.nodeType == Node.ELEMENT_NODE) {
            hasChildren = true;
          }
        }

        var template = templateSource$1.cloneNode(true);
        while (template.children[0]) {
          this.appendChild(template.children[0]);
        }

        var button = util.findChild(this, '.tab-bar__button');

        if (hasChildren) {
          button.appendChild(fragment);
          this._hasDefaultTemplate = false;
        } else {
          this._hasDefaultTemplate = true;
          this._updateDefaultTemplate();
        }
      }

      ModifierUtil.initModifier(this, scheme$20);
      this._updateRipple();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      // util.updateRipple(this.querySelector('.tab-bar__button'), this);
    }
  }, {
    key: '_updateDefaultTemplate',
    value: function _updateDefaultTemplate() {
      if (!this._hasDefaultTemplate) {
        return;
      }

      var button = util.findChild(this, '.tab-bar__button');
      var template = defaultInnerTemplateSource.cloneNode(true);
      if (button.children.length == 0) {
        while (template.children[0]) {
          button.appendChild(template.children[0]);
        }
      }

      if (!button.querySelector('.tab-bar__icon')) {
        button.insertBefore(template.querySelector('.tab-bar__icon'), button.firstChild);
      }

      if (!button.querySelector('.tab-bar__label')) {
        button.appendChild(template.querySelector('.tab-bar__label'));
      }

      if (!button.querySelector('.tab-bar__badge')) {
        button.appendChild(template.querySelector('.tab-bar__badge'));
      }

      var self = this;
      var icon = this.getAttribute('icon');
      var label = this.getAttribute('label');
      var badge = this.getAttribute('badge');

      if (typeof icon === 'string') {
        var iconElement = getIconElement();
        var last = iconElement.getAttribute('icon');
        iconElement.setAttribute('icon', icon);
        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
        getIconElement().attributeChangedCallback('icon', last, icon);
      } else {
        var wrapper = button.querySelector('.tab-bar__icon');
        if (wrapper) {
          wrapper.remove();
        }
      }

      if (typeof label === 'string') {
        getLabelElement().textContent = label;
      } else {
        var _label = getLabelElement();
        if (_label) {
          _label.remove();
        }
      }

      if (typeof badge === 'string') {
        getBadgeElement().textContent = badge;
      } else {
        var _badge = getBadgeElement();
        if (_badge) {
          _badge.remove();
        }
      }

      function getLabelElement() {
        return self.querySelector('.tab-bar__label');
      }

      function getIconElement() {
        return self.querySelector('ons-icon');
      }

      function getBadgeElement() {
        return self.querySelector('.tab-bar__badge');
      }
    }
  }, {
    key: '_onClick',
    value: function _onClick() {
      var tabbar = this._findTabbarElement();
      if (tabbar) {
        tabbar.setActiveTab(this._findTabIndex());
      }
    }
  }, {
    key: 'setActive',
    value: function setActive() {
      var radio = util.findChild(this, 'input');
      radio.checked = true;
      this.classList.add('active');

      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
        return element.style.display = 'none';
      });
      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
        return element.style.display = 'inherit';
      });
    }
  }, {
    key: 'setInactive',
    value: function setInactive() {
      var radio = util.findChild(this, 'input');
      radio.checked = false;
      this.classList.remove('active');

      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
        return element.style.display = 'inherit';
      });
      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
        return element.style.display = 'none';
      });
    }

    /**
     * @param {Element} parent
     * @param {Function} callback
     */

  }, {
    key: '_loadPageElement',
    value: function _loadPageElement(parent, callback) {
      var _this3 = this;

      if (!this._loadedPage && !this._getPageTarget()) {
        var pages = this._findTabbarElement().pages;
        var index = this._findTabIndex();
        callback(pages[index]);
      } else if (this._loadingPage) {
        this._loadingPage.then(function (pageElement) {
          callback(pageElement);
        });
      } else if (!this._loadedPage) {
        (function () {
          var deferred = util.defer();
          _this3._loadingPage = deferred.promise;

          _this3._pageLoader.load({ page: _this3._getPageTarget(), parent: parent }, function (pageElement) {
            _this3._loadedPage = pageElement;
            deferred.resolve(pageElement);
            delete _this3._loadingPage;

            callback(pageElement);
          });
        })();
      } else {
        callback(this._loadedPage);
      }
    }
  }, {
    key: '_loadPage',
    value: function _loadPage(page, parent, callback) {
      this._pageLoader.load({ page: page, parent: parent }, function (pageElement) {
        callback(pageElement);
      });
    }
  }, {
    key: 'isActive',


    /**
     * @return {Boolean}
     */
    value: function isActive() {
      return this.classList.contains('active');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
      if (this._loadedPage) {
        this._pageLoader.unload(this._loadedPage);
        this._loadedPage = null;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._ensureElementPosition();

        var tabbar = _this4._findTabbarElement();

        if (tabbar.hasAttribute('modifier')) {
          var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
          _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
        }

        var onReady = function onReady() {
          if (_this4._getPageTarget() && !_this4.hasLoaded) {
            _this4.hasLoaded = true;
            _this4._loadPageElement(tabbar._contentElement, function (pageElement) {
              pageElement.style.display = 'none';
              tabbar._contentElement.appendChild(pageElement);

              if (_this4.hasAttribute('active')) {
                tabbar.setActiveTab(_this4._findTabIndex());
              }
            });
          }
        };

        TabbarElement.rewritables.ready(tabbar, onReady);

        _this4.addEventListener('click', _this4._boundOnClick, false);
      });
    }
  }, {
    key: '_findTabbarElement',
    value: function _findTabbarElement() {
      if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
        return this.parentNode;
      }

      if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
        return this.parentNode.parentNode;
      }

      return null;
    }
  }, {
    key: '_findTabIndex',
    value: function _findTabIndex() {
      var elements = this.parentNode.children;
      for (var i = 0; i < elements.length; i++) {
        if (this === elements[i]) {
          return i;
        }
      }
    }
  }, {
    key: '_ensureElementPosition',
    value: function _ensureElementPosition() {
      if (!this._findTabbarElement()) {
        throw new Error('This ons-tab element is must be child of ons-tabbar element.');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$20);
          });
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this5._updateRipple();
          });
          break;
        case 'icon':
        case 'label':
        case 'badge':
          contentReady(this, function () {
            return _this5._updateDefaultTemplate();
          });
          break;
        case 'page':
          if (typeof current === 'string') {
            this._page = current;
          }
          break;
      }
    }
  }, {
    key: 'page',
    set: function set(page) {
      this._page = page;
    },
    get: function get() {
      return this._page;
    }
  }, {
    key: 'pageLoader',
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    },
    get: function get() {
      return this._pageLoader;
    }
  }, {
    key: 'pageElement',
    get: function get() {
      if (this._loadedPage) {
        return this._loadedPage;
      }

      var tabbar = this._findTabbarElement();
      var index = this._findTabIndex();

      return tabbar._contentElement.children[index];
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge'];
    }
  }]);
  return TabElement;
}(BaseElement);

customElements.define('ons-tab', TabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$22 = { '': 'toolbar-button--*' };

/**
 * @element ons-toolbar-button
 * @category page
 * @modifier material
 *   [en]Material Design toolbar button.[/en]
 *   [ja][/ja]
 * @modifier outline
 *   [en]A button with an outline.[/en]
 *   [ja]アウトラインをもったボタンを表示します。[/ja]
 * @description
 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
 *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide adding-a-toolbar
 *   [en]Adding a toolbar[/en]
 *   [ja]ツールバーの追加[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-toolbar-button>
 *       Button
 *     </ons-toolbar-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   </div>
 *   <div class="right">
 *     <ons-toolbar-button>
 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
 *     </ons-toolbar-button>
 *   </div>
 * </ons-toolbar>
 */

var ToolbarButtonElement = function (_BaseElement) {
  inherits(ToolbarButtonElement, _BaseElement);

  function ToolbarButtonElement() {
    classCallCheck(this, ToolbarButtonElement);
    return possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).apply(this, arguments));
  }

  createClass(ToolbarButtonElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
     */

    value: function init() {
      this._compile();
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add('toolbar-button');

      ModifierUtil.initModifier(this, scheme$22);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
      }
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return ToolbarButtonElement;
}(BaseElement);

customElements.define('ons-toolbar-button', ToolbarButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$23 = {
  '.range': 'range--*',
  '.range__left': 'range--*__left'
};

var templateSource$2 = util.createElement('<div>\n  <div class="range__left"></div>\n  <input type="range" class="range">\n</div>');

var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

/**
 * @element ons-range
 * @category form
 * @modifier material
 *   [en]Material Design slider[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Range input component. Used to display a draggable slider.
 *
 *     Works very similar to the `<input type="range">` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xZQomM
 * @tutorial vanilla/Reference/range
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
 *   [ja][/ja]
 * @example
 * <ons-range value="20"></ons-range>
 * <ons-range modifier="material" value="10"></range>
 */

var RangeElement = function (_BaseElement) {
  inherits(RangeElement, _BaseElement);

  function RangeElement() {
    classCallCheck(this, RangeElement);
    return possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).apply(this, arguments));
  }

  createClass(RangeElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2._updateBoundAttributes();
        _this2._onChange();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (!(util.findChild(this, '.range__left') && util.findChild(this, 'input'))) {
        var template = templateSource$2.cloneNode(true);
        while (template.children[0]) {
          this.appendChild(template.children[0]);
        }
      }

      ModifierUtil.initModifier(this, scheme$23);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._left.style.width = 100 * this._ratio + '%';
    }
  }, {
    key: '_onDragstart',
    value: function _onDragstart(e) {
      e.stopPropagation();
      e.gesture.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$23);
      } else if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
        contentReady(this, function () {
          _this3._updateBoundAttributes();

          if (name === 'min' || name === 'max') {
            _this3._onChange();
          }
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('dragstart', this._onDragstart);
      this.addEventListener('input', this._onChange);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('dragstart', this._onDragstart);
      this.removeEventListener('input', this._onChange);
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this4 = this;

      INPUT_ATTRIBUTES$1.forEach(function (attr) {
        if (_this4.hasAttribute(attr)) {
          _this4._input.setAttribute(attr, _this4.getAttribute(attr));
        } else {
          _this4._input.removeAttribute(attr);
        }
      });
    }
  }, {
    key: '_ratio',
    get: function get() {
      // Returns the current ratio.
      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

      return (this.value - min) / (max - min);
    }
  }, {
    key: '_input',
    get: function get() {
      return this.querySelector('input');
    }
  }, {
    key: '_left',
    get: function get() {
      return this.querySelector('.range__left');
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current value.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'value',
    get: function get() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set(val) {
      var _this5 = this;

      contentReady(this, function () {
        _this5._input.value = val;
        _this5._onChange();
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'].concat(INPUT_ATTRIBUTES$1);
    }
  }]);
  return RangeElement;
}(BaseElement);

customElements.define('ons-range', RangeElement);

ons$1.TemplateElement = TemplateElement;
ons$1.IfElement = IfElement;
ons$1.AlertDialogElement = AlertDialogElement;
ons$1.BackButtonElement = BackButtonElement;
ons$1.BottomToolbarElement = BottomToolbarElement;
ons$1.ButtonElement = ButtonElement;
ons$1.CarouselItemElement = CarouselItemElement;
ons$1.CarouselElement = CarouselElement;
ons$1.ColElement = ColElement;
ons$1.DialogElement = DialogElement;
ons$1.FabElement = FabElement;
ons$1.GestureDetectorElement = GestureDetectorElement;
ons$1.IconElement = IconElement;
ons$1.LazyRepeatElement = LazyRepeatElement;
ons$1.ListHeaderElement = ListHeaderElement;
ons$1.ListItemElement = ListItemElement;
ons$1.ListElement = ListElement;
ons$1.InputElement = InputElement;
ons$1.ModalElement = ModalElement;
ons$1.NavigatorElement = NavigatorElement;
ons$1.PageElement = PageElement;
ons$1.PopoverElement = PopoverElement;
ons$1.ProgressBarElement = ProgressBarElement;
ons$1.ProgressCircularElement = ProgressCircularElement;
ons$1.PullHookElement = PullHookElement;
ons$1.RippleElement = RippleElement;
ons$1.RowElement = RowElement;
ons$1.SpeedDialItemElement = SpeedDialItemElement;
ons$1.SpeedDialElement = SpeedDialElement;
ons$1.SplitterContentElement = SplitterContentElement;
ons$1.SplitterMaskElement = SplitterMaskElement;
ons$1.SplitterSideElement = SplitterSideElement;
ons$1.SplitterElement = SplitterElement;
ons$1.SwitchElement = SwitchElement;
ons$1.TabElement = TabElement;
ons$1.TabbarElement = TabbarElement;
ons$1.ToolbarButtonElement = ToolbarButtonElement;
ons$1.ToolbarElement = ToolbarElement;
ons$1.RangeElement = RangeElement;

// fastclick
window.addEventListener('load', function () {
  ons$1.fastClick = FastClick.attach(document.body);
}, false);

// ons._defaultDeviceBackButtonHandler
window.addEventListener('DOMContentLoaded', function () {
  ons$1._deviceBackButtonDispatcher.enable();
  ons$1._defaultDeviceBackButtonHandler = ons$1._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
    navigator.app.exitApp();
  });
  document.body._gestureDetector = new ons$1.GestureDetector(document.body);
}, false);

// setup loading placeholder
ons$1.ready(function () {
  ons$1._setupLoadingPlaceHolders();
});

// viewport.js
new Viewport().setup();

return ons$1;

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUV2ZW50LmpzIiwiTXV0YXRpb25PYnNlcnZlci5qcyIsImFuaW1pdC5qcyIsImNoaWxkTm9kZVJlbW92ZS5qcyIsImNsYXNzTGlzdC5qcyIsImRvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQubWF4LmpzIiwiZmFzdGNsaWNrLXBhdGNoZWQuanMiLCJpbm5lckhUTUwuanMiLCJtaWNyb2V2ZW50LmpzIiwicHJvbWlzZS5qcyIsInNldEltbWVkaWF0ZS5qcyIsInZpZXdwb3J0LmpzIiwid2luc3RvcmUtanNjb21wYXQuanMiLCJvbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwib25zL3V0aWwuanMiLCJvbnMvZ2VzdHVyZS1kZXRlY3Rvci5qcyIsIm9ucy9wbGF0Zm9ybS5qcyIsIm9ucy9jb250ZW50LXJlYWR5LmpzIiwib25zL25vdGlmaWNhdGlvbi5qcyIsIm9ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwib25zL2ludGVybmFsL2ludGVybmFsLmpzIiwib25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCJvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbC5qcyIsIm9ucy9pbnRlcm5hbC9sYXp5LXJlcGVhdC5qcyIsIm9ucy9pbnRlcm5hbC9pbmRleC5qcyIsIm9ucy9vcmllbnRhdGlvbi5qcyIsIm9ucy9zb2Z0d2FyZS1rZXlib2FyZC5qcyIsIm9ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlci5qcyIsIm9ucy9hdXRvc3R5bGUuanMiLCJvbnMvZG9vcmxvY2suanMiLCJvbnMvcGFnZS1sb2FkZXIuanMiLCJvbnMvb25zLmpzIiwib25zL2Jhc2UtZWxlbWVudC5qcyIsImVsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsImVsZW1lbnRzL29ucy1pZi5qcyIsImVsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLWJhY2stYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyLmpzIiwiZWxlbWVudHMvb25zLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtLmpzIiwiZWxlbWVudHMvb25zLWNhcm91c2VsLmpzIiwiZWxlbWVudHMvb25zLWNvbC5qcyIsImVsZW1lbnRzL29ucy1kaWFsb2cvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtZGlhbG9nL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLWZhYi5qcyIsImVsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yLmpzIiwiZWxlbWVudHMvb25zLWljb24uanMiLCJlbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQuanMiLCJlbGVtZW50cy9vbnMtbGlzdC1oZWFkZXIuanMiLCJlbGVtZW50cy9vbnMtbGlzdC1pdGVtLmpzIiwiZWxlbWVudHMvb25zLWxpc3QuanMiLCJlbGVtZW50cy9vbnMtaW5wdXQuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zbGlkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1wYWdlLmpzIiwiZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXIuanMiLCJlbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXIuanMiLCJlbGVtZW50cy9vbnMtcHVsbC1ob29rLmpzIiwiZWxlbWVudHMvb25zLXJpcHBsZS9hbmltYXRvci1jc3MuanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXJvdy5qcyIsImVsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0uanMiLCJsaWIvc3R5bGVyLmpzIiwiZWxlbWVudHMvb25zLXNwZWVkLWRpYWwuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItY29udGVudC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUuanMiLCJlbGVtZW50cy9vbnMtc3dpdGNoLmpzIiwiZWxlbWVudHMvb25zLXRhYmJhci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy10YWJiYXIvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtdGFiLmpzIiwiZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLXJhbmdlLmpzIiwic2V0dXAuanMiXSwibmFtZXMiOlsidW53cmFwIiwic3RyaW5nIiwic2xpY2UiLCJpc09iamVjdFN0cmluZyIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImlzQXJyYXlTdHJpbmciLCJpc1F1b3RlZFN0cmluZyIsImVycm9yIiwidG9rZW4iLCJvcmlnaW5hbFN0cmluZyIsIkVycm9yIiwibGVuZ3RoIiwicHJvY2Vzc1Rva2VuIiwiaXNOYU4iLCJwYXJzZU9iamVjdCIsInBhcnNlQXJyYXkiLCJuZXh0VG9rZW4iLCJ0cmltTGVmdCIsImxpbWl0IiwiYyIsImNoYXJDb2RlQXQiLCJuZXN0ZWRPYmplY3QiLCJpIiwiaW5kZXhPZiIsImlzVmFsaWRLZXkiLCJ0ZXN0Iiwia2V5IiwidHJpbSIsIm9iamVjdCIsInJlYWRpbmdLZXkiLCJwcmV2aW91c1Rva2VuIiwiYXJyYXkiLCJwdXNoIiwicGFyc2UiLCJ1dGlsIiwicHJlcGFyZVF1ZXJ5IiwicXVlcnkiLCJGdW5jdGlvbiIsImVsZW1lbnQiLCJtYXRjaCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImZpbmRDaGlsZCIsImNoaWxkcmVuIiwibm9kZSIsImZpbmRQYXJlbnQiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiZG9jdW1lbnQiLCJpc0F0dGFjaGVkIiwiZG9jdW1lbnRFbGVtZW50IiwiaGFzQW55Q29tcG9uZW50QXNQYXJlbnQiLCJwcm9wYWdhdGVBY3Rpb24iLCJhY3Rpb24iLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJjcmVhdGUiLCJzZWxlY3RvciIsInN0eWxlIiwic3BsaXQiLCJjcmVhdGVFbGVtZW50Iiwic2hpZnQiLCJjbGFzc05hbWUiLCJqb2luIiwiZXh0ZW5kIiwiaHRtbCIsIndyYXBwZXIiLCJjcmVhdGVGcmFnbWVudCIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImZpcnN0Q2hpbGQiLCJhcHBlbmRDaGlsZCIsImRzdCIsImFyZ3MiLCJrZXlzIiwiT2JqZWN0IiwiaiIsImFycmF5RnJvbSIsImFycmF5TGlrZSIsIkFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJwYXJzZUpTT05PYmplY3RTYWZlbHkiLCJqc29uU3RyaW5nIiwiZmFpbFNhZmUiLCJyZXN1bHQiLCJKU09OIiwiZSIsImZpbmRGcm9tUGF0aCIsInBhdGgiLCJlbCIsIndpbmRvdyIsInRyaWdnZXJFbGVtZW50RXZlbnQiLCJ0YXJnZXQiLCJldmVudE5hbWUiLCJkZXRhaWwiLCJldmVudCIsIkN1c3RvbUV2ZW50IiwiZm9yRWFjaCIsImRpc3BhdGNoRXZlbnQiLCJoYXNNb2RpZmllciIsIm1vZGlmaWVyTmFtZSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInNvbWUiLCJhZGRNb2RpZmllciIsIm1vZGlmaWVyQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlTW9kaWZpZXIiLCJtb2RpZmllcnMiLCJuZXdNb2RpZmllcnMiLCJmaWx0ZXIiLCJpdGVtIiwidXBkYXRlUGFyZW50UG9zaXRpb24iLCJfcGFyZW50VXBkYXRlZCIsInBhcmVudEVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBvc2l0aW9uIiwidG9nZ2xlQXR0cmlidXRlIiwibmFtZSIsImVuYWJsZSIsInJlbW92ZUF0dHJpYnV0ZSIsImJpbmRMaXN0ZW5lcnMiLCJsaXN0ZW5lck5hbWVzIiwiYm91bmROYW1lIiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwiYmluZCIsImVhY2giLCJvYmoiLCJmIiwidXBkYXRlUmlwcGxlIiwicmlwcGxlRWxlbWVudCIsImluc2VydEJlZm9yZSIsInJlbW92ZSIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsImlzSW50ZWdlciIsInZhbHVlIiwiaXNGaW5pdGUiLCJNYXRoIiwiZmxvb3IiLCJkZWZlciIsImRlZmVycmVkIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXZlbnQiLCJVdGlscyIsIkRldGVjdGlvbiIsIlBvaW50ZXJFdmVudCIsIkdlc3R1cmVEZXRlY3RvciIsIm9wdGlvbnMiLCJJbnN0YW5jZSIsImRlZmF1bHRzIiwiRE9DVU1FTlQiLCJIQVNfUE9JTlRFUkVWRU5UUyIsIm5hdmlnYXRvciIsInBvaW50ZXJFbmFibGVkIiwibXNQb2ludGVyRW5hYmxlZCIsIkhBU19UT1VDSEVWRU5UUyIsIklTX01PQklMRSIsInVzZXJBZ2VudCIsIk5PX01PVVNFRVZFTlRTIiwiQ0FMQ1VMQVRFX0lOVEVSVkFMIiwiRVZFTlRfVFlQRVMiLCJESVJFQ1RJT05fRE9XTiIsIkRJUkVDVElPTl9MRUZUIiwiRElSRUNUSU9OX1VQIiwiRElSRUNUSU9OX1JJR0hUIiwiUE9JTlRFUl9NT1VTRSIsIlBPSU5URVJfVE9VQ0giLCJQT0lOVEVSX1BFTiIsIkVWRU5UX1NUQVJUIiwiRVZFTlRfTU9WRSIsIkVWRU5UX0VORCIsIkVWRU5UX1JFTEVBU0UiLCJFVkVOVF9UT1VDSCIsIlJFQURZIiwicGx1Z2lucyIsImdlc3R1cmVzIiwic2V0dXAiLCJkZXRlcm1pbmVFdmVudFR5cGVzIiwiZ2VzdHVyZSIsInJlZ2lzdGVyIiwib25Ub3VjaCIsImRldGVjdCIsInV0aWxzIiwiZGVzdCIsInNyYyIsIm1lcmdlIiwiaGFzT3duUHJvcGVydHkiLCJ1bmRlZmluZWQiLCJvbiIsInR5cGUiLCJoYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpdGVyYXRvciIsImNvbnRleHQiLCJsZW4iLCJjYWxsIiwiaW5TdHIiLCJmaW5kIiwiaW5BcnJheSIsImluZGV4IiwidG9BcnJheSIsImhhc1BhcmVudCIsImdldENlbnRlciIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiY2xpZW50WCIsImNsaWVudFkiLCJtaW4iLCJtYXgiLCJ0b3VjaCIsImdldFZlbG9jaXR5IiwiZGVsdGFUaW1lIiwiZGVsdGFYIiwiZGVsdGFZIiwiYWJzIiwiZ2V0QW5nbGUiLCJ0b3VjaDEiLCJ0b3VjaDIiLCJ4IiwieSIsImF0YW4yIiwiUEkiLCJnZXREaXJlY3Rpb24iLCJnZXREaXN0YW5jZSIsInNxcnQiLCJnZXRTY2FsZSIsInN0YXJ0IiwiZW5kIiwiZ2V0Um90YXRpb24iLCJpc1ZlcnRpY2FsIiwiZGlyZWN0aW9uIiwic2V0UHJlZml4ZWRDc3MiLCJwcm9wIiwidG9nZ2xlIiwicHJlZml4ZXMiLCJ0b0NhbWVsQ2FzZSIsInAiLCJ0b2dnbGVCZWhhdmlvciIsInByb3BzIiwiZmFsc2VGbiIsInVzZXJTZWxlY3QiLCJvbnNlbGVjdHN0YXJ0IiwidXNlckRyYWciLCJvbmRyYWdzdGFydCIsInN0ciIsInMiLCJob29rIiwidHlwZXMiLCJldmVudFR5cGUiLCJzZWxmIiwib25Ub3VjaEhhbmRsZXIiLCJldiIsInNyY1R5cGUiLCJpc1BvaW50ZXIiLCJpc01vdXNlIiwidHJpZ2dlclR5cGUiLCJwcmV2ZW50TW91c2VFdmVudHMiLCJidXR0b24iLCJzaG91bGREZXRlY3QiLCJidXR0b25zIiwibWF0Y2hUeXBlIiwidXBkYXRlUG9pbnRlciIsImRvRGV0ZWN0IiwicmVzZXQiLCJ0b3VjaExpc3QiLCJnZXRUb3VjaExpc3QiLCJ0b3VjaExpc3RMZW5ndGgiLCJ0cmlnZ2VyQ2hhbmdlIiwidHJpZ2dlciIsImNoYW5nZWRMZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsInN0YXJ0ZWQiLCJldkRhdGEiLCJjb2xsZWN0RXZlbnREYXRhIiwiaWRlbnRpZmllcnMiLCJjb25jYXQiLCJpZGVudGlmaWVyIiwicG9pbnRlclR5cGUiLCJEYXRlIiwibm93Iiwic3JjRXZlbnQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wRGV0ZWN0IiwidG91Y2hsaXN0IiwicG9pbnRlcnMiLCJwb2ludGVyIiwicG9pbnRlckV2ZW50IiwicG9pbnRlcklkIiwicHQiLCJNU1BPSU5URVJfVFlQRV9NT1VTRSIsIk1TUE9JTlRFUl9UWVBFX1RPVUNIIiwiTVNQT0lOVEVSX1RZUEVfUEVOIiwicmVzZXRMaXN0IiwiZGV0ZWN0aW9uIiwic3RhcnREZXRlY3QiLCJpbnN0IiwiZXZlbnREYXRhIiwiY3VycmVudCIsInN0b3BwZWQiLCJleHRlbmRFdmVudERhdGEiLCJpbnN0T3B0aW9ucyIsInRyaWdnZXJHZXN0dXJlIiwiZW5hYmxlZCIsImxhc3RFdmVudCIsInByZXZpb3VzIiwiZ2V0Q2FsY3VsYXRlZERhdGEiLCJjZW50ZXIiLCJjdXIiLCJyZWNhbGMiLCJjYWxjRXYiLCJsYXN0Q2FsY0V2ZW50IiwiY2FsY0RhdGEiLCJsYXN0Q2FsY0RhdGEiLCJ0aW1lU3RhbXAiLCJmdXR1cmVDYWxjRXZlbnQiLCJ2ZWxvY2l0eSIsImFuZ2xlIiwidmVsb2NpdHlYIiwidmVsb2NpdHlZIiwiaW50ZXJpbUFuZ2xlIiwiaW50ZXJpbURpcmVjdGlvbiIsInN0YXJ0RXYiLCJzdGFydEV2ZW50IiwibGFzdEV2Iiwic29ydCIsImEiLCJiIiwiYmVoYXZpb3IiLCJldmVudFN0YXJ0SGFuZGxlciIsImV2ZW50SGFuZGxlcnMiLCJvbkV2ZW50Iiwib2ZmRXZlbnQiLCJzcGxpY2UiLCJ0cmlnZ2VyRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInN0YXRlIiwiZGlzcG9zZSIsImVoIiwidHJpZ2dlcmVkIiwiZHJhZ0dlc3R1cmUiLCJkcmFnTWF4VG91Y2hlcyIsImRpc3RhbmNlIiwiZHJhZ01pbkRpc3RhbmNlIiwic3RhcnRDZW50ZXIiLCJkcmFnRGlzdGFuY2VDb3JyZWN0aW9uIiwiZmFjdG9yIiwiZHJhZ0xvY2tUb0F4aXMiLCJkcmFnTG9ja01pbkRpc3RhbmNlIiwibGFzdERpcmVjdGlvbiIsImRyYWdCbG9ja1ZlcnRpY2FsIiwiZHJhZ0Jsb2NrSG9yaXpvbnRhbCIsIkRyYWciLCJHZXN0dXJlIiwicmVsZWFzZUdlc3R1cmUiLCJ0aW1lciIsImhvbGRHZXN0dXJlIiwic2V0VGltZW91dCIsImhvbGRUaW1lb3V0IiwiaG9sZFRocmVzaG9sZCIsIkhvbGQiLCJSZWxlYXNlIiwiSW5maW5pdHkiLCJTd2lwZSIsInN3aXBlR2VzdHVyZSIsInN3aXBlTWluVG91Y2hlcyIsInN3aXBlTWF4VG91Y2hlcyIsInN3aXBlVmVsb2NpdHlYIiwic3dpcGVWZWxvY2l0eVkiLCJoYXNNb3ZlZCIsInRhcEdlc3R1cmUiLCJwcmV2Iiwic2luY2VQcmV2IiwiZGlkRG91YmxlVGFwIiwidGFwTWF4RGlzdGFuY2UiLCJ0YXBNYXhUaW1lIiwiZG91YmxlVGFwSW50ZXJ2YWwiLCJkb3VibGVUYXBEaXN0YW5jZSIsInRhcEFsd2F5cyIsIlRhcCIsIlRvdWNoIiwidG91Y2hHZXN0dXJlIiwicHJldmVudE1vdXNlIiwidHJhbnNmb3JtR2VzdHVyZSIsInNjYWxlVGhyZXNob2xkIiwic2NhbGUiLCJyb3RhdGlvblRocmVzaG9sZCIsInJvdGF0aW9uIiwidHJhbnNmb3JtTWluU2NhbGUiLCJ0cmFuc2Zvcm1NaW5Sb3RhdGlvbiIsIlRyYW5zZm9ybSIsIlBsYXRmb3JtIiwiX3JlbmRlclBsYXRmb3JtIiwicGxhdGZvcm0iLCJyZWFkeVN0YXRlIiwiY29yZG92YSIsInBob25lZ2FwIiwiUGhvbmVHYXAiLCJkZXZpY2UiLCJvcGVyYSIsIkluc3RhbGxUcmlnZ2VyIiwidG9TdHJpbmciLCJIVE1MRWxlbWVudCIsImNocm9tZSIsImRvY3VtZW50TW9kZSIsInBhcnNlSW50IiwidmVyc2lvbiIsInZlciIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNXUCIsImlzSVBob25lIiwiaXNJUGFkIiwiaXNJUG9kIiwicmVhZHlNYXAiLCJXZWFrTWFwIiwicXVldWVNYXAiLCJpc0NvbnRlbnRSZWFkeSIsImhhcyIsInNldENvbnRlbnRSZWFkeSIsInNldCIsImFkZENhbGxiYWNrIiwiZm4iLCJnZXQiLCJjb25zdW1lUXVldWUiLCJjYWxsYmFja3MiLCJkZWxldGUiLCJjYWxsYmFjayIsImNvbnRlbnRSZWFkeSIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwibm90aWZpY2F0aW9uIiwiX2NyZWF0ZUFsZXJ0RGlhbG9nIiwiaW5wdXRTdHJpbmciLCJpc1Byb21wdCIsImlucHV0VHlwZSIsInBsYWNlaG9sZGVyIiwiZGVmYXVsdFZhbHVlIiwiYnV0dG9uTGFiZWxzIiwibGFiZWwiLCJwcmltYXJ5QnV0dG9uSW5kZXgiLCJfZGVzdHJveURpYWxvZyIsImRpYWxvZyIsIm9uRGlhbG9nQ2FuY2VsIiwiZGVzdHJveSIsInRpdGxlIiwibWVzc2FnZSIsIm1lc3NhZ2VIVE1MIiwibW9kaWZpZXIiLCJzdWJtaXRPbkVudGVyIiwiaW5wdXQiLCJxdWVyeVNlbGVjdG9yIiwib25rZXlwcmVzcyIsImtleUNvZGUiLCJoaWRlIiwidGhlbiIsInJlc29sdmVWYWx1ZSIsImZvb3RlciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJidXR0b25FbGVtZW50Iiwib25jbGljayIsImNhbmNlbGFibGUiLCJib2R5IiwiY29tcGlsZSIsInNob3ciLCJhdXRvZm9jdXMiLCJmb2N1cyIsIl9ub3JtYWxpemVBcmd1bWVudHMiLCJidXR0b25MYWJlbCIsImlzQXJyYXkiLCJwYXJhbSIsImFsZXJ0IiwiY29uZmlybSIsInByb21wdCIsInBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIiwib3ZlcndyaXRlIiwiX3ZhcmlhYmxlcyIsInBhcnQiLCJpbkludGVycG9sYXRpb24iLCJjdXJyZW50SW5kZXgiLCJ0b2tlbnMiLCJjaGFyQXQiLCJzdWJzdHJpbmciLCJyZSIsInZhcmlhYmxlIiwiZ2V0VmFyaWFibGUiLCJydiIsIm1hcCIsIl9yZXBsYWNlVG9rZW4iLCJleHByZXNzaW9uIiwiX3BhcnNlUGFydCIsIl9yZXBsYWNlVG9rZW5zIiwiX3BhcnNlRXhwcmVzc2lvbiIsImRlZmluZVZhcmlhYmxlIiwiZ2V0TW9iaWxlT1MiLCJnZXRJT1NEZXZpY2UiLCJpc1dlYlZpZXciLCJpbnRlcm5hbCIsImNvbmZpZyIsIm51bGxFbGVtZW50IiwiaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwiLCJhdXRvU3RhdHVzQmFyRmlsbCIsIm5vcm1hbGl6ZVBhZ2VIVE1MIiwid2FpdERPTUNvbnRlbnRMb2FkZWQiLCJvblJlYWR5Iiwic2hvdWxkRmlsbFN0YXR1c0JhciIsImlzSU9TN2Fib3ZlIiwidGVtcGxhdGVTdG9yZSIsIl9zdG9yYWdlIiwidGVtcGxhdGUiLCJ0ZW1wbGF0ZUlkIiwidGVtcGxhdGVzIiwidGV4dENvbnRlbnQiLCJnZXRUZW1wbGF0ZUhUTUxBc3luYyIsInBhZ2UiLCJjYWNoZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzIiwib25lcnJvciIsInNlbmQiLCJnZXRQYWdlSFRNTEFzeW5jIiwicGFnZXMiLCJldmFsdWF0ZSIsImdldFBhZ2UiLCJBbmltYXRvckZhY3RvcnkiLCJvcHRzIiwiX2FuaW1hdG9ycyIsImFuaW1hdG9ycyIsIl9iYXNlQ2xhc3MiLCJiYXNlQ2xhc3MiLCJfYmFzZUNsYXNzTmFtZSIsImJhc2VDbGFzc05hbWUiLCJfYW5pbWF0aW9uIiwiZGVmYXVsdEFuaW1hdGlvbiIsIl9hbmltYXRpb25PcHRpb25zIiwiZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0b3IiLCJhbmltYXRvciIsImFuaW1hdGlvbiIsIkFuaW1hdG9yIiwiYW5pbWF0aW9uT3B0cyIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJkdXJhdGlvbiIsImRlbGF5IiwiTW9kaWZpZXJVdGlsIiwibGFzdCIsIm1ha2VEaWN0IiwicmVtb3ZlZCIsInJlZHVjZSIsImFkZGVkIiwiZGljdCIsImRpZmYiLCJhZGQiLCJrbGFzcyIsInNjaGVtZSIsIm1hdGNoZXMiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsInRhcmdldEVsZW1lbnRzIiwiYXBwbHlEaWZmVG9DbGFzc0xpc3QiLCJhcHBseURpZmZUb0VsZW1lbnQiLCJMYXp5UmVwZWF0RGVsZWdhdGUiLCJ1c2VyRGVsZWdhdGUiLCJ0ZW1wbGF0ZUVsZW1lbnQiLCJfdXNlckRlbGVnYXRlIiwiRWxlbWVudCIsIl90ZW1wbGF0ZUVsZW1lbnQiLCJfcmVuZGVyIiwiaXRlbXMiLCJoZWlnaHQiLCJkb25lIiwibG9hZEl0ZW1FbGVtZW50IiwiY3JlYXRlSXRlbUNvbnRlbnQiLCJjb3VudCIsImNvdW50SXRlbXMiLCJ1cGRhdGVJdGVtQ29udGVudCIsImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCJkZXN0cm95SXRlbSIsIml0ZW1IZWlnaHQiLCJMYXp5UmVwZWF0UHJvdmlkZXIiLCJ3cmFwcGVyRWxlbWVudCIsImRlbGVnYXRlIiwiX3dyYXBwZXJFbGVtZW50IiwiX2RlbGVnYXRlIiwidGFnTmFtZSIsIl9wYWdlQ29udGVudCIsIl9maW5kUGFnZUNvbnRlbnRFbGVtZW50IiwiX3RvcFBvc2l0aW9ucyIsIl9yZW5kZXJlZEl0ZW1zIiwiX3Vua25vd25JdGVtSGVpZ2h0IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwiX29uQ2hhbmdlIiwicGFnZUNvbnRlbnQiLCJjb250ZW50IiwicmVtb3ZlQ2hpbGQiLCJfaXRlbUhlaWdodCIsIm9mZnNldEhlaWdodCIsImxhc3RWaXNpYmlsaXR5IiwidmlzaWJpbGl0eSIsInN0YXRpY0l0ZW1IZWlnaHQiLCJfcmVtb3ZlQWxsRWxlbWVudHMiLCJfY2hlY2tJdGVtSGVpZ2h0IiwiX2dldEl0ZW1zSW5WaWV3IiwiaGFzUmVuZGVyRnVuY3Rpb24iLCJfbGlzdEhlaWdodCIsImtlZXAiLCJfcmVuZGVyRWxlbWVudCIsIl9yZW1vdmVFbGVtZW50IiwidG9wIiwidXBkYXRlSXRlbSIsIl9pdGVtQ291bnQiLCJtaWRkbGUiLCJfZ2V0SXRlbUhlaWdodCIsImwiLCJvZmZzZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbm5lckhlaWdodCIsIl9jb3VudEl0ZW1zIiwiX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zIiwiX2NhbGN1bGF0ZVN0YXJ0SW5kZXgiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJjYWxsTm93IiwiYXJndW1lbnRzIiwiX2RlYm91bmNlIiwiX2JvdW5kT25DaGFuZ2UiLCJfYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCIsIl9wYXJlbnRFbGVtZW50IiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJzIiwiX2lzUG9ydHJhaXQiLCJpc1BvcnRyYWl0IiwiX29uRE9NQ29udGVudExvYWRlZCIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uUmVzaXplIiwiaW5uZXJXaWR0aCIsIl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uIiwiZW1pdCIsIm9yaWVudGF0aW9uIiwibkl0ZXIiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwidyIsImgiLCJtaXhpbiIsIl9pbml0Iiwic29mdHdhcmVLZXlib2FyZCIsIk1pY3JvRXZlbnQiLCJfdmlzaWJsZSIsIm9uU2hvdyIsIm9uSGlkZSIsImJpbmRFdmVudHMiLCJLZXlib2FyZCIsIm9uc2hvdyIsIm9uaGlkZSIsInZpc2libGUiLCJpc1Zpc2libGUiLCJub1BsdWdpbkVycm9yIiwid2FybiIsIl9kb21Db250ZW50TG9hZGVkIiwiX3JlYWR5IiwiSGFuZGxlclJlcG9zaXRvcnkiLCJkYXRhc2V0IiwiZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCIsImlkIiwiX2dlbklkIiwiX3N0b3JlIiwiRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJfaXNFbmFibGVkIiwiX2JvdW5kQ2FsbGJhY2siLCJfY2FsbGJhY2siLCJhZGRCYWNrQnV0dG9uTGlzdGVuZXIiLCJyZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIiLCJfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQiLCJfZWxlbWVudCIsInRyZWUiLCJfY2FwdHVyZVRyZWUiLCJfZmluZEhhbmRsZXJMZWFmRWxlbWVudCIsImNyZWF0ZVRyZWUiLCJhcnJheU9mIiwiY2hpbGRFbGVtZW50IiwiZGlzcGxheSIsImNoaWxkTm9kZSIsImxlZnQiLCJyaWdodCIsImxlZnRaIiwiekluZGV4IiwicmlnaHRaIiwiYXV0b1N0eWxlRW5hYmxlZCIsIm1vZGlmaWVyc01hcCIsInBsYXRmb3JtcyIsImFuZHJvaWQiLCJvbGRNb2RpZmllciIsIm5ld01vZGlmaWVyIiwidW5zaGlmdCIsImlvcyIsInVubG9ja2VkIiwicHJlcGFyZUF1dG9TdHlsZSIsImZvcmNlIiwibW9iaWxlT1MiLCJvbnNQbGF0Zm9ybSIsImdlbmVyYXRlSWQiLCJEb29yTG9jayIsIl9sb2NrTGlzdCIsIl93YWl0TGlzdCIsIl9sb2ciLCJsb2ciLCJ1bmxvY2siLCJfdW5sb2NrIiwiX3RyeVRvRnJlZVdhaXRMaXN0IiwiaXNMb2NrZWQiLCJsb2FkUGFnZSIsInBhcmFtcyIsInBhZ2VFbGVtZW50IiwidW5sb2FkUGFnZSIsIl9kZXN0cm95IiwiUGFnZUxvYWRlciIsImxvYWRlciIsInVubG9hZGVyIiwiX2xvYWRlciIsIl91bmxvYWRlciIsImRlZmF1bHRQYWdlTG9hZGVyIiwiaW5zdGFudFBhZ2VMb2FkZXIiLCJvbnMiLCJfdXRpbCIsIl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsImRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIiwiX2ludGVybmFsIiwiUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24iLCJfYW5pbWF0aW9uT3B0aW9uc1BhcnNlciIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZXIiLCJfYXV0b1N0eWxlIiwiYXV0b1N0eWxlIiwiX0Rvb3JMb2NrIiwiX2NvbnRlbnRSZWFkeSIsIl9yZWFkeUxvY2siLCJzZWxlY3QiLCJsb2NhdGlvbiIsInNlYXJjaCIsIndhaXREZXZpY2VSZWFkeSIsImlzUmVhZHkiLCJyZWFkeSIsIndhaXRVbmxvY2siLCJzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJfZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyIiwic2V0TGlzdGVuZXIiLCJkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJkaXNhYmxlIiwiZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJlbmFibGVBdXRvU3RhdHVzQmFyRmlsbCIsImRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCIsImRpc2FibGVBbmltYXRpb25zIiwiZW5hYmxlQW5pbWF0aW9ucyIsImRpc2FibGVBdXRvU3R5bGluZyIsImVuYWJsZUF1dG9TdHlsaW5nIiwiZm9yY2VQbGF0Zm9ybVN0eWxpbmciLCJuZXdQbGF0Zm9ybSIsIl9wbGF0Zm9ybVVwZGF0ZSIsInByZXBhcmUiLCJfdXBkYXRlUG9zaXRpb24iLCJfY3JlYXRlUG9wb3Zlck9yaWdpbmFsIiwiZGl2IiwicG9wb3ZlciIsImxpbmsiLCJjcmVhdGVQb3BvdmVyIiwiX2NyZWF0ZURpYWxvZ09yaWdpbmFsIiwiY3JlYXRlRGlhbG9nIiwiX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWwiLCJhbGVydERpYWxvZyIsImNyZWF0ZUFsZXJ0RGlhbG9nIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJPcmlnaW5hbCIsImVsZW1lbnRzIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJyZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyIiwiX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyIsImNvbnRlbnRFbGVtZW50IiwiY2F0Y2giLCJ1bmxvY2tEZXZpY2VSZWFkeSIsImxvY2siLCJfc3VwZXJTZWNyZXRPbnMiLCJnZXRFbGVtZW50Q2xhc3MiLCJCYXNlRWxlbWVudCIsImluaXQiLCJUZW1wbGF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJidWJibGVzIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiLCJJZkVsZW1lbnQiLCJfaXNBbGxvd2VkUGxhdGZvcm0iLCJjb25kaXRpb25hbE9yaWVudGF0aW9uIiwiY3VycmVudE9yaWVudGF0aW9uIiwiQWxlcnREaWFsb2dBbmltYXRvciIsInRpbWluZyIsIkFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIiwicnVuQWxsIiwiYW5pbWl0IiwiX21hc2siLCJxdWV1ZSIsIl9kaWFsb2ciLCJzYXZlU3R5bGUiLCJyZXN0b3JlU3R5bGUiLCJJT1NBbGVydERpYWxvZ0FuaW1hdG9yIiwiX2FuaW1hdG9yRGljdCIsIkFsZXJ0RGlhbG9nRWxlbWVudCIsIl9jb21waWxlIiwiX2Rvb3JMb2NrIiwiX2JvdW5kQ2FuY2VsIiwiX2NhbmNlbCIsIl91cGRhdGVBbmltYXRvckZhY3RvcnkiLCJfYW5pbWF0b3JGYWN0b3J5IiwibWFzayIsImNvbnRhaW5lciIsImJhY2tncm91bmRDb2xvciIsImluaXRNb2RpZmllciIsImNhbmNlbCIsInBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyIsInRyeVNob3ciLCJuZXdBbmltYXRvciIsIm9wYWNpdHkiLCJ0cnlIaWRlIiwiX3J1bm5pbmciLCJvbkRldmljZUJhY2tCdXR0b24iLCJjYWxsUGFyZW50SGFuZGxlciIsIl9iYWNrQnV0dG9uSGFuZGxlciIsIm9uTW9kaWZpZXJDaGFuZ2VkIiwiY3JlYXRlSGFuZGxlciIsIkJhY2tCdXR0b25FbGVtZW50IiwiX29wdGlvbnMiLCJfYm91bmRPbkNsaWNrIiwiX29uQ2xpY2siLCJpY29uIiwib25DbGljayIsInBvcFBhZ2UiLCJCb3R0b21Ub29sYmFyRWxlbWVudCIsIkJ1dHRvbkVsZW1lbnQiLCJfdXBkYXRlUmlwcGxlIiwiQ2Fyb3VzZWxJdGVtRWxlbWVudCIsIndpZHRoIiwiVmVydGljYWxNb2RlVHJhaXQiLCJfY3VycmVudEVsZW1lbnRTaXplIiwic2Nyb2xsIiwiX3N0eWxlIiwiX2RpbWVuc2lvbnMiLCJjZW50ZXJlZCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiX29mZnNldCIsIl9nZXRDYXJvdXNlbEl0ZW1TaXplIiwiX2dldENhcm91c2VsSXRlbUVsZW1lbnRzIiwic2l6ZUF0dHIiLCJfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIiLCJzaXplSW5mbyIsIl9kZWNvbXBvc2VTaXplU3RyaW5nIiwibnVtYmVyIiwidW5pdCIsIl91cGRhdGVEaW1lbnNpb25EYXRhIiwiX3VwZGF0ZU9mZnNldCIsIl9sYXlvdXRDYXJvdXNlbEl0ZW1zIiwiSG9yaXpvbnRhbE1vZGVUcmFpdCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiQ2Fyb3VzZWxFbGVtZW50IiwiX3Njcm9sbCIsIl9sYXN0QWN0aXZlSW5kZXgiLCJfYm91bmRPbkRyYWciLCJfb25EcmFnIiwiX2JvdW5kT25EcmFnRW5kIiwiX29uRHJhZ0VuZCIsIl9ib3VuZE9uUmVzaXplIiwiX21peGluIiwiX2lzVmVydGljYWwiLCJzZXRBY3RpdmVJbmRleCIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInJlZnJlc2giLCJfbGFzdFN0YXRlIiwiaXRlbUNvdW50IiwiZWxlbWVudFNpemUiLCJfZ2V0RWxlbWVudFNpemUiLCJyb3VuZCIsImF0dHJOYW1lIiwiaXRlbVNpemVBdHRyIiwic2l6ZSIsIl9nZXRJbml0aWFsSW5kZXgiLCJfc2Nyb2xsVG8iLCJfY2FsY3VsYXRlTWF4U2Nyb2xsIiwiX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQiLCJnZXRBY3RpdmVJbmRleCIsImNhcm91c2VsSXRlbVNpemUiLCJhdXRvU2Nyb2xsIiwiX2dlc3R1cmVEZXRlY3RvciIsIl9tdXRhdGlvbk9ic2VydmVyIiwiX3VwZGF0ZVN3aXBlYWJsZSIsIl91cGRhdGVBdXRvUmVmcmVzaCIsImRpc2Nvbm5lY3QiLCJzd2lwZWFibGUiLCJsYXN0QWN0aXZlSW5kZXgiLCJkIiwiX2lzV3JvbmdEaXJlY3Rpb24iLCJfbGFzdERyYWdFdmVudCIsIl9nZXRTY3JvbGxEZWx0YSIsIl9pc092ZXJTY3JvbGwiLCJ3YWl0Rm9yQWN0aW9uIiwiX2dldE92ZXJTY3JvbGxEaXJlY3Rpb24iLCJfc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCIsIl9zdGFydE1vbWVudHVtU2Nyb2xsIiwidHJhaXQiLCJfZ2V0U2Nyb2xsVmVsb2NpdHkiLCJzY3JvbGxEZWx0YSIsIl9ub3JtYWxpemVTY3JvbGxQb3NpdGlvbiIsIl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybSIsInBsYXkiLCJhcnIiLCJuYnJPZkl0ZW1zIiwicG9zIiwibGFzdFNjcm9sbCIsInNjcm9sbFJhdGlvIiwiYXV0b1Njcm9sbFJhdGlvIiwiaXNPdmVyc2Nyb2xsYWJsZSIsIm92ZXJzY3JvbGxhYmxlIiwibm9ybWFsaXplU2Nyb2xsIiwicmF0aW8iLCJtYXhTY3JvbGwiLCJjZWlsIiwiX3NldHVwIiwiX3NhdmVMYXN0U3RhdGUiLCJjYXJvdXNlbCIsIl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMiLCJfc2V0dXBJbml0aWFsSW5kZXgiLCJfb25EaXJlY3Rpb25DaGFuZ2UiLCJhdHRyIiwicGFyc2VGbG9hdCIsIkNvbEVsZW1lbnQiLCJfdXBkYXRlV2lkdGgiLCJ3ZWJraXRCb3hGbGV4Iiwid2Via2l0RmxleCIsIm1vekJveEZsZXgiLCJtb3pGbGV4IiwibXNGbGV4IiwiZmxleCIsIm1heFdpZHRoIiwiRGlhbG9nQW5pbWF0b3IiLCJBbmRyb2lkRGlhbG9nQW5pbWF0b3IiLCJJT1NEaWFsb2dBbmltYXRvciIsIlNsaWRlRGlhbG9nQW5pbWF0b3IiLCJEaWFsb2dFbGVtZW50IiwiRmFiRWxlbWVudCIsInRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsIkdlc3R1cmVEZXRlY3RvckVsZW1lbnQiLCJJY29uRWxlbWVudCIsIl91cGRhdGUiLCJfY2xlYW5DbGFzc0F0dHJpYnV0ZSIsIl9idWlsZENsYXNzQW5kU3R5bGUiLCJfZ2V0QXR0cmlidXRlIiwicGFydHMiLCJkZWYiLCJtZCIsImljb25OYW1lIiwicmVtb3ZlUHJvcGVydHkiLCJmb250U2l6ZSIsIkxhenlSZXBlYXRFbGVtZW50IiwiX2xhenlSZXBlYXRQcm92aWRlciIsIkxpc3RIZWFkZXJFbGVtZW50IiwiTGlzdEl0ZW1FbGVtZW50IiwiX29uVG91Y2giLCJfb25SZWxlYXNlIiwiX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIiwidGFwcGVkIiwiX3Nob3VsZExvY2tPbkRyYWciLCJ0cmFuc2l0aW9uIiwiX3RyYW5zaXRpb24iLCJ3ZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIl90YXBwYWJsZSIsIl90YXBCYWNrZ3JvdW5kQ29sb3IiLCJib3hTaGFkb3ciLCJMaXN0RWxlbWVudCIsIklOUFVUX0FUVFJJQlVURVMiLCJJbnB1dEVsZW1lbnQiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJfYm91bmRPbklucHV0IiwiX29uSW5wdXQiLCJfYm91bmRPbkZvY3VzaW4iLCJfb25Gb2N1c2luIiwiX2JvdW5kRGVsZWdhdGVFdmVudCIsIl9kZWxlZ2F0ZUV2ZW50IiwiaGVscGVyIiwiX2lucHV0IiwiX2hlbHBlciIsIl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMiLCJfdXBkYXRlTGFiZWwiLCJfdXBkYXRlTGFiZWxDbGFzcyIsImNoZWNrZWQiLCJfYm91bmRPbkZvY3Vzb3V0IiwiaW5uZXJUZXh0IiwiX3NldExhYmVsIiwidmFsIiwiTW9kYWxBbmltYXRvciIsIm1vZGFsIiwiRmFkZU1vZGFsQW5pbWF0b3IiLCJNb2RhbEVsZW1lbnQiLCJOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJlbnRlclBhZ2UiLCJsZWF2ZVBhZ2UiLCJwcm9wZXJ0aWVzIiwiZXh0ZW5kZWRBbmltYXRvciIsIklPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiYmFja2dyb3VuZE1hc2siLCJ0b29sYmFyIiwiX2dldFRvb2xiYXJFbGVtZW50IiwiX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50IiwiX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCIsImV4Y2x1ZGVCYWNrQnV0dG9uIiwib3RoZXIiLCJfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCIsIl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50IiwiX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50IiwiX2dldENvbnRlbnRFbGVtZW50IiwiX2dldEJhY2tncm91bmRFbGVtZW50IiwiX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50IiwiYm90aFBhZ2VIYXNUb29sYmFyIiwiX2NhbkFuaW1hdGVUb29sYmFyIiwibm9NYXRlcmlhbFRvb2xiYXIiLCJkZWNvbXBvc2l0aW9uIiwicGFnZVJlY3QiLCJiYWNrQnV0dG9uTGFiZWwiLCJsYWJlbFJlY3QiLCJiYWNrQnV0dG9uSWNvbiIsIm5leHRTaWJsaW5nIiwiZW50ZXJQYWdlRGVjb21wb3NpdGlvbiIsIl9kZWNvbXBvc2UiLCJsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uIiwiZGVsdGEiLCJfY2FsY3VsYXRlRGVsdGEiLCJtYXNrQ2xlYXIiLCJzaG91bGRBbmltYXRlVG9vbGJhciIsIl9zaG91bGRBbmltYXRlVG9vbGJhciIsImVudGVyUGFnZVRvb2xiYXJIZWlnaHQiLCJib3R0b21Ub29sYmFyIiwiYmFja2dyb3VuZCIsInRvb2xiYXJDZW50ZXIiLCJmaW5pc2giLCJJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciIsIk1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJibGFja01hc2tPcGFjaXR5IiwiTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciIsInJld3JpdGFibGVzIiwibmF2aWdhdG9yRWxlbWVudCIsIk5hdmlnYXRvckVsZW1lbnQiLCJfaXNSdW5uaW5nIiwiX3BhZ2VMb2FkZXIiLCJfcGFnZSIsIl9vbkRldmljZUJhY2tCdXR0b24iLCJfZ2V0UGFnZVRhcmdldCIsInB1c2hQYWdlIiwidG9wUGFnZSIsIl9zaG93IiwiX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbiIsIl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMiLCJwb3BVcGRhdGUiLCJ1bmxvYWQiLCJfcG9wUGFnZSIsIm9sZFBhZ2UiLCJwdXNoZWRPcHRpb25zIiwiZGF0YSIsImxvYWQiLCJ1cGRhdGUiLCJfZW1pdFByZVBvcEV2ZW50IiwidXBkYXRlQmFja0J1dHRvbiIsIl9oaWRlIiwicG9wIiwiX3ZlcmlmeVBhZ2VFbGVtZW50IiwicGFnZUhUTUwiLCJfcHVzaFBhZ2UiLCJfZW1pdFByZVB1c2hFdmVudCIsInBhZ2VMZW5ndGgiLCJyZXNvbHZlZFZhbHVlIiwiX25vcm1hbGl6ZUluZGV4IiwiX2xhc3RJbmRleE9mUGFnZSIsInBhZ2VOYW1lIiwiaXNDYW5jZWxlZCIsIl9lbWl0UHJlRXZlbnQiLCJ0ZW1wbGF0ZUhUTUwiLCJwYWdlTG9hZGVyIiwibiIsIlRvb2xiYXJFbGVtZW50IiwiX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMiLCJub2RlVHlwZSIsIl9lbnN1cmVUb29sYmFyRWxlbWVudCIsIm51bGxUb29sYmFyRWxlbWVudCIsIlBhZ2VFbGVtZW50IiwiX2lzU2hvd24iLCJfY29udGVudEVsZW1lbnQiLCJfaXNNdXRlZCIsIl9za2lwSW5pdCIsIl90cnlUb0ZpbGxTdGF0dXNCYXIiLCJiYWNrQnV0dG9uIiwiZmlsbGVkIiwiX2hhc0FQYWdlQ29udHJvbENoaWxkIiwib3ZlckxpbWl0Iiwic2Nyb2xsVG9wIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiX2luZmluaXRlU2Nyb2xsTGltaXQiLCJfb25JbmZpbml0ZVNjcm9sbCIsIl9sb2FkaW5nQ29udGVudCIsIm9uSW5maW5pdGVTY3JvbGwiLCJfZWxlbWVudFNob3VsZEJlTW92ZWQiLCJwcmV2Tm9kZSIsImZpeGVkRWxlbWVudHMiLCJfYm91bmRPblNjcm9sbCIsIl9vblNjcm9sbCIsIlBvcG92ZXJBbmltYXRvciIsImZyb20iLCJ0byIsInJlc3RvcmUiLCJhbmltYXRpb25zIiwiX2FuaW1hdGUiLCJmYWRlIiwiTURGYWRlUG9wb3ZlckFuaW1hdG9yIiwiX2FuaW1hdGVBbGwiLCJpbiIsIm91dCIsIklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IiLCJ0ZW1wbGF0ZVNvdXJjZSIsInBvc2l0aW9ucyIsIlBvcG92ZXJFbGVtZW50IiwiX2luaXRBbmltYXRvckZhY3RvcnkiLCJmYWN0b3J5IiwiX2FuaW1hdG9yIiwicmFkaXVzIiwiX3JhZGl1cyIsIl9jb250ZW50IiwibWFyZ2luIiwiX21hcmdpbiIsImlzTUQiLCJjb3ZlciIsImJvdHRvbSIsIl9jYWxjdWxhdGVEaXJlY3Rpb25zIiwidmVydGljYWwiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwiX3BvcG92ZXIiLCJzaXplcyIsIl9hcnJvdyIsIl9zZXRUcmFuc2Zvcm1PcmlnaW4iLCJjYWxjIiwibyIsIl9jdXJyZW50VGFyZ2V0IiwiX3Bvc2l0aW9uUG9wb3ZlciIsImhhc0RlZmF1bHRDb250YWluZXIiLCJhcnJvdyIsImNsb25lTm9kZSIsImFjdGlvbnMiLCJiZWZvcmUiLCJhZnRlciIsIl9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyIsImNhbmNlbGVkIiwiX2V4ZWN1dGVBY3Rpb24iLCJfY2xlYXJTdHlsZXMiLCJfcmVzZXRCYWNrQnV0dG9uSGFuZGxlciIsIlByb2dyZXNzQmFyRWxlbWVudCIsIl9pc0NvbXBpbGVkIiwiX3RlbXBsYXRlIiwiX3ByaW1hcnkiLCJfc2Vjb25kYXJ5IiwiX3VwZGF0ZURldGVybWluYXRlIiwiX3VwZGF0ZVZhbHVlIiwiYmFyRWxlbWVudCIsIlByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IiwicGVyIiwic3ZnIiwiU1RBVEVfSU5JVElBTCIsIlNUQVRFX1BSRUFDVElPTiIsIlNUQVRFX0FDVElPTiIsInJlbW92ZVRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsIldlYmtpdFRyYW5zaXRpb24iLCJQdWxsSG9va0VsZW1lbnQiLCJfYm91bmRPbkRyYWdTdGFydCIsIl9vbkRyYWdTdGFydCIsIl9zZXRTdGF0ZSIsImxpbmVIZWlnaHQiLCJtYXJnaW5Ub3AiLCJfcGFnZUVsZW1lbnQiLCJkaXNhYmxlZCIsIl9zdGFydFNjcm9sbCIsIl9jdXJyZW50VHJhbnNsYXRpb24iLCJfZ2V0Q3VycmVudFNjcm9sbCIsIl90cmFuc2l0aW9uRHJhZ0xlbmd0aCIsIl90aHJlc2hvbGRIZWlnaHRFbmFibGVkIiwidGhyZXNob2xkSGVpZ2h0IiwiX2ZpbmlzaCIsIl90cmFuc2xhdGVUbyIsImFuaW1hdGUiLCJvbkFjdGlvbiIsInRoIiwibm9FdmVudCIsImxhc3RTdGF0ZSIsIl9nZXRTdGF0ZSIsIl9pc0NvbnRlbnRGaXhlZCIsIl9nZXRTY3JvbGxhYmxlRWxlbWVudCIsIl9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtIiwiX2RyYWdMb2NrRGlzYWJsZWQiLCJfZGVzdHJveUV2ZW50TGlzdGVuZXJzIiwiX2NyZWF0ZUV2ZW50TGlzdGVuZXJzIiwiX3NldFN0eWxlIiwiQW5pbWF0b3JDU1MiLCJmaW5hbCIsImdldFRpbWUiLCJpbml0aWFsIiwibmV4dCIsInVwZGF0ZVN0eWxlcyIsImNsZWFyVGltZW91dCIsImsiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJzdG9wTmV4dCIsImNiIiwibmV3RHVyYXRpb24iLCJwYXNzZWQiLCJyZW1haW5pbmciLCJzcGVlZFVwVGltZSIsInN0b3AiLCJtaWxsaXNlY29uZHMiLCJzcGVlZCIsInYiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJfb25TdG9wQW5pbWF0aW9ucyIsIl9xdWV1ZSIsIl9pbmRleCIsInN0b3BBbmltYXRpb25zIiwiUmlwcGxlRWxlbWVudCIsIl93YXZlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9iYWNrZ3JvdW5kIiwiciIsIl9jZW50ZXIiLCJfbWluUiIsIl9jYWxjdWxhdGVDb29yZHMiLCJzdG9wQWxsIiwiY29tcHV0ZWRTdHlsZSIsIl91cGRhdGVQYXJlbnQiLCJfcmlwcGxlQW5pbWF0aW9uIiwiX2hvbGRpbmciLCJfYm91bmRPblJlbGVhc2UiLCJfb25UYXAiLCJfcGFyZW50Tm9kZSIsIl9ib3VuZE9uVGFwIiwiX2JvdW5kT25Ib2xkIiwiX29uSG9sZCIsInBuIiwiUm93RWxlbWVudCIsIlNwZWVkRGlhbEl0ZW1FbGVtZW50Iiwic3R5bGVyIiwiY3NzIiwic3R5bGVzIiwiX3ByZWZpeCIsInByZWZpeCIsIk9MaW5rIiwic3Vic3RyIiwiY2xlYXIiLCJfY2xlYXIiLCJTcGVlZERpYWxFbGVtZW50IiwiX3Nob3duIiwiX2l0ZW1TaG93biIsIl91cGRhdGVEaXJlY3Rpb24iLCJ0b2dnbGVJdGVtcyIsImlubGluZSIsImZhYiIsImhpZGVJdGVtcyIsImlzT3BlbiIsInNob3dJdGVtcyIsIlNwbGl0dGVyQ29udGVudEVsZW1lbnQiLCJvbGRDb250ZW50IiwiU3BsaXR0ZXJNYXNrRWxlbWVudCIsIl9zaWRlcyIsInNpZGUiLCJjbG9zZSIsIlNwbGl0dGVyQW5pbWF0b3IiLCJ1cGRhdGVPcHRpb25zIiwiX3RpbWluZyIsIl9kdXJhdGlvbiIsIl9kZWxheSIsInNpZGVFbGVtZW50Iiwic3BsaXR0ZXIiLCJfc2lkZSIsIm1pbnVzIiwiU3BsaXR0ZXJFbGVtZW50IiwiX2xheW91dCIsIm1vZGUiLCJfd2lkdGgiLCJfYm91bmRPbk1vZGVDaGFuZ2UiLCJfb25Nb2RlQ2hhbmdlIiwiX2dldFNpZGUiLCJTUExJVF9NT0RFIiwiQ09MTEFQU0VfTU9ERSIsIkNMT1NFRF9TVEFURSIsIk9QRU5fU1RBVEUiLCJDSEFOR0lOR19TVEFURSIsIldBVENIRURfQVRUUklCVVRFUyIsInNwbGl0dGVyU2lkZUVsZW1lbnQiLCJDb2xsYXBzZURldGVjdGlvbiIsImNoYW5nZVRhcmdldCIsIl90YXJnZXQiLCJfb3JpZW50YXRpb24iLCJhY3RpdmF0ZSIsIl91cGRhdGVNb2RlIiwiX21hdGNoIiwiX3F1ZXJ5UmVzdWx0IiwibWF0Y2hNZWRpYSIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJ3aWR0aFRvUHgiLCJweCIsIm9mZnNldFdpZHRoIiwiQ29sbGFwc2VNb2RlIiwiX2FjdGl2ZSIsIl9zdGF0ZSIsIl9sb2NrIiwiX2lzT3Blbk90aGVyU2lkZU1lbnUiLCJfaWdub3JlRHJhZyIsInNjcm9sbGluZyIsImFyZWEiLCJfc3dpcGVUYXJnZXRXaWR0aCIsIl9zdGFydERpc3RhbmNlIiwiX2Rpc3RhbmNlIiwidHJhbnNsYXRlIiwic2hvdWxkT3BlbiIsIl90aHJlc2hvbGQiLCJleGVjdXRlQWN0aW9uIiwibGF5b3V0IiwiRklOQUxfU1RBVEUiLCJfZW1pdEV2ZW50Iiwid2l0aG91dEFuaW1hdGlvbiIsIlNwbGl0dGVyU2lkZUVsZW1lbnQiLCJfY29sbGFwc2VNb2RlIiwiX2NvbGxhcHNlRGV0ZWN0aW9uIiwiX2JvdW5kSGFuZGxlR2VzdHVyZSIsImhhbmRsZUdlc3R1cmUiLCJfd2F0Y2hlZEF0dHJpYnV0ZXMiLCJfbW9kZSIsInRocmVzaG9sZCIsImxvY2F0aW9ucyIsIlN3aXRjaEVsZW1lbnQiLCJfY2hlY2tlZCIsIl9kaXNhYmxlZCIsIl9jaGVja2JveCIsIl9oYW5kbGUiLCJjbGljayIsImNoZWNrYm94IiwiX2xvY2F0aW9ucyIsIl9zdGFydFgiLCJfZ2V0UG9zaXRpb24iLCJwcmV2aW91c1ZhbHVlIiwiX2lzTWF0ZXJpYWwiLCJUYWJiYXJBbmltYXRvciIsImVudGVyUGFnZUluZGV4IiwibGVhdmVQYWdlSW5kZXgiLCJUYWJiYXJOb25lQW5pbWF0b3IiLCJlbnRlckluZGV4IiwibGVhdmVJbmRleCIsIlRhYmJhckZhZGVBbmltYXRvciIsIlRhYmJhclNsaWRlQW5pbWF0b3IiLCJzZ24iLCJ0YWJiYXJFbGVtZW50IiwiVGFiYmFyRWxlbWVudCIsIl90YWJiYXJJZCIsImFjdGl2ZUluZGV4IiwidGFiYmFyIiwiX3RhYmJhckVsZW1lbnQiLCJiYXIiLCJfdG9wIiwidGFiIiwiVGFiRWxlbWVudCIsIl9sb2FkUGFnZSIsIl9sb2FkUGFnZURPTUFzeW5jIiwiZ2V0QWN0aXZlVGFiSW5kZXgiLCJfc3dpdGNoUGFnZSIsIl9vbGRQYWdlRWxlbWVudCIsIm9sZFBhZ2VFbGVtZW50Iiwic2VsZWN0ZWRUYWJJbmRleCIsInByZXZpb3VzVGFiSW5kZXgiLCJwcmV2aW91c1RhYiIsIl9nZXRBY3RpdmVUYWJFbGVtZW50Iiwic2VsZWN0ZWRUYWIiLCJfZ2V0VGFiRWxlbWVudCIsInByZXZpb3VzUGFnZUVsZW1lbnQiLCJfZ2V0Q3VycmVudFBhZ2VFbGVtZW50Iiwic2V0SW5hY3RpdmUiLCJzZXRBY3RpdmUiLCJfbG9hZFBhZ2VFbGVtZW50IiwiX2dldFRhYmJhckVsZW1lbnQiLCJ0YWJzIiwiaXNBY3RpdmUiLCJjdXJyZW50UGFnZUVsZW1lbnQiLCJkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSIsImhhc0lucHV0IiwiaGFzQnV0dG9uIiwiX3RlbXBsYXRlTG9hZGVkIiwiaGFzQ2hpbGRyZW4iLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiX2hhc0RlZmF1bHRUZW1wbGF0ZSIsIl91cGRhdGVEZWZhdWx0VGVtcGxhdGUiLCJiYWRnZSIsImljb25FbGVtZW50IiwiZ2V0SWNvbkVsZW1lbnQiLCJnZXRMYWJlbEVsZW1lbnQiLCJnZXRCYWRnZUVsZW1lbnQiLCJfZmluZFRhYmJhckVsZW1lbnQiLCJzZXRBY3RpdmVUYWIiLCJfZmluZFRhYkluZGV4IiwicmFkaW8iLCJfbG9hZGVkUGFnZSIsIl9sb2FkaW5nUGFnZSIsIl9lbnN1cmVFbGVtZW50UG9zaXRpb24iLCJoYXNMb2FkZWQiLCJUb29sYmFyQnV0dG9uRWxlbWVudCIsIlJhbmdlRWxlbWVudCIsIl9sZWZ0IiwiX3JhdGlvIiwiX29uRHJhZ3N0YXJ0IiwiZmFzdENsaWNrIiwiRmFzdENsaWNrIiwiYXR0YWNoIiwiYXBwIiwiZXhpdEFwcCIsIlZpZXdwb3J0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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SUFBMUIsQ0FBaEI7Q0FESixFQUVHLEtBRkg7OztBQUtBalksT0FBTzBHLGdCQUFQLENBQXdCLGtCQUF4QixFQUE0QyxZQUFNO1FBQzVDc2lCLDJCQUFKLENBQWdDbG5CLE1BQWhDO1FBQ0lzb0IsK0JBQUosR0FBc0N0QixNQUFJRSwyQkFBSixDQUFnQ3NHLGFBQWhDLENBQThDdHZCLE9BQU8zQyxRQUFQLENBQWdCNGEsSUFBOUQsRUFBb0UsWUFBTTtjQUNwR2k5QixHQUFWLENBQWNDLE9BQWQ7R0FEb0MsQ0FBdEM7V0FHU2w5QixJQUFULENBQWNzYixnQkFBZCxHQUFpQyxJQUFJekssTUFBSWpsQixlQUFSLENBQXdCeEcsU0FBUzRhLElBQWpDLENBQWpDO0NBTEYsRUFNRyxLQU5IOzs7QUFTQTZRLE1BQUlrQixLQUFKLENBQVUsWUFBVztRQUNma0MseUJBQUo7Q0FERjs7O0FBS0EsSUFBSWtwQixRQUFKLEdBQWV6dkMsS0FBZixHQUVBIiwiZmlsZSI6Im9uc2VudWkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpZiAoIXdpbmRvdy5DdXN0b21FdmVudCkge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEN1c3RvbUV2ZW50O1xuXG4gICAgQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG4gICAgICB2YXIgZXZ0O1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9O1xuXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcblxuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICB9KSgpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuMjJcbmlmICh0eXBlb2YgV2Vha01hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcbiAgICB9O1xuICAgIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSkgZW50cnlbMV0gPSB2YWx1ZTsgZWxzZSBkZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICByZXR1cm4gKGVudHJ5ID0ga2V5W3RoaXMubmFtZV0pICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcbiAgfSkoKTtcbn1cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBpZiAoZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNldEltbWVkaWF0ZTtcbiAgaWYgKC9UcmlkZW50fEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgIHZhciBzZW50aW5lbCA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgXCIqXCIpO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICAgIHNjaGVkdWxlZE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUoZGlzcGF0Y2hDYWxsYmFja3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICAgIHJldHVybiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKSB8fCBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcbiAgICB9KTtcbiAgICB2YXIgYW55Tm9uRW1wdHkgPSBmYWxzZTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHF1ZXVlID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcik7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFueU5vbkVtcHR5KSBkaXNwYXRjaENhbGxiYWNrcygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmV0dXJuO1xuICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBub2RlID0gdGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAocmVnaXN0cmF0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZ2lzdHJhdGlvbi5vcHRpb25zO1xuICAgICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQgJiYgIW9wdGlvbnMuc3VidHJlZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChyZWNvcmQpIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuICBKc011dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICAgIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fCBvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KHRhcmdldCwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb247XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IG5ldyBSZWdpc3RyYXRpb24odGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIH0sXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlNdXRhdGlvblJlY29yZChvcmlnaW5hbCkge1xuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcbiAgICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gb3JpZ2luYWwucmVtb3ZlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcbiAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIHZhciBjdXJyZW50UmVjb3JkLCByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCBuZXdSZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlICYmIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24obGFzdFJlY29yZCkpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgfVxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZWNvcmRUb1JlcGxhY2VMYXN0ID0gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIHJlY29yZCk7XG4gICAgICAgIGlmIChyZWNvcmRUb1JlcGxhY2VMYXN0KSB7XG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgIGNhc2UgXCJET01BdHRyTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hhcmFjdGVyRGF0YVwiLCB0YXJnZXQpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZVJlbW92ZWRcIjpcbiAgICAgICAgdGhpcy5hZGRUcmFuc2llbnRPYnNlcnZlcihlLnRhcmdldCk7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZUluc2VydGVkXCI6XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcIkRPTU5vZGVJbnNlcnRlZFwiKSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBjaGFuZ2VkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hpbGRMaXN0XCIsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICByZWNvcmQuYWRkZWROb2RlcyA9IGFkZGVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29yZC5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUmVjb3JkcygpO1xuICAgIH1cbiAgfTtcbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikge1xuICAgIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICAgIEpzTXV0YXRpb25PYnNlcnZlci5faXNQb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxufSkoc2VsZik7IiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuXG4vKipcbiAqIE1pbmltYWwgYW5pbWF0aW9uIGxpYnJhcnkgZm9yIG1hbmFnaW5nIGNzcyB0cmFuc2l0aW9uIG9uIG1vYmlsZSBicm93c2Vycy5cbiAqL1xud2luZG93LmFuaW1pdCA9IChmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRJTUVPVVRfUkFUSU8gPSAxLjQ7XG5cbiAgdmFyIHV0aWwgPSB7XG4gIH07XG5cbiAgLy8gY2FwaXRhbGl6ZSBzdHJpbmdcbiAgdXRpbC5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfTtcblxuICAvKipcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm9wZXJ0eVxuICAqIEBwYXJhbSB7RmxvYXR9IHBhcmFtcy5kdXJhdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGltaW5nXG4gICovXG4gIHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBwYXJhbXMucHJvcGVydHkgPSBwYXJhbXMucHJvcGVydHkgfHwgJ2FsbCc7XG4gICAgcGFyYW1zLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDAuNDtcbiAgICBwYXJhbXMudGltaW5nID0gcGFyYW1zLnRpbWluZyB8fCAnbGluZWFyJztcblxuICAgIHZhciBwcm9wcyA9IHBhcmFtcy5wcm9wZXJ0eS5zcGxpdCgvICsvKTtcblxuICAgIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnICcgKyBwYXJhbXMuZHVyYXRpb24gKyAncyAnICsgcGFyYW1zLnRpbWluZztcbiAgICB9KS5qb2luKCcsICcpO1xuICB9O1xuXG4gIC8qKlxuICAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxuICAqL1xuICB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChlbGVtZW50ID09IGV2ZW50LnRhcmdldCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXJzO1xuICB9O1xuXG4gIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoJ29udHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgICByZXR1cm4gWyd0cmFuc2l0aW9uZW5kJ107XG4gICAgfVxuXG4gICAgaWYgKCdvbndlYmtpdHRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIFsnd2Via2l0VHJhbnNpdGlvbkVuZCddO1xuICAgIH1cblxuICAgIGlmICh1dGlsLnZlbmRvclByZWZpeCA9PT0gJ3dlYmtpdCcgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdvJyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21veicgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtcycpIHtcbiAgICAgIHJldHVybiBbdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9KSgpO1xuXG4gIHV0aWwuX2Nzc1Byb3BlcnR5RGljdCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gICAgdmFyIGRpY3QgPSB7fTtcbiAgICB2YXIgYSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB6ID0gJ3onLmNoYXJDb2RlQXQoMCk7XG5cbiAgICB2YXIgdXBwZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gcy5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgdmFyIGtleSA9IHN0eWxlc1tpXVxuICAgICAgICAucmVwbGFjZSgvXltcXC1dKy8sICcnKVxuICAgICAgICAucmVwbGFjZSgvW1xcLV1bYS16XS9nLCB1cHBlcilcbiAgICAgICAgLnJlcGxhY2UoL15tb3ovLCAnTW96Jyk7XG5cbiAgICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2Nzc1RleHQnICYmIGtleSAhPT0gJ3BhcmVudFRleHQnKSB7XG4gICAgICAgICAgZGljdFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9KSgpO1xuXG4gIHV0aWwuaGFzQ3NzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gdXRpbC5fY3NzUHJvcGVydHlEaWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXG4gICAqL1xuICB1dGlsLnZlbmRvclByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXG4gICAgcHJlID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmNhbGwoc3R5bGVzKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICAgIClbMV07XG4gICAgcmV0dXJuIHByZTtcbiAgfSkoKTtcblxuICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYXRjaEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdXRpbC5iYXRjaEltbWVkaWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICAgIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgcmV0dXJuIHV0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9KSgpO1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHZhciBBbmltaXQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFuaW1pdCkpIHtcbiAgICAgIHJldHVybiBuZXcgQW5pbWl0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBbZWxlbWVudF07XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvciBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZSA9IFtdO1xuICAgIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xuICB9O1xuXG4gIEFuaW1pdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICAgKi9cbiAgICBlbGVtZW50czogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSlcbiAgICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y3NzOiB7Y29sb3I6ICdyZWQnfSwgZHVyYXRpb246IDAuMn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy50cmFuc2l0aW9uUXVldWU7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uICYmIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5jc3MgPSB0cmFuc2l0aW9uO1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xuICAgICAgICAgICAgY3NzOiB0cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pIHtcbiAgICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdH0gc2Vjb25kc1xuICAgICAqL1xuICAgIHdhaXQ6IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgKiBzZWNvbmRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGVsZW1lbnQncyBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxuICAgICAqL1xuICAgIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuZHVyYXRpb25cIiBpcyByZXF1aXJlZCB3aGVuIFwib3B0aW9ucy50cmFuc2l0aW9uXCIgaXMgZW5hYmxlZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lO1xuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gb3B0aW9ucy50cmFuc2l0aW9uIHx8ICgnYWxsICcgKyBvcHRpb25zLmR1cmF0aW9uICsgJ3MgJyArIChvcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJykpO1xuXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICAgIHZhciBjbGVhclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICcnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGFkZCBcInRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyXG4gICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gZm9yIGZhaWwgc2FmZS5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9LCBvcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU8pO1xuXG4gICAgICAgICAgLy8gdHJhbnNpdGlvbiBhbmQgc3R5bGUgc2V0dGluZ3NcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cbiAgICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoIWNzcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgICAgICBpZiAoY3NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSB0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIC8vIENsZWFyIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNldHRpbmdzLlxuICAgICAgICBzZWxmLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICdub25lJztcblxuICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuYW1lID0gJyc7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGVxdWV1ZVRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCB0cmFuc2l0aW9uIGV4aXN0cy4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuX2N1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGYuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB0d2ljZS4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuaW1pdH0gYXJndW1lbnRzXG4gICAqL1xuICBBbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3VtZW50c1tpXS5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvcGVydHldXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gICAqL1xuICBBbmltaXQuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5kdXJhdGlvbiB8fCAwO1xuICAgIHRoaXMub3B0aW9ucy50aW1pbmcgPSB0aGlzLm9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMub3B0aW9ucy5jc3MgPSB0aGlzLm9wdGlvbnMuY3NzIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5wcm9wZXJ0eSA9IHRoaXMub3B0aW9ucy5wcm9wZXJ0eSB8fCAnYWxsJztcbiAgfTtcblxuICBBbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmNzcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5jc3MgaXMgcmVxdWlyZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLm9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTztcbiAgICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gJyc7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlKGVsZW1lbnRzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1tuYW1lXTtcblxuICAgICAgICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJlZml4ZWQgPSB1dGlsLnZlbmRvclByZWZpeCArIHV0aWwuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xuXG5cbiAgcmV0dXJuIEFuaW1pdDtcbn0pKCk7XG4iLCIvKlxyXG4gKiBjaGlsZE5vZGUucmVtb3ZlIG1ldGhvZCBwb2x5ZmlsbCBmb3IgSUUuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DaGlsZE5vZGUvcmVtb3ZlXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdGlmICghKCdyZW1vdmUnIGluIEVsZW1lbnQucHJvdG90eXBlKSkge1xyXG5cdCAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0ICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuXHQgICAgXHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblx0fVxyXG59KSgpO1xyXG4iLCIvKlxyXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cclxuICogMS4xLjIwMTUwMzEyXHJcbiAqXHJcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cclxuICogTGljZW5zZTogRGVkaWNhdGVkIHRvIHRoZSBwdWJsaWMgZG9tYWluLlxyXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxyXG4gKi9cclxuXHJcbi8qZ2xvYmFsIHNlbGYsIGRvY3VtZW50LCBET01FeGNlcHRpb24gKi9cclxuXHJcbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvY2xhc3NMaXN0LmpzICovXHJcblxyXG5pZiAoXCJkb2N1bWVudFwiIGluIHNlbGYpIHtcclxuXHJcbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcclxuLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XHJcbmlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikpXHJcbiAgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZ1wiKSkpIHtcclxuXHJcbihmdW5jdGlvbiAodmlldykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcclxuXHJcbnZhclxyXG4gICAgY2xhc3NMaXN0UHJvcCA9IFwiY2xhc3NMaXN0XCJcclxuICAsIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCJcclxuICAsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXHJcbiAgLCBvYmpDdHIgPSBPYmplY3RcclxuICAsIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xyXG4gIH1cclxuICAsIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHZhclxyXG4gICAgICAgIGkgPSAwXHJcbiAgICAgICwgbGVuID0gdGhpcy5sZW5ndGhcclxuICAgIDtcclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbiAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXHJcbiAgLCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XHJcbiAgICB0aGlzLm5hbWUgPSB0eXBlO1xyXG4gICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICB9XHJcbiAgLCBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiAoY2xhc3NMaXN0LCB0b2tlbikge1xyXG4gICAgaWYgKHRva2VuID09PSBcIlwiKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeChcclxuICAgICAgICAgIFwiU1lOVEFYX0VSUlwiXHJcbiAgICAgICAgLCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4KFxyXG4gICAgICAgICAgXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIlxyXG4gICAgICAgICwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcclxuICB9XHJcbiAgLCBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyXHJcbiAgICAgICAgdHJpbW1lZENsYXNzZXMgPSBzdHJUcmltLmNhbGwoZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKVxyXG4gICAgICAsIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXVxyXG4gICAgICAsIGkgPSAwXHJcbiAgICAgICwgbGVuID0gY2xhc3Nlcy5sZW5ndGhcclxuICAgIDtcclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgdGhpcy5wdXNoKGNsYXNzZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMudG9TdHJpbmcoKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuICAsIGNsYXNzTGlzdFByb3RvID0gQ2xhc3NMaXN0W3Byb3RvUHJvcF0gPSBbXVxyXG4gICwgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XHJcbiAgfVxyXG47XHJcbi8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcclxuLy8gb24gbm9uLURPTUV4Y2VwdGlvbnMuIEVycm9yJ3MgdG9TdHJpbmcoKSBpcyBzdWZmaWNpZW50IGhlcmUuXHJcbkRPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xyXG5jbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcclxuICByZXR1cm4gdGhpc1tpXSB8fCBudWxsO1xyXG59O1xyXG5jbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gIHRva2VuICs9IFwiXCI7XHJcbiAgcmV0dXJuIGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgIT09IC0xO1xyXG59O1xyXG5jbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyXHJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xyXG4gICAgLCBpID0gMFxyXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxyXG4gICAgLCB0b2tlblxyXG4gICAgLCB1cGRhdGVkID0gZmFsc2VcclxuICA7XHJcbiAgZG8ge1xyXG4gICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xyXG4gICAgaWYgKGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgPT09IC0xKSB7XHJcbiAgICAgIHRoaXMucHVzaCh0b2tlbik7XHJcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoKytpIDwgbCk7XHJcblxyXG4gIGlmICh1cGRhdGVkKSB7XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXJcclxuICAgICAgdG9rZW5zID0gYXJndW1lbnRzXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXHJcbiAgICAsIHRva2VuXHJcbiAgICAsIHVwZGF0ZWQgPSBmYWxzZVxyXG4gICAgLCBpbmRleFxyXG4gIDtcclxuICBkbyB7XHJcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XHJcbiAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XHJcbiAgICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKCsraSA8IGwpO1xyXG5cclxuICBpZiAodXBkYXRlZCkge1xyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XHJcbiAgdG9rZW4gKz0gXCJcIjtcclxuXHJcbiAgdmFyXHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pXHJcbiAgICAsIG1ldGhvZCA9IHJlc3VsdCA/XHJcbiAgICAgIGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCJcclxuICAgIDpcclxuICAgICAgZm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcclxuICA7XHJcblxyXG4gIGlmIChtZXRob2QpIHtcclxuICAgIHRoaXNbbWV0aG9kXSh0b2tlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9yY2UgPT09IHRydWUgfHwgZm9yY2UgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZm9yY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAhcmVzdWx0O1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuam9pbihcIiBcIik7XHJcbn07XHJcblxyXG5pZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XHJcbiAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xyXG4gICAgICBnZXQ6IGNsYXNzTGlzdEdldHRlclxyXG4gICAgLCBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH07XHJcbiAgdHJ5IHtcclxuICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcclxuICB9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcclxuICAgIGlmIChleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XHJcbiAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcclxuICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xyXG4gICAgfVxyXG4gIH1cclxufSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XHJcbiAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcclxufVxyXG5cclxufShzZWxmKSk7XHJcblxyXG59IGVsc2Uge1xyXG4vLyBUaGVyZSBpcyBmdWxsIG9yIHBhcnRpYWwgbmF0aXZlIGNsYXNzTGlzdCBzdXBwb3J0LCBzbyBqdXN0IGNoZWNrIGlmIHdlIG5lZWRcclxuLy8gdG8gbm9ybWFsaXplIHRoZSBhZGQvcmVtb3ZlIGFuZCB0b2dnbGUgQVBJcy5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xyXG5cclxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYzFcIiwgXCJjMlwiKTtcclxuXHJcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwLzExIGFuZCBGaXJlZm94IDwyNiwgd2hlcmUgY2xhc3NMaXN0LmFkZCBhbmRcclxuICAvLyBjbGFzc0xpc3QucmVtb3ZlIGV4aXN0IGJ1dCBzdXBwb3J0IG9ubHkgb25lIGFyZ3VtZW50IGF0IGEgdGltZS5cclxuICBpZiAoIXRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMyXCIpKSB7XHJcbiAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICAgIHZhciBvcmlnaW5hbCA9IERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXTtcclxuXHJcbiAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgdG9rZW4gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICBvcmlnaW5hbC5jYWxsKHRoaXMsIHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY3JlYXRlTWV0aG9kKCdhZGQnKTtcclxuICAgIGNyZWF0ZU1ldGhvZCgncmVtb3ZlJyk7XHJcbiAgfVxyXG5cclxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiYzNcIiwgZmFsc2UpO1xyXG5cclxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAgYW5kIEZpcmVmb3ggPDI0LCB3aGVyZSBjbGFzc0xpc3QudG9nZ2xlIGRvZXMgbm90XHJcbiAgLy8gc3VwcG9ydCB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xyXG4gICAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcclxuXHJcbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHRva2VuLCBmb3JjZSkge1xyXG4gICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcclxuICAgICAgICByZXR1cm4gZm9yY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gIH1cclxuXHJcbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xyXG59KCkpO1xyXG5cclxufVxyXG5cclxufVxyXG5cclxuIiwiLyohXG5cbkNvcHlyaWdodCAoQykgMjAxNC0yMDE2IGJ5IEFuZHJlYSBHaWFtbWFyY2hpIC0gQFdlYlJlZmxlY3Rpb25cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG5pZiAoJ2N1c3RvbUVsZW1lbnRzJyBpbiB3aW5kb3cpIHtcbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSA9IHVuZGVmaW5lZDtcbn1cblxuKGZ1bmN0aW9uKHdpbmRvdyl7J3VzZSBzdHJpY3QnO1xuXG4gIC8vIERPIE5PVCBVU0UgVEhJUyBGSUxFIERJUkVDVExZLCBJVCBXT04nVCBXT1JLXG4gIC8vIFRISVMgSVMgQSBQUk9KRUNUIEJBU0VEIE9OIEEgQlVJTEQgU1lTVEVNXG4gIC8vIFRISVMgRklMRSBJUyBKVVNUIFdSQVBQRUQgVVAgUkVTVUxUSU5HIElOXG4gIC8vIGJ1aWxkL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQuanNcbiAgLy8gYW5kIGl0cyAubWF4LmpzIGNvdW50ZXIgcGFydFxuXG4gIHZhclxuICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgIE9iamVjdCA9IHdpbmRvdy5PYmplY3RcbiAgO1xuXG4gIHZhciBodG1sQ2xhc3MgPSAoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAvLyAoQykgQW5kcmVhIEdpYW1tYXJjaGkgLSBAV2ViUmVmbGVjdGlvbiAtIE1JVCBTdHlsZVxuICAgIHZhclxuICAgICAgY2F0Y2hDbGFzcyA9IC9eW0EtWl0rW2Etel0vLFxuICAgICAgZmlsdGVyQnkgPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdLCB0YWc7XG4gICAgICAgIGZvciAodGFnIGluIHJlZ2lzdGVyKSB7XG4gICAgICAgICAgaWYgKHJlLnRlc3QodGFnKSkgYXJyLnB1c2godGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSxcbiAgICAgIGFkZCA9IGZ1bmN0aW9uIChDbGFzcywgdGFnKSB7XG4gICAgICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoISh0YWcgaW4gcmVnaXN0ZXIpKSB7XG4gICAgICAgICAgcmVnaXN0ZXJbQ2xhc3NdID0gKHJlZ2lzdGVyW0NsYXNzXSB8fCBbXSkuY29uY2F0KHRhZyk7XG4gICAgICAgICAgcmVnaXN0ZXJbdGFnXSA9IChyZWdpc3Rlclt0YWcudG9VcHBlckNhc2UoKV0gPSBDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWdpc3RlciA9IChPYmplY3QuY3JlYXRlIHx8IE9iamVjdCkobnVsbCksXG4gICAgICBodG1sQ2xhc3MgPSB7fSxcbiAgICAgIGksIHNlY3Rpb24sIHRhZ3MsIENsYXNzXG4gICAgO1xuICAgIGZvciAoc2VjdGlvbiBpbiBpbmZvKSB7XG4gICAgICBmb3IgKENsYXNzIGluIGluZm9bc2VjdGlvbl0pIHtcbiAgICAgICAgdGFncyA9IGluZm9bc2VjdGlvbl1bQ2xhc3NdO1xuICAgICAgICByZWdpc3RlcltDbGFzc10gPSB0YWdzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlZ2lzdGVyW3RhZ3NbaV0udG9Mb3dlckNhc2UoKV0gPVxuICAgICAgICAgIHJlZ2lzdGVyW3RhZ3NbaV0udG9VcHBlckNhc2UoKV0gPSBDbGFzcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBodG1sQ2xhc3MuZ2V0ID0gZnVuY3Rpb24gZ2V0KHRhZ09yQ2xhc3MpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGFnT3JDbGFzcyA9PT0gJ3N0cmluZycgP1xuICAgICAgICAocmVnaXN0ZXJbdGFnT3JDbGFzc10gfHwgKGNhdGNoQ2xhc3MudGVzdCh0YWdPckNsYXNzKSA/IFtdIDogJycpKSA6XG4gICAgICAgIGZpbHRlckJ5KHRhZ09yQ2xhc3MpO1xuICAgIH07XG4gICAgaHRtbENsYXNzLnNldCA9IGZ1bmN0aW9uIHNldCh0YWcsIENsYXNzKSB7XG4gICAgICByZXR1cm4gKGNhdGNoQ2xhc3MudGVzdCh0YWcpID9cbiAgICAgICAgYWRkKHRhZywgQ2xhc3MpIDpcbiAgICAgICAgYWRkKENsYXNzLCB0YWcpXG4gICAgICApLCBodG1sQ2xhc3M7XG4gICAgfTtcbiAgICByZXR1cm4gaHRtbENsYXNzO1xuICB9KHtcbiAgICBcImNvbGxlY3Rpb25zXCI6IHtcbiAgICAgIFwiSFRNTEFsbENvbGxlY3Rpb25cIjogW1xuICAgICAgICBcImFsbFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQ29sbGVjdGlvblwiOiBbXG4gICAgICAgIFwiZm9ybXNcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb25cIjogW1xuICAgICAgICBcImVsZW1lbnRzXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxPcHRpb25zQ29sbGVjdGlvblwiOiBbXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImVsZW1lbnRzXCI6IHtcbiAgICAgIFwiRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZWxlbWVudFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQW5jaG9yRWxlbWVudFwiOiBbXG4gICAgICAgIFwiYVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQXBwbGV0RWxlbWVudFwiOiBbXG4gICAgICAgIFwiYXBwbGV0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxBcmVhRWxlbWVudFwiOiBbXG4gICAgICAgIFwiYXJlYVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQXR0YWNobWVudEVsZW1lbnRcIjogW1xuICAgICAgICBcImF0dGFjaG1lbnRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEF1ZGlvRWxlbWVudFwiOiBbXG4gICAgICAgIFwiYXVkaW9cIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEJSRWxlbWVudFwiOiBbXG4gICAgICAgIFwiYnJcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEJhc2VFbGVtZW50XCI6IFtcbiAgICAgICAgXCJiYXNlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxCb2R5RWxlbWVudFwiOiBbXG4gICAgICAgIFwiYm9keVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQnV0dG9uRWxlbWVudFwiOiBbXG4gICAgICAgIFwiYnV0dG9uXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxDYW52YXNFbGVtZW50XCI6IFtcbiAgICAgICAgXCJjYW52YXNcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTENvbnRlbnRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJjb250ZW50XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxETGlzdEVsZW1lbnRcIjogW1xuICAgICAgICBcImRsXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxEYXRhRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZGF0YVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRGF0YUxpc3RFbGVtZW50XCI6IFtcbiAgICAgICAgXCJkYXRhbGlzdFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRGV0YWlsc0VsZW1lbnRcIjogW1xuICAgICAgICBcImRldGFpbHNcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTERpYWxvZ0VsZW1lbnRcIjogW1xuICAgICAgICBcImRpYWxvZ1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRGlyZWN0b3J5RWxlbWVudFwiOiBbXG4gICAgICAgIFwiZGlyXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxEaXZFbGVtZW50XCI6IFtcbiAgICAgICAgXCJkaXZcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTERvY3VtZW50XCI6IFtcbiAgICAgICAgXCJkb2N1bWVudFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZWxlbWVudFwiLFxuICAgICAgICBcImFiYnJcIixcbiAgICAgICAgXCJhZGRyZXNzXCIsXG4gICAgICAgIFwiYXJ0aWNsZVwiLFxuICAgICAgICBcImFzaWRlXCIsXG4gICAgICAgIFwiYlwiLFxuICAgICAgICBcImJkaVwiLFxuICAgICAgICBcImJkb1wiLFxuICAgICAgICBcImNpdGVcIixcbiAgICAgICAgXCJjb2RlXCIsXG4gICAgICAgIFwiY29tbWFuZFwiLFxuICAgICAgICBcImRkXCIsXG4gICAgICAgIFwiZGZuXCIsXG4gICAgICAgIFwiZHRcIixcbiAgICAgICAgXCJlbVwiLFxuICAgICAgICBcImZpZ2NhcHRpb25cIixcbiAgICAgICAgXCJmaWd1cmVcIixcbiAgICAgICAgXCJmb290ZXJcIixcbiAgICAgICAgXCJoZWFkZXJcIixcbiAgICAgICAgXCJpXCIsXG4gICAgICAgIFwia2JkXCIsXG4gICAgICAgIFwibWFya1wiLFxuICAgICAgICBcIm5hdlwiLFxuICAgICAgICBcIm5vc2NyaXB0XCIsXG4gICAgICAgIFwicnBcIixcbiAgICAgICAgXCJydFwiLFxuICAgICAgICBcInJ1YnlcIixcbiAgICAgICAgXCJzXCIsXG4gICAgICAgIFwic2FtcFwiLFxuICAgICAgICBcInNlY3Rpb25cIixcbiAgICAgICAgXCJzbWFsbFwiLFxuICAgICAgICBcInN0cm9uZ1wiLFxuICAgICAgICBcInN1YlwiLFxuICAgICAgICBcInN1bW1hcnlcIixcbiAgICAgICAgXCJzdXBcIixcbiAgICAgICAgXCJ1XCIsXG4gICAgICAgIFwidmFyXCIsXG4gICAgICAgIFwid2JyXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxFbWJlZEVsZW1lbnRcIjogW1xuICAgICAgICBcImVtYmVkXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxGaWVsZFNldEVsZW1lbnRcIjogW1xuICAgICAgICBcImZpZWxkc2V0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxGb250RWxlbWVudFwiOiBbXG4gICAgICAgIFwiZm9udFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRm9ybUVsZW1lbnRcIjogW1xuICAgICAgICBcImZvcm1cIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEZyYW1lRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZnJhbWVcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEZyYW1lU2V0RWxlbWVudFwiOiBbXG4gICAgICAgIFwiZnJhbWVzZXRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEhSRWxlbWVudFwiOiBbXG4gICAgICAgIFwiaHJcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEhlYWRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJoZWFkXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxIZWFkaW5nRWxlbWVudFwiOiBbXG4gICAgICAgIFwiaDFcIixcbiAgICAgICAgXCJoMlwiLFxuICAgICAgICBcImgzXCIsXG4gICAgICAgIFwiaDRcIixcbiAgICAgICAgXCJoNVwiLFxuICAgICAgICBcImg2XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxIdG1sRWxlbWVudFwiOiBbXG4gICAgICAgIFwiaHRtbFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MSUZyYW1lRWxlbWVudFwiOiBbXG4gICAgICAgIFwiaWZyYW1lXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxJbWFnZUVsZW1lbnRcIjogW1xuICAgICAgICBcImltZ1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MSW5wdXRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJpbnB1dFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MS2V5Z2VuRWxlbWVudFwiOiBbXG4gICAgICAgIFwia2V5Z2VuXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxMSUVsZW1lbnRcIjogW1xuICAgICAgICBcImxpXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxMYWJlbEVsZW1lbnRcIjogW1xuICAgICAgICBcImxhYmVsXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxMZWdlbmRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJsZWdlbmRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTExpbmtFbGVtZW50XCI6IFtcbiAgICAgICAgXCJsaW5rXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxNYXBFbGVtZW50XCI6IFtcbiAgICAgICAgXCJtYXBcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE1hcnF1ZWVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJtYXJxdWVlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxNZWRpYUVsZW1lbnRcIjogW1xuICAgICAgICBcIm1lZGlhXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxNZW51RWxlbWVudFwiOiBbXG4gICAgICAgIFwibWVudVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MTWVudUl0ZW1FbGVtZW50XCI6IFtcbiAgICAgICAgXCJtZW51aXRlbVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MTWV0YUVsZW1lbnRcIjogW1xuICAgICAgICBcIm1ldGFcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE1ldGVyRWxlbWVudFwiOiBbXG4gICAgICAgIFwibWV0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE1vZEVsZW1lbnRcIjogW1xuICAgICAgICBcImRlbFwiLFxuICAgICAgICBcImluc1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MT0xpc3RFbGVtZW50XCI6IFtcbiAgICAgICAgXCJvbFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MT2JqZWN0RWxlbWVudFwiOiBbXG4gICAgICAgIFwib2JqZWN0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxPcHRHcm91cEVsZW1lbnRcIjogW1xuICAgICAgICBcIm9wdGdyb3VwXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxPcHRpb25FbGVtZW50XCI6IFtcbiAgICAgICAgXCJvcHRpb25cIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE91dHB1dEVsZW1lbnRcIjogW1xuICAgICAgICBcIm91dHB1dFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MUGFyYWdyYXBoRWxlbWVudFwiOiBbXG4gICAgICAgIFwicFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MUGFyYW1FbGVtZW50XCI6IFtcbiAgICAgICAgXCJwYXJhbVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MUGljdHVyZUVsZW1lbnRcIjogW1xuICAgICAgICBcInBpY3R1cmVcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFByZUVsZW1lbnRcIjogW1xuICAgICAgICBcInByZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MUHJvZ3Jlc3NFbGVtZW50XCI6IFtcbiAgICAgICAgXCJwcm9ncmVzc1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MUXVvdGVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJibG9ja3F1b3RlXCIsXG4gICAgICAgIFwicVwiLFxuICAgICAgICBcInF1b3RlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxTY3JpcHRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJzY3JpcHRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFNlbGVjdEVsZW1lbnRcIjogW1xuICAgICAgICBcInNlbGVjdFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MU2hhZG93RWxlbWVudFwiOiBbXG4gICAgICAgIFwic2hhZG93XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxTbG90RWxlbWVudFwiOiBbXG4gICAgICAgIFwic2xvdFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MU291cmNlRWxlbWVudFwiOiBbXG4gICAgICAgIFwic291cmNlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxTcGFuRWxlbWVudFwiOiBbXG4gICAgICAgIFwic3BhblwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MU3R5bGVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJzdHlsZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGFibGVDYXB0aW9uRWxlbWVudFwiOiBbXG4gICAgICAgIFwiY2FwdGlvblwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGFibGVDZWxsRWxlbWVudFwiOiBbXG4gICAgICAgIFwidGRcIixcbiAgICAgICAgXCJ0aFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGFibGVDb2xFbGVtZW50XCI6IFtcbiAgICAgICAgXCJjb2xcIixcbiAgICAgICAgXCJjb2xncm91cFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGFibGVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0YWJsZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGFibGVSb3dFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0clwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGFibGVTZWN0aW9uRWxlbWVudFwiOiBbXG4gICAgICAgIFwidGhlYWRcIixcbiAgICAgICAgXCJ0Ym9keVwiLFxuICAgICAgICBcInRmb290XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUZW1wbGF0ZUVsZW1lbnRcIjogW1xuICAgICAgICBcInRlbXBsYXRlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUZXh0QXJlYUVsZW1lbnRcIjogW1xuICAgICAgICBcInRleHRhcmVhXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUaW1lRWxlbWVudFwiOiBbXG4gICAgICAgIFwidGltZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVGl0bGVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0aXRsZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVHJhY2tFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0cmFja1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVUxpc3RFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ1bFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVW5rbm93bkVsZW1lbnRcIjogW1xuICAgICAgICBcInVua25vd25cIixcbiAgICAgICAgXCJ2aGdyb3VwdlwiLFxuICAgICAgICBcInZrZXlnZW5cIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFZpZGVvRWxlbWVudFwiOiBbXG4gICAgICAgIFwidmlkZW9cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJub2Rlc1wiOiB7XG4gICAgICBcIkF0dHJcIjogW1xuICAgICAgICBcIm5vZGVcIlxuICAgICAgXSxcbiAgICAgIFwiQXVkaW9cIjogW1xuICAgICAgICBcImF1ZGlvXCJcbiAgICAgIF0sXG4gICAgICBcIkNEQVRBU2VjdGlvblwiOiBbXG4gICAgICAgIFwibm9kZVwiXG4gICAgICBdLFxuICAgICAgXCJDaGFyYWN0ZXJEYXRhXCI6IFtcbiAgICAgICAgXCJub2RlXCJcbiAgICAgIF0sXG4gICAgICBcIkNvbW1lbnRcIjogW1xuICAgICAgICBcIiNjb21tZW50XCJcbiAgICAgIF0sXG4gICAgICBcIkRvY3VtZW50XCI6IFtcbiAgICAgICAgXCIjZG9jdW1lbnRcIlxuICAgICAgXSxcbiAgICAgIFwiRG9jdW1lbnRGcmFnbWVudFwiOiBbXG4gICAgICAgIFwiI2RvY3VtZW50LWZyYWdtZW50XCJcbiAgICAgIF0sXG4gICAgICBcIkRvY3VtZW50VHlwZVwiOiBbXG4gICAgICAgIFwibm9kZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRG9jdW1lbnRcIjogW1xuICAgICAgICBcIiNkb2N1bWVudFwiXG4gICAgICBdLFxuICAgICAgXCJJbWFnZVwiOiBbXG4gICAgICAgIFwiaW1nXCJcbiAgICAgIF0sXG4gICAgICBcIk9wdGlvblwiOiBbXG4gICAgICAgIFwib3B0aW9uXCJcbiAgICAgIF0sXG4gICAgICBcIlByb2Nlc3NpbmdJbnN0cnVjdGlvblwiOiBbXG4gICAgICAgIFwibm9kZVwiXG4gICAgICBdLFxuICAgICAgXCJTaGFkb3dSb290XCI6IFtcbiAgICAgICAgXCIjc2hhZG93LXJvb3RcIlxuICAgICAgXSxcbiAgICAgIFwiVGV4dFwiOiBbXG4gICAgICAgIFwiI3RleHRcIlxuICAgICAgXSxcbiAgICAgIFwiWE1MRG9jdW1lbnRcIjogW1xuICAgICAgICBcInhtbFwiXG4gICAgICBdXG4gICAgfVxuICB9KSk7XG4gIFxuICBcbiAgICB2YXJcbiAgICAvLyBWMCBwb2x5ZmlsbCBlbnRyeVxuICAgIFJFR0lTVEVSX0VMRU1FTlQgPSAncmVnaXN0ZXJFbGVtZW50JyxcbiAgXG4gICAgLy8gSUUgPCAxMSBvbmx5ICsgb2xkIFdlYktpdCBmb3IgYXR0cmlidXRlcyArIGZlYXR1cmUgZGV0ZWN0aW9uXG4gICAgRVhQQU5ET19VSUQgPSAnX18nICsgUkVHSVNURVJfRUxFTUVOVCArICh3aW5kb3cuTWF0aC5yYW5kb20oKSAqIDEwZTQgPj4gMCksXG4gIFxuICAgIC8vIHNob3J0Y3V0cyBhbmQgY29zdGFudHNcbiAgICBBRERfRVZFTlRfTElTVEVORVIgPSAnYWRkRXZlbnRMaXN0ZW5lcicsXG4gICAgQVRUQUNIRUQgPSAnYXR0YWNoZWQnLFxuICAgIENBTExCQUNLID0gJ0NhbGxiYWNrJyxcbiAgICBERVRBQ0hFRCA9ICdkZXRhY2hlZCcsXG4gICAgRVhURU5EUyA9ICdleHRlbmRzJyxcbiAgXG4gICAgQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0sgPSAnYXR0cmlidXRlQ2hhbmdlZCcgKyBDQUxMQkFDSyxcbiAgICBBVFRBQ0hFRF9DQUxMQkFDSyA9IEFUVEFDSEVEICsgQ0FMTEJBQ0ssXG4gICAgQ09OTkVDVEVEX0NBTExCQUNLID0gJ2Nvbm5lY3RlZCcgKyBDQUxMQkFDSyxcbiAgICBESVNDT05ORUNURURfQ0FMTEJBQ0sgPSAnZGlzY29ubmVjdGVkJyArIENBTExCQUNLLFxuICAgIENSRUFURURfQ0FMTEJBQ0sgPSAnY3JlYXRlZCcgKyBDQUxMQkFDSyxcbiAgICBERVRBQ0hFRF9DQUxMQkFDSyA9IERFVEFDSEVEICsgQ0FMTEJBQ0ssXG4gIFxuICAgIEFERElUSU9OID0gJ0FERElUSU9OJyxcbiAgICBNT0RJRklDQVRJT04gPSAnTU9ESUZJQ0FUSU9OJyxcbiAgICBSRU1PVkFMID0gJ1JFTU9WQUwnLFxuICBcbiAgICBET01fQVRUUl9NT0RJRklFRCA9ICdET01BdHRyTW9kaWZpZWQnLFxuICAgIERPTV9DT05URU5UX0xPQURFRCA9ICdET01Db250ZW50TG9hZGVkJyxcbiAgICBET01fU1VCVFJFRV9NT0RJRklFRCA9ICdET01TdWJ0cmVlTW9kaWZpZWQnLFxuICBcbiAgICBQUkVGSVhfVEFHID0gJzwnLFxuICAgIFBSRUZJWF9JUyA9ICc9JyxcbiAgXG4gICAgLy8gdmFsaWQgYW5kIGludmFsaWQgbm9kZSBuYW1lc1xuICAgIHZhbGlkTmFtZSA9IC9eW0EtWl1bQS1aMC05XSooPzotW0EtWjAtOV0rKSskLyxcbiAgICBpbnZhbGlkTmFtZXMgPSBbXG4gICAgICAnQU5OT1RBVElPTi1YTUwnLFxuICAgICAgJ0NPTE9SLVBST0ZJTEUnLFxuICAgICAgJ0ZPTlQtRkFDRScsXG4gICAgICAnRk9OVC1GQUNFLVNSQycsXG4gICAgICAnRk9OVC1GQUNFLVVSSScsXG4gICAgICAnRk9OVC1GQUNFLUZPUk1BVCcsXG4gICAgICAnRk9OVC1GQUNFLU5BTUUnLFxuICAgICAgJ01JU1NJTkctR0xZUEgnXG4gICAgXSxcbiAgXG4gICAgLy8gcmVnaXN0ZXJlZCB0eXBlcyBhbmQgdGhlaXIgcHJvdG90eXBlc1xuICAgIHR5cGVzID0gW10sXG4gICAgcHJvdG9zID0gW10sXG4gIFxuICAgIC8vIHRvIHF1ZXJ5IHN1Ym5vZGVzXG4gICAgcXVlcnkgPSAnJyxcbiAgXG4gICAgLy8gaHRtbCBzaG9ydGN1dCB1c2VkIHRvIGZlYXR1cmUgZGV0ZWN0XG4gICAgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICBcbiAgICAvLyBFUzUgaW5saW5lIGhlbHBlcnMgfHwgYmFzaWMgcGF0Y2hlc1xuICAgIGluZGV4T2YgPSB0eXBlcy5pbmRleE9mIHx8IGZ1bmN0aW9uICh2KSB7XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLmxlbmd0aDsgaS0tICYmIHRoaXNbaV0gIT09IHY7KXt9XG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICBcbiAgICAvLyBvdGhlciBoZWxwZXJzIC8gc2hvcnRjdXRzXG4gICAgT1AgPSBPYmplY3QucHJvdG90eXBlLFxuICAgIGhPUCA9IE9QLmhhc093blByb3BlcnR5LFxuICAgIGlQTyA9IE9QLmlzUHJvdG90eXBlT2YsXG4gIFxuICAgIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgIGVtcHR5ID0gW10sXG4gICAgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgZ09QTiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgIGdQTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICBzUE8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsXG4gIFxuICAgIC8vIGpzaGludCBwcm90bzogdHJ1ZVxuICAgIGhhc1Byb3RvID0gISFPYmplY3QuX19wcm90b19fLFxuICBcbiAgICAvLyBWMSBoZWxwZXJzXG4gICAgZml4R2V0Q2xhc3MgPSBmYWxzZSxcbiAgICBEUkVDRVYxID0gJ19fZHJlQ0V2MScsXG4gICAgY3VzdG9tRWxlbWVudHMgPSB3aW5kb3cuY3VzdG9tRWxlbWVudHMsXG4gICAgdXNhYmxlQ3VzdG9tRWxlbWVudHMgPSAhIShcbiAgICAgIGN1c3RvbUVsZW1lbnRzICYmXG4gICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUgJiZcbiAgICAgIGN1c3RvbUVsZW1lbnRzLmdldCAmJlxuICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWRcbiAgICApLFxuICAgIERpY3QgPSBPYmplY3QuY3JlYXRlIHx8IE9iamVjdCxcbiAgICBNYXAgPSB3aW5kb3cuTWFwIHx8IGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgIHZhciBLID0gW10sIFYgPSBbXSwgaTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gVltpbmRleE9mLmNhbGwoSywgayldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgaSA9IGluZGV4T2YuY2FsbChLLCBrKTtcbiAgICAgICAgICBpZiAoaSA8IDApIFZbSy5wdXNoKGspIC0gMV0gPSB2O1xuICAgICAgICAgIGVsc2UgVltpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBQcm9taXNlID0gd2luZG93LlByb21pc2UgfHwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXJcbiAgICAgICAgbm90aWZ5ID0gW10sXG4gICAgICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgICAgcCA9IHtcbiAgICAgICAgICAnY2F0Y2gnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9LFxuICAgICAgICAgICd0aGVuJzogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBub3RpZnkucHVzaChjYik7XG4gICAgICAgICAgICBpZiAoZG9uZSkgc2V0VGltZW91dChyZXNvbHZlLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgO1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKG5vdGlmeS5sZW5ndGgpIG5vdGlmeS5zaGlmdCgpKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuKHJlc29sdmUpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBqdXN0Q3JlYXRlZCA9IGZhbHNlLFxuICAgIGNvbnN0cnVjdG9ycyA9IERpY3QobnVsbCksXG4gICAgd2FpdGluZ0xpc3QgPSBEaWN0KG51bGwpLFxuICAgIG5vZGVOYW1lcyA9IG5ldyBNYXAoKSxcbiAgICBzZWNvbmRBcmd1bWVudCA9IFN0cmluZyxcbiAgXG4gICAgLy8gdXNlZCB0byBjcmVhdGUgdW5pcXVlIGluc3RhbmNlc1xuICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gQnJpZGdlKHByb3RvKSB7XG4gICAgICAvLyBzaWxseSBicm9rZW4gcG9seWZpbGwgcHJvYmFibHkgZXZlciB1c2VkIGJ1dCBzaG9ydCBlbm91Z2ggdG8gd29ya1xuICAgICAgcmV0dXJuIHByb3RvID8gKChCcmlkZ2UucHJvdG90eXBlID0gcHJvdG8pLCBuZXcgQnJpZGdlKCkpIDogdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyB3aWxsIHNldCB0aGUgcHJvdG90eXBlIGlmIHBvc3NpYmxlXG4gICAgLy8gb3IgY29weSBvdmVyIGFsbCBwcm9wZXJ0aWVzXG4gICAgc2V0UHJvdG90eXBlID0gc1BPIHx8IChcbiAgICAgIGhhc1Byb3RvID9cbiAgICAgICAgZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0gOiAoXG4gICAgICAoZ09QTiAmJiBnT1BEKSA/XG4gICAgICAgIChmdW5jdGlvbigpe1xuICAgICAgICAgIGZ1bmN0aW9uIHNldFByb3BlcnRpZXMobywgcCkge1xuICAgICAgICAgICAgZm9yICh2YXJcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBuYW1lcyA9IGdPUE4ocCksXG4gICAgICAgICAgICAgIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGtleSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgICBpZiAoIWhPUC5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvLCBrZXksIGdPUEQocCwga2V5KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHNldFByb3BlcnRpZXMobywgcCk7XG4gICAgICAgICAgICB9IHdoaWxlICgocCA9IGdQTyhwKSkgJiYgIWlQTy5jYWxsKHAsIG8pKTtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKSkgOlxuICAgICAgICBmdW5jdGlvbiAobywgcCkge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwKSB7XG4gICAgICAgICAgICBvW2tleV0gPSBwW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgKSksXG4gIFxuICAgIC8vIERPTSBzaG9ydGN1dHMgYW5kIGhlbHBlcnMsIGlmIGFueVxuICBcbiAgICBNdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsXG4gIFxuICAgIEhUTUxFbGVtZW50UHJvdG90eXBlID0gKFxuICAgICAgd2luZG93LkhUTUxFbGVtZW50IHx8XG4gICAgICB3aW5kb3cuRWxlbWVudCB8fFxuICAgICAgd2luZG93Lk5vZGVcbiAgICApLnByb3RvdHlwZSxcbiAgXG4gICAgSUU4ID0gIWlQTy5jYWxsKEhUTUxFbGVtZW50UHJvdG90eXBlLCBkb2N1bWVudEVsZW1lbnQpLFxuICBcbiAgICBzYWZlUHJvcGVydHkgPSBJRTggPyBmdW5jdGlvbiAobywgaywgZCkge1xuICAgICAgb1trXSA9IGQudmFsdWU7XG4gICAgICByZXR1cm4gbztcbiAgICB9IDogZGVmaW5lUHJvcGVydHksXG4gIFxuICAgIGlzVmFsaWROb2RlID0gSUU4ID9cbiAgICAgIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gaVBPLmNhbGwoSFRNTEVsZW1lbnRQcm90b3R5cGUsIG5vZGUpO1xuICAgICAgfSxcbiAgXG4gICAgdGFyZ2V0cyA9IElFOCAmJiBbXSxcbiAgXG4gICAgYXR0YWNoU2hhZG93ID0gSFRNTEVsZW1lbnRQcm90b3R5cGUuYXR0YWNoU2hhZG93LFxuICAgIGNsb25lTm9kZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZSxcbiAgICBkaXNwYXRjaEV2ZW50ID0gSFRNTEVsZW1lbnRQcm90b3R5cGUuZGlzcGF0Y2hFdmVudCxcbiAgICBnZXRBdHRyaWJ1dGUgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5nZXRBdHRyaWJ1dGUsXG4gICAgaGFzQXR0cmlidXRlID0gSFRNTEVsZW1lbnRQcm90b3R5cGUuaGFzQXR0cmlidXRlLFxuICAgIHJlbW92ZUF0dHJpYnV0ZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxcbiAgICBzZXRBdHRyaWJ1dGUgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5zZXRBdHRyaWJ1dGUsXG4gIFxuICAgIC8vIHJlcGxhY2VkIGxhdGVyIG9uXG4gICAgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQsXG4gICAgcGF0Y2hlZENyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LFxuICBcbiAgICAvLyBzaGFyZWQgb2JzZXJ2ZXIgZm9yIGFsbCBhdHRyaWJ1dGVzXG4gICAgYXR0cmlidXRlc09ic2VydmVyID0gTXV0YXRpb25PYnNlcnZlciAmJiB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgXG4gICAgLy8gdXNlZnVsIHRvIGRldGVjdCBvbmx5IGlmIHRoZXJlJ3Mgbm8gTXV0YXRpb25PYnNlcnZlclxuICAgIERPTUF0dHJNb2RpZmllZCA9IE11dGF0aW9uT2JzZXJ2ZXIgfHwgZnVuY3Rpb24oZSkge1xuICAgICAgZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBET01fQVRUUl9NT0RJRklFRCxcbiAgICAgICAgRE9NQXR0ck1vZGlmaWVkXG4gICAgICApO1xuICAgIH0sXG4gIFxuICAgIC8vIHdpbGwgYm90aCBiZSB1c2VkIHRvIG1ha2UgRE9NTm9kZUluc2VydGVkIGFzeW5jaHJvbm91c1xuICAgIGFzYXBRdWV1ZSxcbiAgICBhc2FwVGltZXIgPSAwLFxuICBcbiAgICAvLyBpbnRlcm5hbCBmbGFnc1xuICAgIHNldExpc3RlbmVyID0gZmFsc2UsXG4gICAgZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQgPSB0cnVlLFxuICAgIGRyb3BEb21Db250ZW50TG9hZGVkID0gdHJ1ZSxcbiAgXG4gICAgLy8gbmVlZGVkIGZvciB0aGUgaW5uZXJIVE1MIGhlbHBlclxuICAgIG5vdEZyb21Jbm5lckhUTUxIZWxwZXIgPSB0cnVlLFxuICBcbiAgICAvLyBvcHRpb25hbGx5IGRlZmluZWQgbGF0ZXIgb25cbiAgICBvblN1YnRyZWVNb2RpZmllZCxcbiAgICBjYWxsRE9NQXR0ck1vZGlmaWVkLFxuICAgIGdldEF0dHJpYnV0ZXNNaXJyb3IsXG4gICAgb2JzZXJ2ZXIsXG4gICAgb2JzZXJ2ZSxcbiAgXG4gICAgLy8gYmFzZWQgb24gc2V0dGluZyBwcm90b3R5cGUgY2FwYWJpbGl0eVxuICAgIC8vIHdpbGwgY2hlY2sgcHJvdG8gb3IgdGhlIGV4cGFuZG8gYXR0cmlidXRlXG4gICAgLy8gaW4gb3JkZXIgdG8gc2V0dXAgdGhlIG5vZGUgb25jZVxuICAgIHBhdGNoSWZOb3RBbHJlYWR5LFxuICAgIHBhdGNoXG4gIDtcbiAgXG4gIC8vIG9ubHkgaWYgbmVlZGVkXG4gIGlmICghKFJFR0lTVEVSX0VMRU1FTlQgaW4gZG9jdW1lbnQpKSB7XG4gIFxuICAgIGlmIChzUE8gfHwgaGFzUHJvdG8pIHtcbiAgICAgICAgcGF0Y2hJZk5vdEFscmVhZHkgPSBmdW5jdGlvbiAobm9kZSwgcHJvdG8pIHtcbiAgICAgICAgICBpZiAoIWlQTy5jYWxsKHByb3RvLCBub2RlKSkge1xuICAgICAgICAgICAgc2V0dXBOb2RlKG5vZGUsIHByb3RvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhdGNoID0gc2V0dXBOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoSWZOb3RBbHJlYWR5ID0gZnVuY3Rpb24gKG5vZGUsIHByb3RvKSB7XG4gICAgICAgICAgaWYgKCFub2RlW0VYUEFORE9fVUlEXSkge1xuICAgICAgICAgICAgbm9kZVtFWFBBTkRPX1VJRF0gPSBPYmplY3QodHJ1ZSk7XG4gICAgICAgICAgICBzZXR1cE5vZGUobm9kZSwgcHJvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaElmTm90QWxyZWFkeTtcbiAgICB9XG4gIFxuICAgIGlmIChJRTgpIHtcbiAgICAgIGRvZXNOb3RTdXBwb3J0RE9NQXR0ck1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAoZnVuY3Rpb24gKCl7XG4gICAgICAgIHZhclxuICAgICAgICAgIGRlc2NyaXB0b3IgPSBnT1BEKEhUTUxFbGVtZW50UHJvdG90eXBlLCBBRERfRVZFTlRfTElTVEVORVIpLFxuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIgPSBkZXNjcmlwdG9yLnZhbHVlLFxuICAgICAgICAgIHBhdGNoZWRSZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgQ3VzdG9tRXZlbnQoRE9NX0FUVFJfTU9ESUZJRUQsIHtidWJibGVzOiB0cnVlfSk7XG4gICAgICAgICAgICBlLmF0dHJOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGUucHJldlZhbHVlID0gZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgICBlLm5ld1ZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGVbUkVNT1ZBTF0gPSBlLmF0dHJDaGFuZ2UgPSAyO1xuICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXRjaGVkU2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgaGFkID0gaGFzQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSksXG4gICAgICAgICAgICAgIG9sZCA9IGhhZCAmJiBnZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKSxcbiAgICAgICAgICAgICAgZSA9IG5ldyBDdXN0b21FdmVudChET01fQVRUUl9NT0RJRklFRCwge2J1YmJsZXM6IHRydWV9KVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgZS5hdHRyTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBlLnByZXZWYWx1ZSA9IGhhZCA/IG9sZCA6IG51bGw7XG4gICAgICAgICAgICBlLm5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFkKSB7XG4gICAgICAgICAgICAgIGVbTU9ESUZJQ0FUSU9OXSA9IGUuYXR0ckNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlW0FERElUSU9OXSA9IGUuYXR0ckNoYW5nZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblByb3BlcnR5Q2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIGpzaGludCBlcW51bGw6dHJ1ZVxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgIG5vZGUgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICAgIHN1cGVyU2VjcmV0ID0gbm9kZVtFWFBBTkRPX1VJRF0sXG4gICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IGUucHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKHN1cGVyU2VjcmV0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgc3VwZXJTZWNyZXQgPSBzdXBlclNlY3JldFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChET01fQVRUUl9NT0RJRklFRCwge2J1YmJsZXM6IHRydWV9KTtcbiAgICAgICAgICAgICAgZXZlbnQuYXR0ck5hbWUgPSBzdXBlclNlY3JldC5uYW1lO1xuICAgICAgICAgICAgICBldmVudC5wcmV2VmFsdWUgPSBzdXBlclNlY3JldC52YWx1ZSB8fCBudWxsO1xuICAgICAgICAgICAgICBldmVudC5uZXdWYWx1ZSA9IChzdXBlclNlY3JldC52YWx1ZSA9IG5vZGVbcHJvcGVydHlOYW1lXSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRbQURESVRJT05dID0gZXZlbnQuYXR0ckNoYW5nZSA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnRbTU9ESUZJQ0FUSU9OXSA9IGV2ZW50LmF0dHJDaGFuZ2UgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQuY2FsbChub2RlLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGUgPT09IERPTV9BVFRSX01PRElGSUVEICYmXG4gICAgICAgICAgICB0aGlzW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXSAmJlxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUgIT09IHBhdGNoZWRTZXRBdHRyaWJ1dGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXNbRVhQQU5ET19VSURdID0ge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xhc3MnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNsYXNzTmFtZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUgPSBwYXRjaGVkU2V0QXR0cmlidXRlO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUgPSBwYXRjaGVkUmVtb3ZlQXR0cmlidXRlO1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsICdwcm9wZXJ0eWNoYW5nZScsIG9uUHJvcGVydHlDaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlLCBBRERfRVZFTlRfTElTVEVORVIsIGRlc2NyaXB0b3IpO1xuICAgICAgfSgpKTtcbiAgICB9IGVsc2UgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBkb2N1bWVudEVsZW1lbnRbQUREX0VWRU5UX0xJU1RFTkVSXShET01fQVRUUl9NT0RJRklFRCwgRE9NQXR0ck1vZGlmaWVkKTtcbiAgICAgIGRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoRVhQQU5ET19VSUQsIDEpO1xuICAgICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShFWFBBTkRPX1VJRCk7XG4gICAgICBpZiAoZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQpIHtcbiAgICAgICAgb25TdWJ0cmVlTW9kaWZpZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhclxuICAgICAgICAgICAgbm9kZSA9IHRoaXMsXG4gICAgICAgICAgICBvbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgIDtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMgPSBub2RlW0VYUEFORE9fVUlEXTtcbiAgICAgICAgICAgIG5vZGVbRVhQQU5ET19VSURdID0gKG5ld0F0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzTWlycm9yKG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG5ld0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9sZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlIHdhcyBhZGRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsRE9NQXR0ck1vZGlmaWVkKFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICBBRERJVElPTlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3QXR0cmlidXRlc1trZXldICE9PSBvbGRBdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgd2FzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbERPTUF0dHJNb2RpZmllZChcbiAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlc1trZXldLFxuICAgICAgICAgICAgICAgICAgbmV3QXR0cmlidXRlc1trZXldLFxuICAgICAgICAgICAgICAgICAgTU9ESUZJQ0FUSU9OXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2tpbmcgaWYgaXQgaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2xkQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3QXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsRE9NQXR0ck1vZGlmaWVkKFxuICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICBSRU1PVkFMXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2FsbERPTUF0dHJNb2RpZmllZCA9IGZ1bmN0aW9uIChcbiAgICAgICAgICBhdHRyQ2hhbmdlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYXR0ck5hbWUsXG4gICAgICAgICAgcHJldlZhbHVlLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIGFjdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGF0dHJDaGFuZ2U6IGF0dHJDaGFuZ2UsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgYXR0ck5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgcHJldlZhbHVlOiBwcmV2VmFsdWUsXG4gICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVbYWN0aW9uXSA9IGF0dHJDaGFuZ2U7XG4gICAgICAgICAgb25ET01BdHRyTW9kaWZpZWQoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGdldEF0dHJpYnV0ZXNNaXJyb3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBhdHRyLCBuYW1lLFxuICAgICAgICAgICAgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgaSA9IDAsIGxlbmd0aCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIG5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3NldEF0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIC8vIHNldCBhcyBlbnVtZXJhYmxlLCB3cml0YWJsZSBhbmQgY29uZmlndXJhYmxlXG4gICAgZG9jdW1lbnRbUkVHSVNURVJfRUxFTUVOVF0gPSBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQodHlwZSwgb3B0aW9ucykge1xuICAgICAgdXBwZXJUeXBlID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFzZXRMaXN0ZW5lcikge1xuICAgICAgICAvLyBvbmx5IGZpcnN0IHRpbWUgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50IGlzIHVzZWRcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzZXQgdGhpcyBsaXN0ZW5lclxuICAgICAgICAvLyBzZXR0aW5nIGl0IGJ5IGRlZmF1bHQgbWlnaHQgc2xvdyBkb3duIGZvciBubyByZWFzb25cbiAgICAgICAgc2V0TGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICBpZiAoTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgIG9ic2VydmVyID0gKGZ1bmN0aW9uKGF0dGFjaGVkLCBkZXRhY2hlZCl7XG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja0VtQWxsKGxpc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgY2FsbGJhY2sobGlzdFtpKytdKSl7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChyZWNvcmRzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICAgICAgY3VycmVudCwgbm9kZSwgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgaSA9IDAsIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrRW1BbGwoY3VycmVudC5hZGRlZE5vZGVzLCBhdHRhY2hlZCk7XG4gICAgICAgICAgICAgICAgICBjaGVja0VtQWxsKGN1cnJlbnQucmVtb3ZlZE5vZGVzLCBkZXRhY2hlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgIGlmIChub3RGcm9tSW5uZXJIVE1MSGVscGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgbm9kZVtBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDS10gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZU5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBnZXRBdHRyaWJ1dGUuY2FsbChub2RlLCBjdXJyZW50LmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnQub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXShcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQub2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oZXhlY3V0ZUFjdGlvbihBVFRBQ0hFRCksIGV4ZWN1dGVBY3Rpb24oREVUQUNIRUQpKSk7XG4gICAgICAgICAgb2JzZXJ2ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgb2JzZXJ2ZShkb2N1bWVudCk7XG4gICAgICAgICAgaWYgKGF0dGFjaFNoYWRvdykge1xuICAgICAgICAgICAgSFRNTEVsZW1lbnRQcm90b3R5cGUuYXR0YWNoU2hhZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZShhdHRhY2hTaGFkb3cuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc2FwUXVldWUgPSBbXTtcbiAgICAgICAgICBkb2N1bWVudFtBRERfRVZFTlRfTElTVEVORVJdKCdET01Ob2RlSW5zZXJ0ZWQnLCBvbkRPTU5vZGUoQVRUQUNIRUQpKTtcbiAgICAgICAgICBkb2N1bWVudFtBRERfRVZFTlRfTElTVEVORVJdKCdET01Ob2RlUmVtb3ZlZCcsIG9uRE9NTm9kZShERVRBQ0hFRCkpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBkb2N1bWVudFtBRERfRVZFTlRfTElTVEVORVJdKERPTV9DT05URU5UX0xPQURFRCwgb25SZWFkeVN0YXRlQ2hhbmdlKTtcbiAgICAgICAgZG9jdW1lbnRbQUREX0VWRU5UX0xJU1RFTkVSXSgncmVhZHlzdGF0ZWNoYW5nZScsIG9uUmVhZHlTdGF0ZUNoYW5nZSk7XG4gIFxuICAgICAgICBIVE1MRWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiAoZGVlcCkge1xuICAgICAgICAgIHZhclxuICAgICAgICAgICAgbm9kZSA9IGNsb25lTm9kZS5jYWxsKHRoaXMsICEhZGVlcCksXG4gICAgICAgICAgICBpID0gZ2V0VHlwZUluZGV4KG5vZGUpXG4gICAgICAgICAgO1xuICAgICAgICAgIGlmICgtMSA8IGkpIHBhdGNoKG5vZGUsIHByb3Rvc1tpXSk7XG4gICAgICAgICAgaWYgKGRlZXApIGxvb3BBbmRTZXR1cChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoLTIgPCAoXG4gICAgICAgIGluZGV4T2YuY2FsbCh0eXBlcywgUFJFRklYX0lTICsgdXBwZXJUeXBlKSArXG4gICAgICAgIGluZGV4T2YuY2FsbCh0eXBlcywgUFJFRklYX1RBRyArIHVwcGVyVHlwZSlcbiAgICAgICkpIHtcbiAgICAgICAgdGhyb3dUeXBlRXJyb3IodHlwZSk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKCF2YWxpZE5hbWUudGVzdCh1cHBlclR5cGUpIHx8IC0xIDwgaW5kZXhPZi5jYWxsKGludmFsaWROYW1lcywgdXBwZXJUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0eXBlICcgKyB0eXBlICsgJyBpcyBpbnZhbGlkJyk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyXG4gICAgICAgIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBleHRlbmRpbmcgP1xuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSwgdXBwZXJUeXBlKSA6XG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3B0ID0gb3B0aW9ucyB8fCBPUCxcbiAgICAgICAgZXh0ZW5kaW5nID0gaE9QLmNhbGwob3B0LCBFWFRFTkRTKSxcbiAgICAgICAgbm9kZU5hbWUgPSBleHRlbmRpbmcgPyBvcHRpb25zW0VYVEVORFNdLnRvVXBwZXJDYXNlKCkgOiB1cHBlclR5cGUsXG4gICAgICAgIHVwcGVyVHlwZSxcbiAgICAgICAgaVxuICAgICAgO1xuICBcbiAgICAgIGlmIChleHRlbmRpbmcgJiYgLTEgPCAoXG4gICAgICAgIGluZGV4T2YuY2FsbCh0eXBlcywgUFJFRklYX1RBRyArIG5vZGVOYW1lKVxuICAgICAgKSkge1xuICAgICAgICB0aHJvd1R5cGVFcnJvcihub2RlTmFtZSk7XG4gICAgICB9XG4gIFxuICAgICAgaSA9IHR5cGVzLnB1c2goKGV4dGVuZGluZyA/IFBSRUZJWF9JUyA6IFBSRUZJWF9UQUcpICsgdXBwZXJUeXBlKSAtIDE7XG4gIFxuICAgICAgcXVlcnkgPSBxdWVyeS5jb25jYXQoXG4gICAgICAgIHF1ZXJ5Lmxlbmd0aCA/ICcsJyA6ICcnLFxuICAgICAgICBleHRlbmRpbmcgPyBub2RlTmFtZSArICdbaXM9XCInICsgdHlwZS50b0xvd2VyQ2FzZSgpICsgJ1wiXScgOiBub2RlTmFtZVxuICAgICAgKTtcbiAgXG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAoXG4gICAgICAgIHByb3Rvc1tpXSA9IGhPUC5jYWxsKG9wdCwgJ3Byb3RvdHlwZScpID9cbiAgICAgICAgICBvcHQucHJvdG90eXBlIDpcbiAgICAgICAgICBjcmVhdGUoSFRNTEVsZW1lbnRQcm90b3R5cGUpXG4gICAgICApO1xuICBcbiAgICAgIGxvb3BBbmRWZXJpZnkoXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICBBVFRBQ0hFRFxuICAgICAgKTtcbiAgXG4gICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfTtcbiAgXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9IChwYXRjaGVkQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChsb2NhbE5hbWUsIHR5cGVFeHRlbnNpb24pIHtcbiAgICAgIHZhclxuICAgICAgICBpcyA9IGdldElzKHR5cGVFeHRlbnNpb24pLFxuICAgICAgICBub2RlID0gaXMgP1xuICAgICAgICAgIGNyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgbG9jYWxOYW1lLCBzZWNvbmRBcmd1bWVudChpcykpIDpcbiAgICAgICAgICBjcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsIGxvY2FsTmFtZSksXG4gICAgICAgIG5hbWUgPSAnJyArIGxvY2FsTmFtZSxcbiAgICAgICAgaSA9IGluZGV4T2YuY2FsbChcbiAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAoaXMgPyBQUkVGSVhfSVMgOiBQUkVGSVhfVEFHKSArXG4gICAgICAgICAgKGlzIHx8IG5hbWUpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgKSxcbiAgICAgICAgc2V0dXAgPSAtMSA8IGlcbiAgICAgIDtcbiAgICAgIGlmIChpcykge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaXMnLCBpcyA9IGlzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgICBzZXR1cCA9IGlzSW5RU0EobmFtZS50b1VwcGVyQ2FzZSgpLCBpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vdEZyb21Jbm5lckhUTUxIZWxwZXIgPSAhZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5pbm5lckhUTUxIZWxwZXI7XG4gICAgICBpZiAoc2V0dXApIHBhdGNoKG5vZGUsIHByb3Rvc1tpXSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgXG4gIH1cbiAgXG4gIGZ1bmN0aW9uIEFTQVAoKSB7XG4gICAgdmFyIHF1ZXVlID0gYXNhcFF1ZXVlLnNwbGljZSgwLCBhc2FwUXVldWUubGVuZ3RoKTtcbiAgICBhc2FwVGltZXIgPSAwO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCkuY2FsbChcbiAgICAgICAgbnVsbCwgcXVldWUuc2hpZnQoKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGxvb3BBbmRWZXJpZnkobGlzdCwgYWN0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZlcmlmeUFuZFNldHVwQW5kQWN0aW9uKGxpc3RbaV0sIGFjdGlvbik7XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBsb29wQW5kU2V0dXAobGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbGlzdFtpXTtcbiAgICAgIHBhdGNoKG5vZGUsIHByb3Rvc1tnZXRUeXBlSW5kZXgobm9kZSldKTtcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb24oYWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoaXNWYWxpZE5vZGUobm9kZSkpIHtcbiAgICAgICAgdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obm9kZSwgYWN0aW9uKTtcbiAgICAgICAgbG9vcEFuZFZlcmlmeShcbiAgICAgICAgICBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICAgIGFjdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldFR5cGVJbmRleCh0YXJnZXQpIHtcbiAgICB2YXJcbiAgICAgIGlzID0gZ2V0QXR0cmlidXRlLmNhbGwodGFyZ2V0LCAnaXMnKSxcbiAgICAgIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCksXG4gICAgICBpID0gaW5kZXhPZi5jYWxsKFxuICAgICAgICB0eXBlcyxcbiAgICAgICAgaXMgP1xuICAgICAgICAgICAgUFJFRklYX0lTICsgaXMudG9VcHBlckNhc2UoKSA6XG4gICAgICAgICAgICBQUkVGSVhfVEFHICsgbm9kZU5hbWVcbiAgICAgIClcbiAgICA7XG4gICAgcmV0dXJuIGlzICYmIC0xIDwgaSAmJiAhaXNJblFTQShub2RlTmFtZSwgaXMpID8gLTEgOiBpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBpc0luUVNBKG5hbWUsIHR5cGUpIHtcbiAgICByZXR1cm4gLTEgPCBxdWVyeS5pbmRleE9mKG5hbWUgKyAnW2lzPVwiJyArIHR5cGUgKyAnXCJdJyk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIG9uRE9NQXR0ck1vZGlmaWVkKGUpIHtcbiAgICB2YXJcbiAgICAgIG5vZGUgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgICBhdHRyQ2hhbmdlID0gZS5hdHRyQ2hhbmdlLFxuICAgICAgYXR0ck5hbWUgPSBlLmF0dHJOYW1lLFxuICAgICAgdGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICBhZGRpdGlvbiA9IGVbQURESVRJT05dIHx8IDIsXG4gICAgICByZW1vdmFsID0gZVtSRU1PVkFMXSB8fCAzXG4gICAgO1xuICAgIGlmIChub3RGcm9tSW5uZXJIVE1MSGVscGVyICYmXG4gICAgICAgICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gbm9kZSkgJiZcbiAgICAgICAgbm9kZVtBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDS10gJiZcbiAgICAgICAgYXR0ck5hbWUgIT09ICdzdHlsZScgJiYgKFxuICAgICAgICAgIGUucHJldlZhbHVlICE9PSBlLm5ld1ZhbHVlIHx8XG4gICAgICAgICAgLy8gSUU5LCBJRTEwLCBhbmQgT3BlcmEgMTIgZ290Y2hhXG4gICAgICAgICAgZS5uZXdWYWx1ZSA9PT0gJycgJiYgKFxuICAgICAgICAgICAgYXR0ckNoYW5nZSA9PT0gYWRkaXRpb24gfHxcbiAgICAgICAgICAgIGF0dHJDaGFuZ2UgPT09IHJlbW92YWxcbiAgICAgICAgICApXG4gICAgKSkge1xuICAgICAgbm9kZVtBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDS10oXG4gICAgICAgIGF0dHJOYW1lLFxuICAgICAgICBhdHRyQ2hhbmdlID09PSBhZGRpdGlvbiA/IG51bGwgOiBlLnByZXZWYWx1ZSxcbiAgICAgICAgYXR0ckNoYW5nZSA9PT0gcmVtb3ZhbCA/IG51bGwgOiBlLm5ld1ZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gb25ET01Ob2RlKGFjdGlvbikge1xuICAgIHZhciBleGVjdXRvciA9IGV4ZWN1dGVBY3Rpb24oYWN0aW9uKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGFzYXBRdWV1ZS5wdXNoKGV4ZWN1dG9yLCBlLnRhcmdldCk7XG4gICAgICBpZiAoYXNhcFRpbWVyKSBjbGVhclRpbWVvdXQoYXNhcFRpbWVyKTtcbiAgICAgIGFzYXBUaW1lciA9IHNldFRpbWVvdXQoQVNBUCwgMSk7XG4gICAgfTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gb25SZWFkeVN0YXRlQ2hhbmdlKGUpIHtcbiAgICBpZiAoZHJvcERvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIGRyb3BEb21Db250ZW50TG9hZGVkID0gZmFsc2U7XG4gICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihET01fQ09OVEVOVF9MT0FERUQsIG9uUmVhZHlTdGF0ZUNoYW5nZSk7XG4gICAgfVxuICAgIGxvb3BBbmRWZXJpZnkoXG4gICAgICAoZS50YXJnZXQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgZS5kZXRhaWwgPT09IERFVEFDSEVEID8gREVUQUNIRUQgOiBBVFRBQ0hFRFxuICAgICk7XG4gICAgaWYgKElFOCkgcHVyZ2UoKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGF0Y2hlZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIC8vIGpzaGludCB2YWxpZHRoaXM6dHJ1ZVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRBdHRyaWJ1dGUuY2FsbChzZWxmLCBuYW1lLCB2YWx1ZSk7XG4gICAgb25TdWJ0cmVlTW9kaWZpZWQuY2FsbChzZWxmLCB7dGFyZ2V0OiBzZWxmfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHNldHVwTm9kZShub2RlLCBwcm90bykge1xuICAgIHNldFByb3RvdHlwZShub2RlLCBwcm90byk7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIGF0dHJpYnV0ZXNPYnNlcnZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSA9IHBhdGNoZWRTZXRBdHRyaWJ1dGU7XG4gICAgICAgIG5vZGVbRVhQQU5ET19VSURdID0gZ2V0QXR0cmlidXRlc01pcnJvcihub2RlKTtcbiAgICAgICAgbm9kZVtBRERfRVZFTlRfTElTVEVORVJdKERPTV9TVUJUUkVFX01PRElGSUVELCBvblN1YnRyZWVNb2RpZmllZCk7XG4gICAgICB9XG4gICAgICBub2RlW0FERF9FVkVOVF9MSVNURU5FUl0oRE9NX0FUVFJfTU9ESUZJRUQsIG9uRE9NQXR0ck1vZGlmaWVkKTtcbiAgICB9XG4gICAgaWYgKG5vZGVbQ1JFQVRFRF9DQUxMQkFDS10gJiYgbm90RnJvbUlubmVySFRNTEhlbHBlcikge1xuICAgICAgbm9kZS5jcmVhdGVkID0gdHJ1ZTtcbiAgICAgIG5vZGVbQ1JFQVRFRF9DQUxMQkFDS10oKTtcbiAgICAgIG5vZGUuY3JlYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gcHVyZ2UoKSB7XG4gICAgZm9yICh2YXJcbiAgICAgIG5vZGUsXG4gICAgICBpID0gMCxcbiAgICAgIGxlbmd0aCA9IHRhcmdldHMubGVuZ3RoO1xuICAgICAgaSA8IGxlbmd0aDsgaSsrXG4gICAgKSB7XG4gICAgICBub2RlID0gdGFyZ2V0c1tpXTtcbiAgICAgIGlmICghZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB2ZXJpZnlBbmRTZXR1cEFuZEFjdGlvbihub2RlLCBERVRBQ0hFRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiB0aHJvd1R5cGVFcnJvcih0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBICcgKyB0eXBlICsgJyB0eXBlIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICB9XG4gIFxuICBmdW5jdGlvbiB2ZXJpZnlBbmRTZXR1cEFuZEFjdGlvbihub2RlLCBhY3Rpb24pIHtcbiAgICB2YXJcbiAgICAgIGZuLFxuICAgICAgaSA9IGdldFR5cGVJbmRleChub2RlKVxuICAgIDtcbiAgICBpZiAoLTEgPCBpKSB7XG4gICAgICBwYXRjaElmTm90QWxyZWFkeShub2RlLCBwcm90b3NbaV0pO1xuICAgICAgaSA9IDA7XG4gICAgICBpZiAoYWN0aW9uID09PSBBVFRBQ0hFRCAmJiAhbm9kZVtBVFRBQ0hFRF0pIHtcbiAgICAgICAgbm9kZVtERVRBQ0hFRF0gPSBmYWxzZTtcbiAgICAgICAgbm9kZVtBVFRBQ0hFRF0gPSB0cnVlO1xuICAgICAgICBpID0gMTtcbiAgICAgICAgaWYgKElFOCAmJiBpbmRleE9mLmNhbGwodGFyZ2V0cywgbm9kZSkgPCAwKSB7XG4gICAgICAgICAgdGFyZ2V0cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gREVUQUNIRUQgJiYgIW5vZGVbREVUQUNIRURdKSB7XG4gICAgICAgIG5vZGVbQVRUQUNIRURdID0gZmFsc2U7XG4gICAgICAgIG5vZGVbREVUQUNIRURdID0gdHJ1ZTtcbiAgICAgICAgaSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoaSAmJiAoZm4gPSBub2RlW2FjdGlvbiArIENBTExCQUNLXSkpIGZuLmNhbGwobm9kZSk7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgXG4gIC8vIFYxIGluIGRhIEhvdXNlIVxuICBmdW5jdGlvbiBDdXN0b21FbGVtZW50UmVnaXN0cnkoKSB7fVxuICBcbiAgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LFxuICAgIC8vIGEgd29ya2Fyb3VuZCBmb3IgdGhlIHN0dWJib3JuIFdlYktpdFxuICAgIGRlZmluZTogdXNhYmxlQ3VzdG9tRWxlbWVudHMgP1xuICAgICAgZnVuY3Rpb24gKG5hbWUsIENsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgQ0VSRGVmaW5lKG5hbWUsIENsYXNzLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgTkFNRSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBjb25zdHJ1Y3RvcnNbTkFNRV0gPSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogQ2xhc3MsXG4gICAgICAgICAgICBjcmVhdGU6IFtOQU1FXVxuICAgICAgICAgIH07XG4gICAgICAgICAgbm9kZU5hbWVzLnNldChDbGFzcywgTkFNRSk7XG4gICAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKG5hbWUsIENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSA6XG4gICAgICBDRVJEZWZpbmUsXG4gICAgZ2V0OiB1c2FibGVDdXN0b21FbGVtZW50cyA/XG4gICAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY3VzdG9tRWxlbWVudHMuZ2V0KG5hbWUpIHx8IGdldChuYW1lKTtcbiAgICAgIH0gOlxuICAgICAgZ2V0LFxuICAgIHdoZW5EZWZpbmVkOiB1c2FibGVDdXN0b21FbGVtZW50cyA/XG4gICAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChuYW1lKSxcbiAgICAgICAgICB3aGVuRGVmaW5lZChuYW1lKVxuICAgICAgICBdKTtcbiAgICAgIH0gOlxuICAgICAgd2hlbkRlZmluZWRcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIENFUkRlZmluZShuYW1lLCBDbGFzcywgb3B0aW9ucykge1xuICAgIHZhclxuICAgICAgaXMgPSBvcHRpb25zICYmIG9wdGlvbnNbRVhURU5EU10gfHwgJycsXG4gICAgICBDUHJvdG8gPSBDbGFzcy5wcm90b3R5cGUsXG4gICAgICBwcm90byA9IGNyZWF0ZShDUHJvdG8pLFxuICAgICAgYXR0cmlidXRlcyA9IENsYXNzLm9ic2VydmVkQXR0cmlidXRlcyB8fCBlbXB0eSxcbiAgICAgIGRlZmluaXRpb24gPSB7cHJvdG90eXBlOiBwcm90b31cbiAgICA7XG4gICAgLy8gVE9ETzogaXMgdGhpcyBuZWVkZWQgYXQgYWxsIHNpbmNlIGl0J3MgaW5oZXJpdGVkP1xuICAgIC8vIGRlZmluZVByb3BlcnR5KHByb3RvLCAnY29uc3RydWN0b3InLCB7dmFsdWU6IENsYXNzfSk7XG4gICAgc2FmZVByb3BlcnR5KHByb3RvLCBDUkVBVEVEX0NBTExCQUNLLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGp1c3RDcmVhdGVkKSBqdXN0Q3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgaWYgKCF0aGlzW0RSRUNFVjFdKSB7XG4gICAgICAgICAgICB0aGlzW0RSRUNFVjFdID0gdHJ1ZTtcbiAgICAgICAgICAgIG5ldyBDbGFzcyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChDUHJvdG9bQ1JFQVRFRF9DQUxMQkFDS10pXG4gICAgICAgICAgICAgIENQcm90b1tDUkVBVEVEX0NBTExCQUNLXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBjb25zdHJ1Y3RvcnNbbm9kZU5hbWVzLmdldChDbGFzcyldO1xuICAgICAgICAgICAgaWYgKCF1c2FibGVDdXN0b21FbGVtZW50cyB8fCBpbmZvLmNyZWF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIG5vdGlmeUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHNhZmVQcm9wZXJ0eShwcm90bywgQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0ssIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoLTEgPCBpbmRleE9mLmNhbGwoYXR0cmlidXRlcywgbmFtZSkpXG4gICAgICAgICAgQ1Byb3RvW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChDUHJvdG9bQ09OTkVDVEVEX0NBTExCQUNLXSkge1xuICAgICAgc2FmZVByb3BlcnR5KHByb3RvLCBBVFRBQ0hFRF9DQUxMQkFDSywge1xuICAgICAgICB2YWx1ZTogQ1Byb3RvW0NPTk5FQ1RFRF9DQUxMQkFDS11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoQ1Byb3RvW0RJU0NPTk5FQ1RFRF9DQUxMQkFDS10pIHtcbiAgICAgIHNhZmVQcm9wZXJ0eShwcm90bywgREVUQUNIRURfQ0FMTEJBQ0ssIHtcbiAgICAgICAgdmFsdWU6IENQcm90b1tESVNDT05ORUNURURfQ0FMTEJBQ0tdXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzKSBkZWZpbml0aW9uW0VYVEVORFNdID0gaXM7XG4gICAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdHJ1Y3RvcnNbbmFtZV0gPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogQ2xhc3MsXG4gICAgICBjcmVhdGU6IGlzID8gW2lzLCBzZWNvbmRBcmd1bWVudChuYW1lKV0gOiBbbmFtZV1cbiAgICB9O1xuICAgIG5vZGVOYW1lcy5zZXQoQ2xhc3MsIG5hbWUpO1xuICAgIGRvY3VtZW50W1JFR0lTVEVSX0VMRU1FTlRdKG5hbWUudG9Mb3dlckNhc2UoKSwgZGVmaW5pdGlvbik7XG4gICAgd2hlbkRlZmluZWQobmFtZSk7XG4gICAgd2FpdGluZ0xpc3RbbmFtZV0ucigpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHZhciBpbmZvID0gY29uc3RydWN0b3JzW25hbWUudG9VcHBlckNhc2UoKV07XG4gICAgcmV0dXJuIGluZm8gJiYgaW5mby5jb25zdHJ1Y3RvcjtcbiAgfVxuICBcbiAgZnVuY3Rpb24gZ2V0SXMob3B0aW9ucykge1xuICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgP1xuICAgICAgICBvcHRpb25zIDogKG9wdGlvbnMgJiYgb3B0aW9ucy5pcyB8fCAnJyk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIG5vdGlmeUF0dHJpYnV0ZXMoc2VsZikge1xuICAgIHZhclxuICAgICAgY2FsbGJhY2sgPSBzZWxmW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBjYWxsYmFjayA/IHNlbGYuYXR0cmlidXRlcyA6IGVtcHR5LFxuICAgICAgaSA9IGF0dHJpYnV0ZXMubGVuZ3RoLFxuICAgICAgYXR0cmlidXRlXG4gICAgO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGF0dHJpYnV0ZSA9ICBhdHRyaWJ1dGVzW2ldOyAvLyB8fCBhdHRyaWJ1dGVzLml0ZW0oaSk7XG4gICAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgICBzZWxmLFxuICAgICAgICBhdHRyaWJ1dGUubmFtZSB8fCBhdHRyaWJ1dGUubm9kZU5hbWUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSB8fCBhdHRyaWJ1dGUubm9kZVZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gd2hlbkRlZmluZWQobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCEobmFtZSBpbiB3YWl0aW5nTGlzdCkpIHtcbiAgICAgIHdhaXRpbmdMaXN0W25hbWVdID0ge307XG4gICAgICB3YWl0aW5nTGlzdFtuYW1lXS5wID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgd2FpdGluZ0xpc3RbbmFtZV0uciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdhaXRpbmdMaXN0W25hbWVdLnA7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBvbHlmaWxsVjEoKSB7XG4gICAgaWYgKGN1c3RvbUVsZW1lbnRzKSBkZWxldGUgd2luZG93LmN1c3RvbUVsZW1lbnRzO1xuICAgIGRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2N1c3RvbUVsZW1lbnRzJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG5ldyBDdXN0b21FbGVtZW50UmVnaXN0cnkoKVxuICAgIH0pO1xuICAgIGRlZmluZVByb3BlcnR5KHdpbmRvdywgJ0N1c3RvbUVsZW1lbnRSZWdpc3RyeScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBDdXN0b21FbGVtZW50UmVnaXN0cnlcbiAgICB9KTtcbiAgICBmb3IgKHZhclxuICAgICAgcGF0Y2hDbGFzcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBDbGFzcyA9IHdpbmRvd1tuYW1lXTtcbiAgICAgICAgaWYgKENsYXNzKSB7XG4gICAgICAgICAgd2luZG93W25hbWVdID0gZnVuY3Rpb24gQ3VzdG9tRWxlbWVudHNWMShzZWxmKSB7XG4gICAgICAgICAgICB2YXIgaW5mbywgaXNOYXRpdmU7XG4gICAgICAgICAgICBpZiAoIXNlbGYpIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFzZWxmW0RSRUNFVjFdKSB7XG4gICAgICAgICAgICAgIGp1c3RDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaW5mbyA9IGNvbnN0cnVjdG9yc1tub2RlTmFtZXMuZ2V0KHNlbGYuY29uc3RydWN0b3IpXTtcbiAgICAgICAgICAgICAgaXNOYXRpdmUgPSB1c2FibGVDdXN0b21FbGVtZW50cyAmJiBpbmZvLmNyZWF0ZS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICAgIHNlbGYgPSBpc05hdGl2ZSA/XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQ2xhc3MsIGVtcHR5LCBpbmZvLmNvbnN0cnVjdG9yKSA6XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseShkb2N1bWVudCwgaW5mby5jcmVhdGUpO1xuICAgICAgICAgICAgICBzZWxmW0RSRUNFVjFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAganVzdENyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKCFpc05hdGl2ZSkgbm90aWZ5QXR0cmlidXRlcyhzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2luZG93W25hbWVdLnByb3RvdHlwZSA9IENsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gd2luZG93W25hbWVdO1xuICAgICAgICAgIH0gY2F0Y2goV2ViS2l0KSB7XG4gICAgICAgICAgICBmaXhHZXRDbGFzcyA9IHRydWU7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShDbGFzcywgRFJFQ0VWMSwge3ZhbHVlOiB3aW5kb3dbbmFtZV19KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDbGFzc2VzID0gaHRtbENsYXNzLmdldCgvXkhUTUxbQS1aXSpbYS16XS8pLFxuICAgICAgaSA9IENsYXNzZXMubGVuZ3RoO1xuICAgICAgaS0tO1xuICAgICAgcGF0Y2hDbGFzcyhDbGFzc2VzW2ldKVxuICAgICkge31cbiAgICAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaXMgPSBnZXRJcyhvcHRpb25zKTtcbiAgICAgIHJldHVybiBpcyA/XG4gICAgICAgIHBhdGNoZWRDcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbmFtZSwgc2Vjb25kQXJndW1lbnQoaXMpKSA6XG4gICAgICAgIHBhdGNoZWRDcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIGlmIGN1c3RvbUVsZW1lbnRzIGlzIG5vdCB0aGVyZSBhdCBhbGxcbiAgaWYgKCFjdXN0b21FbGVtZW50cykgcG9seWZpbGxWMSgpO1xuICBlbHNlIHtcbiAgICAvLyBpZiBhdmFpbGFibGUgdGVzdCBleHRlbmRzIHdvcmsgYXMgZXhwZWN0ZWRcbiAgICB0cnkge1xuICAgICAgKGZ1bmN0aW9uIChEUkUsIG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgb3B0aW9uc1tFWFRFTkRTXSA9ICdhJztcbiAgICAgICAgRFJFLnByb3RvdHlwZSA9IGNyZWF0ZShIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICBEUkUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRFJFO1xuICAgICAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKG5hbWUsIERSRSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBnZXRBdHRyaWJ1dGUuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJywge2lzOiBuYW1lfSksICdpcycpICE9PSBuYW1lIHx8XG4gICAgICAgICAgKHVzYWJsZUN1c3RvbUVsZW1lbnRzICYmIGdldEF0dHJpYnV0ZS5jYWxsKG5ldyBEUkUoKSwgJ2lzJykgIT09IG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH0oXG4gICAgICAgIGZ1bmN0aW9uIERSRSgpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoSFRNTEFuY2hvckVsZW1lbnQsIFtdLCBEUkUpO1xuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgICAgJ2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQtYSdcbiAgICAgICkpO1xuICAgIH0gY2F0Y2gob19PKSB7XG4gICAgICAvLyBvciBmb3JjZSB0aGUgcG9seWZpbGwgaWYgbm90XG4gICAgICAvLyBhbmQga2VlcCBpbnRlcm5hbCBvcmlnaW5hbCByZWZlcmVuY2VcbiAgICAgIHBvbHlmaWxsVjEoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCAnYScsICdhJyk7XG4gIH0gY2F0Y2goRmlyZUZveCkge1xuICAgIHNlY29uZEFyZ3VtZW50ID0gZnVuY3Rpb24gKGlzKSB7XG4gICAgICByZXR1cm4ge2lzOiBpc307XG4gICAgfTtcbiAgfVxuICBcbn0od2luZG93KSk7XG4iLCI7KGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBAcHJlc2VydmUgRmFzdENsaWNrOiBwb2x5ZmlsbCB0byByZW1vdmUgY2xpY2sgZGVsYXlzIG9uIGJyb3dzZXJzIHdpdGggdG91Y2ggVUlzLlxuXHQgKlxuXHQgKiBAY29kaW5nc3RhbmRhcmQgZnRsYWJzLWpzdjJcblx0ICogQGNvcHlyaWdodCBUaGUgRmluYW5jaWFsIFRpbWVzIExpbWl0ZWQgW0FsbCBSaWdodHMgUmVzZXJ2ZWRdXG5cdCAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChzZWUgTElDRU5TRS50eHQpXG5cdCAqL1xuXG5cdC8qanNsaW50IGJyb3dzZXI6dHJ1ZSwgbm9kZTp0cnVlKi9cblx0LypnbG9iYWwgZGVmaW5lLCBFdmVudCwgTm9kZSovXG5cblxuXHQvKipcblx0ICogSW5zdGFudGlhdGUgZmFzdC1jbGlja2luZyBsaXN0ZW5lcnMgb24gdGhlIHNwZWNpZmllZCBsYXllci5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0ZnVuY3Rpb24gRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0dmFyIG9sZE9uQ2xpY2s7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgYSBjbGljayBpcyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGltZXN0YW1wIGZvciB3aGVuIGNsaWNrIHRyYWNraW5nIHN0YXJ0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbGVtZW50IGJlaW5nIHRyYWNrZWQgZm9yIGEgY2xpY2suXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFdmVudFRhcmdldFxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFgtY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFggPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBZLWNvb3JkaW5hdGUgb2YgdG91Y2ggc3RhcnQgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogSUQgb2YgdGhlIGxhc3QgdG91Y2gsIHJldHJpZXZlZCBmcm9tIFRvdWNoLmlkZW50aWZpZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUb3VjaG1vdmUgYm91bmRhcnksIGJleW9uZCB3aGljaCBhIGNsaWNrIHdpbGwgYmUgY2FuY2VsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaEJvdW5kYXJ5ID0gb3B0aW9ucy50b3VjaEJvdW5kYXJ5IHx8IDEwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgRmFzdENsaWNrIGxheWVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiB0YXAodG91Y2hzdGFydCBhbmQgdG91Y2hlbmQpIGV2ZW50c1xuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBEZWxheSA9IG9wdGlvbnMudGFwRGVsYXkgfHwgMjAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gdGltZSBmb3IgYSB0YXBcblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudGFwVGltZW91dCA9IG9wdGlvbnMudGFwVGltZW91dCB8fCA3MDA7XG5cblx0XHRpZiAoRmFzdENsaWNrLm5vdE5lZWRlZChsYXllcikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBBbmRyb2lkIGRvbid0IGhhdmUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblx0XHRmdW5jdGlvbiBiaW5kKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7IH07XG5cdFx0fVxuXG5cblx0XHR2YXIgbWV0aG9kcyA9IFsnb25Nb3VzZScsICdvbkNsaWNrJywgJ29uVG91Y2hTdGFydCcsICdvblRvdWNoTW92ZScsICdvblRvdWNoRW5kJywgJ29uVG91Y2hDYW5jZWwnXTtcblx0XHR2YXIgY29udGV4dCA9IHRoaXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtZXRob2RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29udGV4dFttZXRob2RzW2ldXSA9IGJpbmQoY29udGV4dFttZXRob2RzW2ldXSwgY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGV2ZW50IGhhbmRsZXJzIGFzIHJlcXVpcmVkXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblxuXHRcdC8vIEhhY2sgaXMgcmVxdWlyZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdC8vIHdoaWNoIGlzIGhvdyBGYXN0Q2xpY2sgbm9ybWFsbHkgc3RvcHMgY2xpY2sgZXZlbnRzIGJ1YmJsaW5nIHRvIGNhbGxiYWNrcyByZWdpc3RlcmVkIG9uIHRoZSBGYXN0Q2xpY2tcblx0XHQvLyBsYXllciB3aGVuIHRoZXkgYXJlIGNhbmNlbGxlZC5cblx0XHRpZiAoIUV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgcm12ID0gTm9kZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRybXYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgYWR2ID0gTm9kZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgKGNhbGxiYWNrLmhpamFja2VkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmICghZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSwgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWR2LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBJZiBhIGhhbmRsZXIgaXMgYWxyZWFkeSBkZWNsYXJlZCBpbiB0aGUgZWxlbWVudCdzIG9uY2xpY2sgYXR0cmlidXRlLCBpdCB3aWxsIGJlIGZpcmVkIGJlZm9yZVxuXHRcdC8vIEZhc3RDbGljaydzIG9uQ2xpY2sgaGFuZGxlci4gRml4IHRoaXMgYnkgcHVsbGluZyBvdXQgdGhlIHVzZXItZGVmaW5lZCBoYW5kbGVyIGZ1bmN0aW9uIGFuZFxuXHRcdC8vIGFkZGluZyBpdCBhcyBsaXN0ZW5lci5cblx0XHRpZiAodHlwZW9mIGxheWVyLm9uY2xpY2sgPT09ICdmdW5jdGlvbicpIHtcblxuXHRcdFx0Ly8gQW5kcm9pZCBicm93c2VyIG9uIGF0IGxlYXN0IDMuMiByZXF1aXJlcyBhIG5ldyByZWZlcmVuY2UgdG8gdGhlIGZ1bmN0aW9uIGluIGxheWVyLm9uY2xpY2tcblx0XHRcdC8vIC0gdGhlIG9sZCBvbmUgd29uJ3Qgd29yayBpZiBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lciBkaXJlY3RseS5cblx0XHRcdG9sZE9uQ2xpY2sgPSBsYXllci5vbmNsaWNrO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRvbGRPbkNsaWNrKGV2ZW50KTtcblx0XHRcdH0sIGZhbHNlKTtcblx0XHRcdGxheWVyLm9uY2xpY2sgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIFdpbmRvd3MgUGhvbmUgOC4xIGZha2VzIHVzZXIgYWdlbnQgc3RyaW5nIHRvIGxvb2sgbGlrZSBBbmRyb2lkIGFuZCBpUGhvbmUuXG5cdCpcblx0KiBAdHlwZSBib29sZWFuXG5cdCovXG5cdHZhciBkZXZpY2VJc1dpbmRvd3NQaG9uZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIikgPj0gMDtcblxuXHQvKipcblx0ICogQW5kcm9pZCByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPiAwICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TID0gL2lQKGFkfGhvbmV8b2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNCByZXF1aXJlcyBhbiBleGNlcHRpb24gZm9yIHNlbGVjdCBlbGVtZW50cy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TNCA9IGRldmljZUlzSU9TICYmICgvT1MgNF9cXGQoX1xcZCk/LykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNi4wLTcuKiByZXF1aXJlcyB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gYmUgbWFudWFsbHkgZGVyaXZlZFxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyBbNi03XV9cXGQvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdC8qKlxuXHQgKiBCbGFja0JlcnJ5IHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0JsYWNrQmVycnkxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQkIxMCcpID4gMDtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgbmF0aXZlIGNsaWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBuZWVkcyBhIG5hdGl2ZSBjbGlja1xuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0NsaWNrID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2VuZCBhIHN5bnRoZXRpYyBjbGljayB0byBkaXNhYmxlZCBpbnB1dHMgKGlzc3VlICM2Milcblx0XHRjYXNlICdidXR0b24nOlxuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0aWYgKHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaW5wdXQnOlxuXG5cdFx0XHQvLyBGaWxlIGlucHV0cyBuZWVkIHJlYWwgY2xpY2tzIG9uIGlPUyA2IGR1ZSB0byBhIGJyb3dzZXIgYnVnIChpc3N1ZSAjNjgpXG5cdFx0XHRpZiAoKGRldmljZUlzSU9TICYmIHRhcmdldC50eXBlID09PSAnZmlsZScpIHx8IHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGFiZWwnOlxuXHRcdGNhc2UgJ2lmcmFtZSc6IC8vIGlPUzggaG9tZXNjcmVlbiBhcHBzIGNhbiBwcmV2ZW50IGV2ZW50cyBidWJibGluZyBpbnRvIGZyYW1lc1xuXHRcdGNhc2UgJ3ZpZGVvJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiAoL1xcYm5lZWRzY2xpY2tcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgY2xpY2sgaW50byBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgbmF0aXZlIGNsaWNrLlxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0ZvY3VzID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdGNhc2UgJ3RleHRhcmVhJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0XHRyZXR1cm4gIWRldmljZUlzQW5kcm9pZDtcblx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRzd2l0Y2ggKHRhcmdldC50eXBlKSB7XG5cdFx0XHRjYXNlICdidXR0b24nOlxuXHRcdFx0Y2FzZSAnY2hlY2tib3gnOlxuXHRcdFx0Y2FzZSAnZmlsZSc6XG5cdFx0XHRjYXNlICdpbWFnZSc6XG5cdFx0XHRjYXNlICdyYWRpbyc6XG5cdFx0XHRjYXNlICdzdWJtaXQnOlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vIHBvaW50IGluIGF0dGVtcHRpbmcgdG8gZm9jdXMgZGlzYWJsZWQgaW5wdXRzXG5cdFx0XHRyZXR1cm4gIXRhcmdldC5kaXNhYmxlZCAmJiAhdGFyZ2V0LnJlYWRPbmx5O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKC9cXGJuZWVkc2ZvY3VzXFxiLykudGVzdCh0YXJnZXQuY2xhc3NOYW1lKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogU2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnNlbmRDbGljayA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQsIGV2ZW50KSB7XG5cdFx0dmFyIGNsaWNrRXZlbnQsIHRvdWNoO1xuXG5cdFx0Ly8gT24gc29tZSBBbmRyb2lkIGRldmljZXMgYWN0aXZlRWxlbWVudCBuZWVkcyB0byBiZSBibHVycmVkIG90aGVyd2lzZSB0aGUgc3ludGhldGljIGNsaWNrIHdpbGwgaGF2ZSBubyBlZmZlY3QgKCMyNClcblx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0YXJnZXRFbGVtZW50KSB7XG5cdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblx0XHR9XG5cblx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gU3ludGhlc2l6ZSBhIGNsaWNrIGV2ZW50LCB3aXRoIGFuIGV4dHJhIGF0dHJpYnV0ZSBzbyBpdCBjYW4gYmUgdHJhY2tlZFxuXHRcdGNsaWNrRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0XHRjbGlja0V2ZW50LmluaXRNb3VzZUV2ZW50KHRoaXMuZGV0ZXJtaW5lRXZlbnRUeXBlKHRhcmdldEVsZW1lbnQpLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIHRvdWNoLnNjcmVlblgsIHRvdWNoLnNjcmVlblksIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblx0XHRjbGlja0V2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQgPSB0cnVlO1xuXHRcdHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcblx0fTtcblxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRldGVybWluZUV2ZW50VHlwZSA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblxuXHRcdC8vSXNzdWUgIzE1OTogQW5kcm9pZCBDaHJvbWUgU2VsZWN0IEJveCBkb2VzIG5vdCBvcGVuIHdpdGggYSBzeW50aGV0aWMgY2xpY2sgZXZlbnRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkICYmIHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xuXHRcdFx0cmV0dXJuICdtb3VzZWRvd24nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnY2xpY2snO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgbGVuZ3RoO1xuXG5cdFx0Ly8gSXNzdWUgIzE2MDogb24gaU9TIDcsIHNvbWUgaW5wdXQgZWxlbWVudHMgKGUuZy4gZGF0ZSBkYXRldGltZSBtb250aCkgdGhyb3cgYSB2YWd1ZSBUeXBlRXJyb3Igb24gc2V0U2VsZWN0aW9uUmFuZ2UuIFRoZXNlIGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gaW50ZWdlciB2YWx1ZSBmb3IgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgcHJvcGVydGllcywgYnV0IHVuZm9ydHVuYXRlbHkgdGhhdCBjYW4ndCBiZSB1c2VkIGZvciBkZXRlY3Rpb24gYmVjYXVzZSBhY2Nlc3NpbmcgdGhlIHByb3BlcnRpZXMgYWxzbyB0aHJvd3MgYSBUeXBlRXJyb3IuIEp1c3QgY2hlY2sgdGhlIHR5cGUgaW5zdGVhZC4gRmlsZWQgYXMgQXBwbGUgYnVnICMxNTEyMjcyNC5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSAmJiB0YXJnZXRFbGVtZW50LnR5cGUuaW5kZXhPZignZGF0ZScpICE9PSAwICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ3RpbWUnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ21vbnRoJykge1xuXHRcdFx0bGVuZ3RoID0gdGFyZ2V0RWxlbWVudC52YWx1ZS5sZW5ndGg7XG5cdFx0XHR0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciBhbmQgaWYgc28sIHNldCBhIGZsYWcgb24gaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS51cGRhdGVTY3JvbGxQYXJlbnQgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudCwgcGFyZW50RWxlbWVudDtcblxuXHRcdHNjcm9sbFBhcmVudCA9IHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkaXNjb3ZlciB3aGV0aGVyIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgc2Nyb2xsYWJsZSBsYXllci4gUmUtY2hlY2sgaWYgdGhlXG5cdFx0Ly8gdGFyZ2V0IGVsZW1lbnQgd2FzIG1vdmVkIHRvIGFub3RoZXIgcGFyZW50LlxuXHRcdGlmICghc2Nyb2xsUGFyZW50IHx8ICFzY3JvbGxQYXJlbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdHBhcmVudEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAocGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodCkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSBwYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdH0gd2hpbGUgKHBhcmVudEVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdC8vIEFsd2F5cyB1cGRhdGUgdGhlIHNjcm9sbCB0b3AgdHJhY2tlciBpZiBwb3NzaWJsZS5cblx0XHRpZiAoc2Nyb2xsUGFyZW50KSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQuZmFzdENsaWNrTGFzdFNjcm9sbFRvcCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQgPSBmdW5jdGlvbihldmVudFRhcmdldCkge1xuXG5cdFx0Ly8gT24gc29tZSBvbGRlciBicm93c2VycyAobm90YWJseSBTYWZhcmkgb24gaU9TIDQuMSAtIHNlZSBpc3N1ZSAjNTYpIHRoZSBldmVudCB0YXJnZXQgbWF5IGJlIGEgdGV4dCBub2RlLlxuXHRcdGlmIChldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdHJldHVybiBldmVudFRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudFRhcmdldDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBzdGFydCwgcmVjb3JkIHRoZSBwb3NpdGlvbiBhbmQgc2Nyb2xsIG9mZnNldC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldEVsZW1lbnQsIHRvdWNoLCBzZWxlY3Rpb247XG5cblx0XHQvLyBJZ25vcmUgbXVsdGlwbGUgdG91Y2hlcywgb3RoZXJ3aXNlIHBpbmNoLXRvLXpvb20gaXMgcHJldmVudGVkIGlmIGJvdGggZmluZ2VycyBhcmUgb24gdGhlIEZhc3RDbGljayBlbGVtZW50IChpc3N1ZSAjMTExKS5cblx0XHRpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cdFx0dG91Y2ggPSBldmVudC50YXJnZXRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gSWdub3JlIHRvdWNoZXMgb24gY29udGVudGVkaXRhYmxlIGVsZW1lbnRzIHRvIHByZXZlbnQgY29uZmxpY3Qgd2l0aCB0ZXh0IHNlbGVjdGlvbi5cblx0XHQvLyAoRm9yIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mdGxhYnMvZmFzdGNsaWNrL3B1bGwvMjExIClcblx0XHRpZiAodGFyZ2V0RWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGRldmljZUlzSU9TKSB7XG5cblx0XHRcdC8vIE9ubHkgdHJ1c3RlZCBldmVudHMgd2lsbCBkZXNlbGVjdCB0ZXh0IG9uIGlPUyAoaXNzdWUgIzQ5KVxuXHRcdFx0c2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0aWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdFx0Ly8gV2VpcmQgdGhpbmdzIGhhcHBlbiBvbiBpT1Mgd2hlbiBhbiBhbGVydCBvciBjb25maXJtIGRpYWxvZyBpcyBvcGVuZWQgZnJvbSBhIGNsaWNrIGV2ZW50IGNhbGxiYWNrIChpc3N1ZSAjMjMpOlxuXHRcdFx0XHQvLyB3aGVuIHRoZSB1c2VyIG5leHQgdGFwcyBhbnl3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCBuZXcgdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXG5cdFx0XHRcdC8vIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciBhcyB0aGUgdG91Y2ggZXZlbnQgdGhhdCBwcmV2aW91c2x5IHRyaWdnZXJlZCB0aGUgY2xpY2sgdGhhdCB0cmlnZ2VyZWQgdGhlIGFsZXJ0LlxuXHRcdFx0XHQvLyBTYWRseSwgdGhlcmUgaXMgYW4gaXNzdWUgb24gaU9TIDQgdGhhdCBjYXVzZXMgc29tZSBub3JtYWwgdG91Y2ggZXZlbnRzIHRvIGhhdmUgdGhlIHNhbWUgaWRlbnRpZmllciBhcyBhblxuXHRcdFx0XHQvLyBpbW1lZGlhdGVseSBwcmVjZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXG5cdFx0XHRcdC8vIElzc3VlIDEyMDogdG91Y2guaWRlbnRpZmllciBpcyAwIHdoZW4gQ2hyb21lIGRldiB0b29scyAnRW11bGF0ZSB0b3VjaCBldmVudHMnIGlzIHNldCB3aXRoIGFuIGlPUyBkZXZpY2UgVUEgc3RyaW5nLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYWxsIHRvdWNoIGV2ZW50cyB0byBiZSBpZ25vcmVkLiBBcyB0aGlzIGJsb2NrIG9ubHkgYXBwbGllcyB0byBpT1MsIGFuZCBpT1MgaWRlbnRpZmllcnMgYXJlIGFsd2F5cyBsb25nLFxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXG5cdFx0XHRcdGlmICh0b3VjaC5pZGVudGlmaWVyICYmIHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMubGFzdFRvdWNoSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgKHVzaW5nIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgYW5kOlxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXG5cdFx0XHRcdC8vIDIpIHRoZSB1c2VyIHN0b3BzIHRoZSBmbGluZyBzY3JvbGwgd2l0aCBhbm90aGVyIHRhcFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBldmVudC50YXJnZXQgb2YgdGhlIGxhc3QgJ3RvdWNoZW5kJyBldmVudCB3aWxsIGJlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHVuZGVyIHRoZSB1c2VyJ3MgZmluZ2VyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xuXHRcdFx0XHQvLyBpcyBtYWRlIHRvIGVuc3VyZSB0aGF0IGEgcGFyZW50IGxheWVyIHdhcyBub3Qgc2Nyb2xsZWQgYmVmb3JlIHNlbmRpbmcgYSBzeW50aGV0aWMgY2xpY2sgKGlzc3VlICM0MikuXG5cdFx0XHRcdHRoaXMudXBkYXRlU2Nyb2xsUGFyZW50KHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSBldmVudC50aW1lU3RhbXA7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblxuXHRcdHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBCYXNlZCBvbiBhIHRvdWNobW92ZSBldmVudCBvYmplY3QsIGNoZWNrIHdoZXRoZXIgdGhlIHRvdWNoIGhhcyBtb3ZlZCBwYXN0IGEgYm91bmRhcnkgc2luY2UgaXQgc3RhcnRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnRvdWNoSGFzTW92ZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLCBib3VuZGFyeSA9IHRoaXMudG91Y2hCb3VuZGFyeTtcblxuXHRcdGlmIChNYXRoLmFicyh0b3VjaC5wYWdlWCAtIHRoaXMudG91Y2hTdGFydFgpID4gYm91bmRhcnkgfHwgTWF0aC5hYnModG91Y2gucGFnZVkgLSB0aGlzLnRvdWNoU3RhcnRZKSA+IGJvdW5kYXJ5KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsYXN0IHBvc2l0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgdG91Y2ggaGFzIG1vdmVkLCBjYW5jZWwgdGhlIGNsaWNrIHRyYWNraW5nXG5cdFx0aWYgKHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCkgfHwgdGhpcy50b3VjaEhhc01vdmVkKGV2ZW50KSkge1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gZmluZCB0aGUgbGFiZWxsZWQgY29udHJvbCBmb3IgdGhlIGdpdmVuIGxhYmVsIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8SFRNTExhYmVsRWxlbWVudH0gbGFiZWxFbGVtZW50XG5cdCAqIEByZXR1cm5zIHtFbGVtZW50fG51bGx9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZpbmRDb250cm9sID0gZnVuY3Rpb24obGFiZWxFbGVtZW50KSB7XG5cblx0XHQvLyBGYXN0IHBhdGggZm9yIG5ld2VyIGJyb3dzZXJzIHN1cHBvcnRpbmcgdGhlIEhUTUw1IGNvbnRyb2wgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5jb250cm9sICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsYWJlbEVsZW1lbnQuY29udHJvbDtcblx0XHR9XG5cblx0XHQvLyBBbGwgYnJvd3NlcnMgdW5kZXIgdGVzdCB0aGF0IHN1cHBvcnQgdG91Y2ggZXZlbnRzIGFsc28gc3VwcG9ydCB0aGUgSFRNTDUgaHRtbEZvciBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50Lmh0bWxGb3IpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsYWJlbEVsZW1lbnQuaHRtbEZvcik7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gZm9yIGF0dHJpYnV0ZSBleGlzdHMsIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGZpcnN0IGxhYmVsbGFibGUgZGVzY2VuZGFudCBlbGVtZW50XG5cdFx0Ly8gdGhlIGxpc3Qgb2Ygd2hpY2ggaXMgZGVmaW5lZCBoZXJlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxhYmVsXG5cdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24sIGlucHV0Om5vdChbdHlwZT1oaWRkZW5dKSwga2V5Z2VuLCBtZXRlciwgb3V0cHV0LCBwcm9ncmVzcywgc2VsZWN0LCB0ZXh0YXJlYScpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGVuZCwgZGV0ZXJtaW5lIHdoZXRoZXIgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IGF0IG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZm9yRWxlbWVudCwgdHJhY2tpbmdDbGlja1N0YXJ0LCB0YXJnZXRUYWdOYW1lLCBzY3JvbGxQYXJlbnQsIHRvdWNoLCB0YXJnZXRFbGVtZW50ID0gdGhpcy50YXJnZXRFbGVtZW50O1xuXG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0KSA+IHRoaXMudGFwVGltZW91dCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgdG8gcHJldmVudCB3cm9uZyBjbGljayBjYW5jZWwgb24gaW5wdXQgKGlzc3VlICMxNTYpLlxuXHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gZmFsc2U7XG5cblx0XHR0aGlzLmxhc3RDbGlja1RpbWUgPSBldmVudC50aW1lU3RhbXA7XG5cblx0XHR0cmFja2luZ0NsaWNrU3RhcnQgPSB0aGlzLnRyYWNraW5nQ2xpY2tTdGFydDtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblx0XHQvLyBPbiBzb21lIGlPUyBkZXZpY2VzLCB0aGUgdGFyZ2V0RWxlbWVudCBzdXBwbGllZCB3aXRoIHRoZSBldmVudCBpcyBpbnZhbGlkIGlmIHRoZSBsYXllclxuXHRcdC8vIGlzIHBlcmZvcm1pbmcgYSB0cmFuc2l0aW9uIG9yIHNjcm9sbCwgYW5kIGhhcyB0byBiZSByZS1kZXRlY3RlZCBtYW51YWxseS4gTm90ZSB0aGF0XG5cdFx0Ly8gZm9yIHRoaXMgdG8gZnVuY3Rpb24gY29ycmVjdGx5LCBpdCBtdXN0IGJlIGNhbGxlZCAqYWZ0ZXIqIHRoZSBldmVudCB0YXJnZXQgaXMgY2hlY2tlZCFcblx0XHQvLyBTZWUgaXNzdWUgIzU3OyBhbHNvIGZpbGVkIGFzIHJkYXI6Ly8xMzA0ODU4OSAuXG5cdFx0aWYgKGRldmljZUlzSU9TV2l0aEJhZFRhcmdldCkge1xuXHRcdFx0dG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdFx0Ly8gSW4gY2VydGFpbiBjYXNlcyBhcmd1bWVudHMgb2YgZWxlbWVudEZyb21Qb2ludCBjYW4gYmUgbmVnYXRpdmUsIHNvIHByZXZlbnQgc2V0dGluZyB0YXJnZXRFbGVtZW50IHRvIG51bGxcblx0XHRcdHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCB0b3VjaC5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCkgfHwgdGFyZ2V0RWxlbWVudDtcblx0XHRcdHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50ID0gdGhpcy50YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHR9XG5cblx0XHR0YXJnZXRUYWdOYW1lID0gdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKHRhcmdldFRhZ05hbWUgPT09ICdsYWJlbCcpIHtcblx0XHRcdGZvckVsZW1lbnQgPSB0aGlzLmZpbmRDb250cm9sKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0aWYgKGZvckVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcblx0XHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldEVsZW1lbnQgPSBmb3JFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5uZWVkc0ZvY3VzKHRhcmdldEVsZW1lbnQpKSB7XG5cblx0XHRcdC8vIENhc2UgMTogSWYgdGhlIHRvdWNoIHN0YXJ0ZWQgYSB3aGlsZSBhZ28gKGJlc3QgZ3Vlc3MgaXMgMTAwbXMgYmFzZWQgb24gdGVzdHMgZm9yIGlzc3VlICMzNikgdGhlbiBmb2N1cyB3aWxsIGJlIHRyaWdnZXJlZCBhbnl3YXkuIFJldHVybiBlYXJseSBhbmQgdW5zZXQgdGhlIHRhcmdldCBlbGVtZW50IHJlZmVyZW5jZSBzbyB0aGF0IHRoZSBzdWJzZXF1ZW50IGNsaWNrIHdpbGwgYmUgYWxsb3dlZCB0aHJvdWdoLlxuXHRcdFx0Ly8gQ2FzZSAyOiBXaXRob3V0IHRoaXMgZXhjZXB0aW9uIGZvciBpbnB1dCBlbGVtZW50cyB0YXBwZWQgd2hlbiB0aGUgZG9jdW1lbnQgaXMgY29udGFpbmVkIGluIGFuIGlmcmFtZSwgdGhlbiBhbnkgaW5wdXR0ZWQgdGV4dCB3b24ndCBiZSB2aXNpYmxlIGV2ZW4gdGhvdWdoIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgdXBkYXRlZCBhcyB0aGUgdXNlciB0eXBlcyAoaXNzdWUgIzM3KS5cblx0XHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdHJhY2tpbmdDbGlja1N0YXJ0KSA+IDEwMCB8fCAoZGV2aWNlSXNJT1MgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICYmIHRhcmdldFRhZ05hbWUgPT09ICdpbnB1dCcpKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblxuXHRcdFx0Ly8gU2VsZWN0IGVsZW1lbnRzIG5lZWQgdGhlIGV2ZW50IHRvIGdvIHRocm91Z2ggb24gaU9TIDQsIG90aGVyd2lzZSB0aGUgc2VsZWN0b3IgbWVudSB3b24ndCBvcGVuLlxuXHRcdFx0Ly8gQWxzbyB0aGlzIGJyZWFrcyBvcGVuaW5nIHNlbGVjdHMgd2hlbiBWb2ljZU92ZXIgaXMgYWN0aXZlIG9uIGlPUzYsIGlPUzcgKGFuZCBwb3NzaWJseSBvdGhlcnMpXG5cdFx0XHRpZiAoIWRldmljZUlzSU9TIHx8IHRhcmdldFRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgIWRldmljZUlzSU9TNCkge1xuXG5cdFx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIGV2ZW50IGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgcGFyZW50IGxheWVyIHRoYXQgd2FzIHNjcm9sbGVkXG5cdFx0XHQvLyBhbmQgdGhpcyB0YXAgaXMgYmVpbmcgdXNlZCB0byBzdG9wIHRoZSBzY3JvbGxpbmcgKHVzdWFsbHkgaW5pdGlhdGVkIGJ5IGEgZmxpbmcgLSBpc3N1ZSAjNDIpLlxuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0XHRpZiAoc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wICE9PSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgdGhlIGFjdHVhbCBjbGljayBmcm9tIGdvaW5nIHRob3VnaCAtIHVubGVzcyB0aGUgdGFyZ2V0IG5vZGUgaXMgbWFya2VkIGFzIHJlcXVpcmluZ1xuXHRcdC8vIHJlYWwgY2xpY2tzIG9yIGlmIGl0IGlzIGluIHRoZSB3aGl0ZWxpc3QgaW4gd2hpY2ggY2FzZSBvbmx5IG5vbi1wcm9ncmFtbWF0aWMgY2xpY2tzIGFyZSBwZXJtaXR0ZWQuXG5cdFx0aWYgKCF0aGlzLm5lZWRzQ2xpY2sodGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGNhbmNlbCwgc3RvcCB0cmFja2luZyB0aGUgY2xpY2suXG5cdCAqXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgbW91c2UgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbk1vdXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vIElmIGEgdGFyZ2V0IGVsZW1lbnQgd2FzIG5ldmVyIHNldCAoYmVjYXVzZSBhIHRvdWNoIGV2ZW50IHdhcyBuZXZlciBmaXJlZCkgYWxsb3cgdGhlIGV2ZW50XG5cdFx0aWYgKCF0aGlzLnRhcmdldEVsZW1lbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5mb3J3YXJkZWRUb3VjaEV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcm9ncmFtbWF0aWNhbGx5IGdlbmVyYXRlZCBldmVudHMgdGFyZ2V0aW5nIGEgc3BlY2lmaWMgZWxlbWVudCBzaG91bGQgYmUgcGVybWl0dGVkXG5cdFx0aWYgKCFldmVudC5jYW5jZWxhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBEZXJpdmUgYW5kIGNoZWNrIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzZWUgd2hldGhlciB0aGUgbW91c2UgZXZlbnQgbmVlZHMgdG8gYmUgcGVybWl0dGVkO1xuXHRcdC8vIHVubGVzcyBleHBsaWNpdGx5IGVuYWJsZWQsIHByZXZlbnQgbm9uLXRvdWNoIGNsaWNrIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgYWN0aW9ucyxcblx0XHQvLyB0byBwcmV2ZW50IGdob3N0L2RvdWJsZWNsaWNrcy5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0aGlzLnRhcmdldEVsZW1lbnQpIHx8IHRoaXMuY2FuY2VsTmV4dENsaWNrKSB7XG5cblx0XHRcdC8vIFByZXZlbnQgYW55IHVzZXItYWRkZWQgbGlzdGVuZXJzIGRlY2xhcmVkIG9uIEZhc3RDbGljayBlbGVtZW50IGZyb20gYmVpbmcgZmlyZWQuXG5cdFx0XHRpZiAoZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBQYXJ0IG9mIHRoZSBoYWNrIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIChlLmcuIEFuZHJvaWQgMilcblx0XHRcdFx0ZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FuY2VsIHRoZSBldmVudFxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1vdXNlIGV2ZW50IGlzIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiBhY3R1YWwgY2xpY2tzLCBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgdG91Y2gtZ2VuZXJhdGVkIGNsaWNrLCBhIGNsaWNrIGFjdGlvbiBvY2N1cnJpbmdcblx0ICogbmF0dXJhbGx5IGFmdGVyIGEgZGVsYXkgYWZ0ZXIgYSB0b3VjaCAod2hpY2ggbmVlZHMgdG8gYmUgY2FuY2VsbGVkIHRvIGF2b2lkIGR1cGxpY2F0aW9uKSwgb3Jcblx0ICogYW4gYWN0dWFsIGNsaWNrIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcGVybWl0dGVkO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3IgYW5vdGhlciBGYXN0Q2xpY2stbGlrZSBsaWJyYXJ5IGRlbGl2ZXJlZCB3aXRoIHRoaXJkLXBhcnR5IGNvZGUgdG8gZmlyZSBhIGNsaWNrIGV2ZW50IGJlZm9yZSBGYXN0Q2xpY2sgZG9lcyAoaXNzdWUgIzQ0KS4gSW4gdGhhdCBjYXNlLCBzZXQgdGhlIGNsaWNrLXRyYWNraW5nIGZsYWcgYmFjayB0byBmYWxzZSBhbmQgcmV0dXJuIGVhcmx5LiBUaGlzIHdpbGwgY2F1c2Ugb25Ub3VjaEVuZCB0byByZXR1cm4gZWFybHkuXG5cdFx0aWYgKHRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVmVyeSBvZGQgYmVoYXZpb3Igb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIG5vbi1wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9IaDc2NzMxMy5hc3B4XG5cdFx0aWYgKGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgRmFzdENsaWNrIG9iamVjdFxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHNcblx0ICovXG5cdEZhc3RDbGljay5hdHRhY2ggPSBmdW5jdGlvbihsYXllciwgb3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKTtcblx0fTtcblxuICB3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xufSgpKTtcbiIsIi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50L2lzc3Vlcy8yMSNpc3N1ZWNvbW1lbnQtMTAyMDIwMzExXG52YXIgaW5uZXJIVE1MID0gKGZ1bmN0aW9uIChkb2N1bWVudCkge1xuXG4gIHZhclxuICAgIEVYVEVORFMgPSAnZXh0ZW5kcycsXG4gICAgcmVnaXN0ZXIgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQsXG4gICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgZHJlID0gJ2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQnLFxuICAgIGlubmVySFRNTCA9IHJlZ2lzdGVyLmlubmVySFRNTCxcbiAgICBpbml0aWFsaXplLFxuICAgIHJlZ2lzdGVyZWRcbiAgO1xuXG4gIC8vIGF2b2lkIGR1cGxpY2F0ZWQgd3JhcHBlcnNcbiAgaWYgKGlubmVySFRNTCkgcmV0dXJuIGlubmVySFRNTDtcblxuICB0cnkge1xuXG4gICAgLy8gZmVhdHVyZSBkZXRlY3QgdGhlIHByb2JsZW1cbiAgICByZWdpc3Rlci5jYWxsKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBkcmUsXG4gICAgICB7cHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIHtjcmVhdGVkQ2FsbGJhY2s6IHt2YWx1ZTogT2JqZWN0fX1cbiAgICAgICl9XG4gICAgKTtcblxuICAgIGRpdi5pbm5lckhUTUwgPSAnPCcgKyBkcmUgKyAnPjwvJyArIGRyZSArICc+JztcblxuICAgIC8vIGlmIG5hdGl2ZWx5IHN1cHBvcnRlZCwgbm90aGluZyB0byBkb1xuICAgIGlmICgnY3JlYXRlZENhbGxiYWNrJyBpbiBkaXYucXVlcnlTZWxlY3RvcihkcmUpKSB7XG4gICAgICAvLyByZXR1cm4ganVzdCBhbiBpbm5lckhUTUwgd3JhcFxuICAgICAgcmV0dXJuIChyZWdpc3Rlci5pbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwsIGh0bWwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0gY2F0Y2gobWVoKSB7fVxuXG4gIC8vIGluIG90aGVyIGNhc2VzXG4gIHJlZ2lzdGVyZWQgPSBbXTtcbiAgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChcbiAgICAgICdjcmVhdGVkQ2FsbGJhY2snIGluIGVsICAgICAgICAgfHxcbiAgICAgICdhdHRhY2hlZENhbGxiYWNrJyBpbiBlbCAgICAgICAgfHxcbiAgICAgICdkZXRhY2hlZENhbGxiYWNrJyBpbiBlbCAgICAgICAgfHxcbiAgICAgICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snIGluIGVsXG4gICAgKSByZXR1cm47XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5pbm5lckhUTUxIZWxwZXIgPSB0cnVlO1xuICAgIGZvciAodmFyXG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZSxcbiAgICAgIHR5cGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lzJyksXG4gICAgICBuYW1lID0gZWwubm9kZU5hbWUsXG4gICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseShcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHR5cGUgPyBbbmFtZSwgdHlwZV0gOiBbbmFtZV1cbiAgICAgICksXG4gICAgICBhdHRyaWJ1dGVzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgIGkgPSAwLFxuICAgICAgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGgsXG4gICAgICBhdHRyLCBmYztcbiAgICAgIGkgPCBsZW5ndGg7IGkrK1xuICAgICkge1xuICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5jcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIG5vZGUuY3JlYXRlZCA9IHRydWU7XG4gICAgICBub2RlLmNyZWF0ZWRDYWxsYmFjaygpO1xuICAgICAgbm9kZS5jcmVhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlICgoZmMgPSBlbC5maXJzdENoaWxkKSkgbm9kZS5hcHBlbmRDaGlsZChmYyk7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5pbm5lckhUTUxIZWxwZXIgPSBmYWxzZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgZWwpO1xuICB9O1xuICAvLyBhdWdtZW50IHRoZSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQgbWV0aG9kXG4gIHJldHVybiAoKGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCA9IGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudCh0eXBlLCBvcHRpb25zKSB7XG4gICAgdmFyIG5hbWUgPSAob3B0aW9uc1tFWFRFTkRTXSA/XG4gICAgICAob3B0aW9uc1tFWFRFTkRTXSArICdbaXM9XCInICsgdHlwZSArICdcIl0nKSA6IHR5cGVcbiAgICApLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHJlZ2lzdGVyZWQuaW5kZXhPZihuYW1lKSA8IDApIHJlZ2lzdGVyZWQucHVzaChuYW1lKTtcbiAgICByZXR1cm4gcmVnaXN0ZXIuYXBwbHkoZG9jdW1lbnQsIGFyZ3VtZW50cyk7XG4gIH0pLmlubmVySFRNTCA9IGZ1bmN0aW9uIChlbCwgaHRtbCkge1xuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgZm9yICh2YXJcbiAgICAgIG5vZGVzID0gZWwucXVlcnlTZWxlY3RvckFsbChyZWdpc3RlcmVkLmpvaW4oJywnKSksXG4gICAgICBpID0gbm9kZXMubGVuZ3RoOyBpLS07IGluaXRpYWxpemUobm9kZXNbaV0pXG4gICAgKSB7fVxuICAgIHJldHVybiBlbDtcbiAgfSk7XG59KGRvY3VtZW50KSk7IiwiLyoqXG4gKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXIgKHNlcnZlciBvciBicm93c2VyKVxuICogXG4gKiAtIHB1cmUgamF2YXNjcmlwdCAtIHNlcnZlciBjb21wYXRpYmxlLCBicm93c2VyIGNvbXBhdGlibGVcbiAqIC0gZG9udCByZWx5IG9uIHRoZSBicm93c2VyIGRvbXNcbiAqIC0gc3VwZXIgc2ltcGxlIC0geW91IGdldCBpdCBpbW1lZGlhdGVseSwgbm8gbXlzdGVyeSwgbm8gbWFnaWMgaW52b2x2ZWRcbiAqXG4gKiAtIGNyZWF0ZSBhIE1pY3JvRXZlbnREZWJ1ZyB3aXRoIGdvb2RpZXMgdG8gZGVidWdcbiAqICAgLSBtYWtlIGl0IHNhZmVyIHRvIHVzZVxuKi9cblxuLyoqIE5PVEU6IFRoaXMgbGlicmFyeSBpcyBjdXN0b21pemVkIGZvciBPbnNlbiBVSS4gKi9cblxudmFyIE1pY3JvRXZlbnQgID0gZnVuY3Rpb24oKXt9O1xuTWljcm9FdmVudC5wcm90b3R5cGUgID0ge1xuICBvbiAgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGZjdCk7XG4gIH0sXG4gIG9uY2UgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCB3cmFwcGVyKTtcbiAgICAgIHJldHVybiBmY3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMub24oZXZlbnQsIHdyYXBwZXIpO1xuICB9LFxuICBvZmYgIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmKCBldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlICApICByZXR1cm47XG5cbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihfZmN0KSB7XG4gICAgICAgIGlmIChmY3QpIHtcbiAgICAgICAgICAgcmV0dXJuIGZjdCAhPT0gX2ZjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9LFxuICBlbWl0IDogZnVuY3Rpb24oZXZlbnQgLyogLCBhcmdzLi4uICovKXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYoIGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UgICkgIHJldHVybjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkrKyl7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBtaXhpbiB3aWxsIGRlbGVnYXRlIGFsbCBNaWNyb0V2ZW50LmpzIGZ1bmN0aW9uIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcbiAqXG4gKiAtIHJlcXVpcmUoJ01pY3JvRXZlbnQnKS5taXhpbihGb29iYXIpIHdpbGwgbWFrZSBGb29iYXIgYWJsZSB0byB1c2UgTWljcm9FdmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgc3VwcG9ydCBNaWNyb0V2ZW50XG4qL1xuTWljcm9FdmVudC5taXhpbiAgPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcbiAgdmFyIHByb3BzID0gWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKyspe1xuICAgIGlmKCB0eXBlb2YgZGVzdE9iamVjdCA9PT0gJ2Z1bmN0aW9uJyApe1xuICAgICAgZGVzdE9iamVjdC5wcm90b3R5cGVbcHJvcHNbaV1dICA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9ZWxzZXtcbiAgICAgIGRlc3RPYmplY3RbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vLyBleHBvcnQgaW4gY29tbW9uIGpzXG5pZiggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoJ2V4cG9ydHMnIGluIG1vZHVsZSkpe1xuICBtb2R1bGUuZXhwb3J0cyAgPSBNaWNyb0V2ZW50O1xufVxuXG53aW5kb3cuTWljcm9FdmVudCA9IE1pY3JvRXZlbnQ7XG4iLCIoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgXG4gIC8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gICAgd2hpbGUgKHNlbGYuX3N0YXRlID09PSAzKSB7XG4gICAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gICAgfVxuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMCkge1xuICAgICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAoc2VsZi5fc3RhdGUgPT09IDEgPyByZXNvbHZlIDogcmVqZWN0KShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl92YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgaWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChzZWxmLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICBzZWxmLl9zdGF0ZSA9IDI7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVkKSB7XG4gICAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBoYW5kbGUoc2VsZiwgc2VsZi5fZGVmZXJyZWRzW2ldKTtcbiAgICB9XG4gICAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICAgKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAgICpcbiAgICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICAgKi9cbiAgZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBzZWxmKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHJlamVjdChzZWxmLCBleCk7XG4gICAgfVxuICB9XG5cbiAgUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBwcm9tID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShub29wKTtcblxuICAgIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbSkpO1xuICAgIHJldHVybiBwcm9tO1xuICB9O1xuXG4gIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3QodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uIChmbikgeyBzZXRJbW1lZGlhdGUoZm4pOyB9KSB8fFxuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICAgIH07XG5cbiAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfdW5oYW5kbGVkUmVqZWN0aW9uRm4oZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1tZWRpYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgY2FsbGJhY2tzXG4gICAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldEltbWVkaWF0ZUZuID0gZnVuY3Rpb24gX3NldEltbWVkaWF0ZUZuKGZuKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSBmbjtcbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF9zZXRVbmhhbmRsZWRSZWplY3Rpb25Gbihmbikge1xuICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZm47XG4gIH07XG5cbiAgaWYgKCF3aW5kb3cuUHJvbWlzZSkge1xuICAgIHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZTtcbiAgfVxufSkodGhpcyk7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDEyIEJhcm5lc2FuZG5vYmxlLmNvbSwgbGxjLCBEb25hdm9uIFdlc3QsIGFuZCBEb21lbmljIERlbmljb2xhXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciBzZXRJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3MpIHtcbiAgICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHBhcnRpYWxseUFwcGxpZWQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIHBhcnRpYWxseUFwcGxpZWQoaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChuZXcgRnVuY3Rpb24oXCJcIiArIGhhbmRsZXIpKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0oZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSgpKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVmlld3BvcnQoKSB7XG5cbiAgICAgICAgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcbiAgICAgICAgdGhpcy5JT1M3X1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuICAgICAgICB0aGlzLkRFRkFVTFRfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG5cbiAgICAgICAgdGhpcy5lbnN1cmVWaWV3cG9ydEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHt9O1xuICAgICAgICB0aGlzLnBsYXRmb3JtLm5hbWUgPSB0aGlzLmdldFBsYXRmb3JtTmFtZSgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtLnZlcnNpb24gPSB0aGlzLmdldFBsYXRmb3JtVmVyc2lvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZW5zdXJlVmlld3BvcnRFbGVtZW50ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG4gICAgICAgIGlmKCF0aGlzLnZpZXdwb3J0RWxlbWVudCl7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50Lm5hbWUgPSBcInZpZXdwb3J0XCI7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uby1hZGp1c3QnKSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0ubmFtZSA9PSAnaW9zJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsYXRmb3JtLnZlcnNpb24gPj0gNyAmJiBpc1dlYlZpZXcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLklPUzdfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuUFJFX0lPUzdfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5ERUZBVUxUX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzV2ViVmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuY29yZG92YSB8fCB3aW5kb3cucGhvbmVnYXAgfHwgd2luZG93LlBob25lR2FwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZ2V0UGxhdGZvcm1OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhbmRyb2lkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaW9zXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1bmtub3duXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybVZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignT1MgJyk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuTnVtYmVyKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnN1YnN0cihzdGFydCArIDMsIDMpLnJlcGxhY2UoJ18nLCAnLicpKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlZpZXdwb3J0ID0gVmlld3BvcnQ7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgT3BlbiBUZWNobm9sb2dpZXMsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4vLyBKYXZhU2NyaXB0IER5bmFtaWMgQ29udGVudCBzaGltIGZvciBXaW5kb3dzIFN0b3JlIGFwcHNcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAod2luZG93Lk1TQXBwICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG5cbiAgICAgICAgLy8gU29tZSBub2RlcyB3aWxsIGhhdmUgYW4gXCJhdHRyaWJ1dGVzXCIgcHJvcGVydHkgd2hpY2ggc2hhZG93cyB0aGUgTm9kZS5wcm90b3R5cGUuYXR0cmlidXRlcyBwcm9wZXJ0eVxuICAgICAgICAvLyAgYW5kIG1lYW5zIHdlIGRvbid0IGFjdHVhbGx5IHNlZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgTm9kZSAoaW50ZXJlc3RpbmdseSB0aGUgVlMgZGVidWcgY29uc29sZVxuICAgICAgICAvLyAgYXBwZWFycyB0byBzdWZmZXIgZnJvbSB0aGUgc2FtZSBpc3N1ZSkuXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBFbGVtZW50X3NldEF0dHJpYnV0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwic2V0QXR0cmlidXRlXCIpLnZhbHVlO1xuICAgICAgICB2YXIgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCBcInJlbW92ZUF0dHJpYnV0ZVwiKS52YWx1ZTtcbiAgICAgICAgdmFyIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTFByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBcImluc2VydEFkamFjZW50SFRNTFwiKTtcbiAgICAgICAgdmFyIE5vZGVfZ2V0X2F0dHJpYnV0ZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCBcImF0dHJpYnV0ZXNcIikuZ2V0O1xuICAgICAgICB2YXIgTm9kZV9nZXRfY2hpbGROb2RlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiY2hpbGROb2Rlc1wiKS5nZXQ7XG4gICAgICAgIHZhciBkZXRlY3Rpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVfZ2V0X2F0dHJpYnV0ZXMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEVsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKGVsZW1lbnQsIGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGlsZE5vZGVzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlX2dldF9jaGlsZE5vZGVzLmNhbGwoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QWRqYWNlbnRIVE1MKGVsZW1lbnQsIHBvc2l0aW9uLCBodG1sKSB7XG4gICAgICAgICAgICBIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUxQcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUuY2FsbChlbGVtZW50LCBwb3NpdGlvbiwgaHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpblVuc2FmZU1vZGUoKSB7XG4gICAgICAgICAgICB2YXIgaXNVbnNhZmUgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25EaXYuaW5uZXJIVE1MID0gXCI8dGVzdC8+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpc1Vuc2FmZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNVbnNhZmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnNlKGh0bWwsIHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBjbGVhbmVyID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiY2xlYW5lclwiKTtcbiAgICAgICAgICAgIGVtcHR5KGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEhUTUwoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQsIFwiYWZ0ZXJiZWdpblwiLCBodG1sKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNjcmlwdHMsIGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjcmlwdC50eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvaW5lcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2VjbWFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQveC1qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2pzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvbGl2ZXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4xXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuM1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvaW5lcnQtXCIgKyBzY3JpcHQudHlwZS5zbGljZShcInRleHQvXCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24veC1qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwiYXBwbGljYXRpb24vaW5lcnQtXCIgKyBzY3JpcHQudHlwZS5zbGljZShcImFwcGxpY2F0aW9uL1wiLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFuc2VBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgYXR0cmlidXRlcyBjb2xsZWN0aW9uIGlzIGxpdmUgaXQgaXMgc2ltcGxlciB0byBxdWV1ZSB1cCB0aGUgcmVuYW1lc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuYW1lWzBdID09PSBcIm9cIiB8fCBuYW1lWzBdID09PSBcIk9cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZVsxXSA9PT0gXCJuXCIgfHwgbmFtZVsxXSA9PT0gXCJOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHsgbmFtZTogYXR0cmlidXRlLm5hbWUsIHZhbHVlOiBhdHRyaWJ1dGUudmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJ4LVwiICsgYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY2hpbGROb2RlcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFuc2VBdHRyaWJ1dGVzKGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAgICAgdmFyIGNsZWFuZWROb2RlcyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbmVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5lci5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IGNsZWFuZWROb2Rlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuaGVhZCkuY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5lci5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IGNsZWFuZWROb2Rlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuYm9keSkuY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWROb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihwcm9wZXJ0eSwgc2V0dGVyKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNldHRlciA9IHByb3BlcnR5RGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGdldDogcHJvcGVydHlEZXNjcmlwdG9yLmdldCxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuV2luSlMgJiYgd2luZG93LldpbkpTLl9leGVjVW5zYWZlICYmIGluVW5zYWZlTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNldHRlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGNsZWFuc2UodmFsdWUsIHRoYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcihwcm9wZXJ0eURlc2NyaXB0b3IsIHRoYXQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBwcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhbnNlUHJvcGVydHlTZXR0ZXIoXCJpbm5lckhUTUxcIiwgZnVuY3Rpb24gKHByb3BlcnR5RGVzY3JpcHRvciwgdGFyZ2V0LCBlbGVtZW50cykge1xuICAgICAgICAgICAgZW1wdHkodGFyZ2V0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhbnNlUHJvcGVydHlTZXR0ZXIoXCJvdXRlckhUTUxcIiwgZnVuY3Rpb24gKHByb3BlcnR5RGVzY3JpcHRvciwgdGFyZ2V0LCBlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KCkpOyIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdW53cmFwID0gc3RyaW5nID0+IHN0cmluZy5zbGljZSgxLCAtMSk7XG5jb25zdCBpc09iamVjdFN0cmluZyA9IHN0cmluZyA9PiBzdHJpbmcuc3RhcnRzV2l0aCgneycpICYmIHN0cmluZy5lbmRzV2l0aCgnfScpO1xuY29uc3QgaXNBcnJheVN0cmluZyA9IHN0cmluZyA9PiBzdHJpbmcuc3RhcnRzV2l0aCgnWycpICYmIHN0cmluZy5lbmRzV2l0aCgnXScpO1xuY29uc3QgaXNRdW90ZWRTdHJpbmcgPSBzdHJpbmcgPT4gKHN0cmluZy5zdGFydHNXaXRoKCdcXCcnKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1xcJycpKSB8fCAoc3RyaW5nLnN0YXJ0c1dpdGgoJ1wiJykgJiYgc3RyaW5nLmVuZHNXaXRoKCdcIicpKTtcblxuY29uc3QgZXJyb3IgPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIFxcJycgKyB0b2tlbiArICdcXCcgYXQgcG9zaXRpb24gJyArIChvcmlnaW5hbFN0cmluZy5sZW5ndGggLSBzdHJpbmcubGVuZ3RoIC0gMSkgKyAnIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xufTtcblxuY29uc3QgcHJvY2Vzc1Rva2VuID0gKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSA9PiB7XG4gIGlmICh0b2tlbiA9PT0gJ3RydWUnIHx8IHRva2VuID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIHRva2VuID09PSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAoaXNRdW90ZWRTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHVud3JhcCh0b2tlbik7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHRva2VuKSkge1xuICAgIHJldHVybiArKHRva2VuKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHRva2VuKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cbn07XG5cbmNvbnN0IG5leHRUb2tlbiA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW1MZWZ0KCk7XG4gIGxldCBsaW1pdCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgaWYgKHN0cmluZ1swXSA9PT0gJzonIHx8IHN0cmluZ1swXSA9PT0gJywnKSB7XG5cbiAgICBsaW1pdCA9IDE7XG5cbiAgfSBlbHNlIGlmIChzdHJpbmdbMF0gPT09ICd7JyB8fCBzdHJpbmdbMF0gPT09ICdbJykge1xuXG4gICAgY29uc3QgYyA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgIGxldCBuZXN0ZWRPYmplY3QgPSAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0Kys7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjICsgMikge1xuICAgICAgICBuZXN0ZWRPYmplY3QtLTtcbiAgICAgICAgaWYgKG5lc3RlZE9iamVjdCA9PT0gMCkge1xuICAgICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmIChzdHJpbmdbMF0gPT09ICdcXCcnIHx8IHN0cmluZ1swXSA9PT0gJ1xcXCInKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gc3RyaW5nWzBdKSB7XG4gICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChbJyAnLCAnLCcsICc6J10uaW5kZXhPZihzdHJpbmdbaV0pICE9PSAtMSkge1xuICAgICAgICBsaW1pdCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBsaW1pdCk7XG59O1xuXG5jb25zdCBwYXJzZU9iamVjdCA9IChzdHJpbmcpID0+IHtcbiAgY29uc3QgaXNWYWxpZEtleSA9IGtleSA9PiAvXltBLVpfXFwkXVtBLVowLTlfXFwkXSokL2kudGVzdChrZXkpO1xuXG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gIGNvbnN0IG9yaWdpbmFsU3RyaW5nID0gc3RyaW5nO1xuICBjb25zdCBvYmplY3QgPSB7fTtcbiAgbGV0IHJlYWRpbmdLZXkgPSB0cnVlLCBrZXksIHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcblxuICAgIGlmICgodG9rZW4gPT09ICc6JyAmJiAoIXJlYWRpbmdLZXkgfHwgIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSlcbiAgICAgICB8fCAodG9rZW4gPT09ICcsJyAmJiByZWFkaW5nS2V5KVxuICAgICAgIHx8ICh0b2tlbiAhPT0gJzonICYmIHRva2VuICE9PSAnLCcgJiYgKHByZXZpb3VzVG9rZW4gJiYgcHJldmlvdXNUb2tlbiAhPT0gJywnICYmIHByZXZpb3VzVG9rZW4gIT09ICc6JykpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJzonICYmIHJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgaWYgKGlzVmFsaWRLZXkocHJldmlvdXNUb2tlbikpIHtcbiAgICAgICAga2V5ID0gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgcmVhZGluZ0tleSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSB0b2tlbiBcXCcnICsgcHJldmlvdXNUb2tlbiArICdcXCcgYXQgcG9zaXRpb24gMCBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnLCcgJiYgIXJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgICByZWFkaW5nS2V5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgcGFyc2VBcnJheSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGxldCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZShzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xuICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgsIHN0cmluZy5sZW5ndGgpLnRyaW1MZWZ0KCk7XG5cbiAgICBpZiAodG9rZW4gPT09ICcsJyAmJiAoIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJykge1xuICAgICAgYXJyYXkucHVzaChwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIGlmICh0b2tlbiAhPT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuY29uc3QgcGFyc2UgPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG5cbiAgaWYgKGlzT2JqZWN0U3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcChzdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHN0cmluZyBtdXN0IGJlIG9iamVjdCBvciBhcnJheSBsaWtlOiAnICsgc3RyaW5nKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlIGZyb20gJy4vYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyJztcblxuY29uc3QgdXRpbCA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG51dGlsLnByZXBhcmVRdWVyeSA9IChxdWVyeSkgPT4ge1xuICByZXR1cm4gcXVlcnkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHF1ZXJ5IDogKGVsZW1lbnQpID0+IHV0aWwubWF0Y2goZWxlbWVudCwgcXVlcnkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLm1hdGNoID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGlmIChxdWVyeVswXSA9PT0gJy4nKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHF1ZXJ5LnNsaWNlKDEpKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBxdWVyeTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRDaGlsZCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudC5jaGlsZHJlbltpXTtcbiAgICBpZiAobWF0Y2gobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRQYXJlbnQgPSAoZWxlbWVudCwgcXVlcnkpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgZm9yICg7Oykge1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobWF0Y2gocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmlzQXR0YWNoZWQgPSAoZWxlbWVudCkgPT4ge1xuICB3aGlsZSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChlbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8ob25zLW5hdmlnYXRvcnxvbnMtdGFiYmFyfG9ucy1tb2RhbHxvbnMtc2xpZGluZy1tZW51fG9ucy1zcGxpdC12aWV3KS8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXG4gKi9cbnV0aWwucHJvcGFnYXRlQWN0aW9uID0gKGVsZW1lbnQsIGFjdGlvbikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZFthY3Rpb25dIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNoaWxkW2FjdGlvbl0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oY2hpbGQsIGFjdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gdGFnIGFuZCBjbGFzcyBvbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGUgPSAoc2VsZWN0b3IgPSAnJywgc3R5bGUgPSB7fSkgPT4ge1xuICBjb25zdCBjbGFzc0xpc3QgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjbGFzc0xpc3Quc2hpZnQoKSB8fCAnZGl2Jyk7XG5cbiAgaWYgKGNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gIH1cblxuICB1dGlsLmV4dGVuZChlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZUVsZW1lbnQgPSAoaHRtbCkgPT4ge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVySFRNTCh3cmFwcGVyLCBodG1sKTtcblxuICBpZiAod3JhcHBlci5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImh0bWxcIiBtdXN0IGJlIG9uZSB3cmFwcGVyIGVsZW1lbnQuJyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlci5jaGlsZHJlblswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxGcmFnbWVudH1cbiAqL1xudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXJIVE1MKHdyYXBwZXIsIGh0bWwpO1xuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn07XG5cbi8qXG4gKiBAcGFyYW0ge09iamVjdH0gZHN0IERlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzcmMgU291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cbiAqL1xudXRpbC5leHRlbmQgPSAoZHN0LCAuLi5hcmdzKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnc1tpXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgZHN0W2tleV0gPSBhcmdzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnV0aWwuYXJyYXlGcm9tID0gKGFycmF5TGlrZSkgPT4ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5TGlrZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhaWxTYWZlXVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLnBhcnNlSlNPTk9iamVjdFNhZmVseSA9IChqc29uU3RyaW5nLCBmYWlsU2FmZSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgnJyArIGpzb25TdHJpbmcpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFpbFNhZmU7XG4gIH1cbiAgcmV0dXJuIGZhaWxTYWZlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHBhdGggc3VjaCBhcyAnbXlBcHAuY29udHJvbGxlcnMuZGF0YS5sb2FkRGF0YSdcbiAqIEByZXR1cm4ge0FueX0gLSB3aGF0ZXZlciBpcyBsb2NhdGVkIGF0IHRoYXQgcGF0aFxuICovXG51dGlsLmZpbmRGcm9tUGF0aCA9IChwYXRoKSA9PiB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBlbCA9IHdpbmRvdywga2V5O1xuICB3aGlsZSAoa2V5ID0gcGF0aC5zaGlmdCgpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICBlbCA9IGVsW2tleV07XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsXVxuICogQHJldHVybiB7Q3VzdG9tRXZlbnR9XG4gKi9cbnV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgZGV0YWlsID0ge30pID0+IHtcblxuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZGV0YWlsKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZXZlbnRba2V5XSA9IGRldGFpbFtrZXldO1xuICB9KTtcblxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgcmV0dXJuIGV2ZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5oYXNNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykuc3BsaXQoL1xccysvKS5zb21lKGUgPT4gZSA9PT0gbW9kaWZpZXJOYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGFkZGVkIG9yIG5vdC5cbiAqL1xudXRpbC5hZGRNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAodXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtb2RpZmllck5hbWUgPSBtb2RpZmllck5hbWUudHJpbSgpO1xuICBjb25zdCBtb2RpZmllckF0dHJpYnV0ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgKG1vZGlmaWVyQXR0cmlidXRlICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAqL1xudXRpbC5yZW1vdmVNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBtb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLyk7XG5cbiAgY29uc3QgbmV3TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbSAhPT0gbW9kaWZpZXJOYW1lKTtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKTtcblxuICByZXR1cm4gbW9kaWZpZXJzLmxlbmd0aCAhPT0gbmV3TW9kaWZpZXJzLmxlbmd0aDtcbn07XG5cbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcbiAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCBlbmFibGUpID0+IHtcbiAgaWYgKGVuYWJsZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufTtcblxudXRpbC5iaW5kTGlzdGVuZXJzID0gKGVsZW1lbnQsIGxpc3RlbmVyTmFtZXMpID0+IHtcbiAgbGlzdGVuZXJOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IGJvdW5kTmFtZSA9IG5hbWUucmVwbGFjZSgvXl9bYS16XS8sICdfYm91bmQnICsgbmFtZVsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBlbGVtZW50W2JvdW5kTmFtZV0gPSBlbGVtZW50W2JvdW5kTmFtZV0gfHwgZWxlbWVudFtuYW1lXS5iaW5kKGVsZW1lbnQpO1xuICB9KTtcbn07XG5cbnV0aWwuZWFjaCA9IChvYmosIGYpID0+IE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4gZihrZXksIG9ialtrZXldKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG51dGlsLnVwZGF0ZVJpcHBsZSA9ICh0YXJnZXQpID0+IHtcbiAgY29uc3QgcmlwcGxlRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRhcmdldCwgJ29ucy1yaXBwbGUnKTtcblxuICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcbiAgICBpZiAoIXJpcHBsZUVsZW1lbnQpIHtcbiAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXJpcHBsZScpLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpcHBsZUVsZW1lbnQpIHtcbiAgICByaXBwbGVFbGVtZW50LnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSA9IGFuaW1hdGlvbk9wdGlvbnNQYXJzZTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmVqY3R9IERlZmVycmVkIHByb21pc2UuXG4gKi9cbnV0aWwuZGVmZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGRlZmVycmVkID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcbiIsIi8qXG4gKiBHZXN0dXJlIGRldGVjdG9yIGxpYnJhcnkgdGhhdCBmb3JrZWQgZnJvbSBnaXRodWIuY29tL0VpZ2h0TWVkaWEvaGFtbWVyLmpzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50LCBVdGlscywgRGV0ZWN0aW9uLCBQb2ludGVyRXZlbnQ7XG5cbi8qKlxuICogQG9iamVjdCBvbnMuR2VzdHVyZURldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1VdGlsaXR5IGNsYXNzIGZvciBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Kv44Op44K544Gn44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAqIEBzaWduYXR1cmUgY29uc3RydWN0b3IoZWxlbWVudFssIG9wdGlvbnNdKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXUNyZWF0ZSBhIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UuWy9lbl1cbiAqICBbamFdR2VzdHVyZURldGVjdG9y44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi0RPTeimgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEByZXR1cm4ge29ucy5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbnZhciBHZXN0dXJlRGV0ZWN0b3IgPSBmdW5jdGlvbiBHZXN0dXJlRGV0ZWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZShlbGVtZW50LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICogbW9yZSBzZXR0aW5ncyBhcmUgZGVmaW5lZCBwZXIgZ2VzdHVyZSBhdCBgL2dlc3R1cmVzYC4gRWFjaCBnZXN0dXJlIGNhbiBiZSBkaXNhYmxlZC9lbmFibGVkXG4gKiBieSBzZXR0aW5nIGl0J3MgbmFtZSAobGlrZSBgc3dpcGVgKSB0byBmYWxzZS5cbiAqIFlvdSBjYW4gc2V0IHRoZSBkZWZhdWx0cyBmb3IgYWxsIGluc3RhbmNlcyBieSBjaGFuZ2luZyB0aGlzIG9iamVjdCBiZWZvcmUgY3JlYXRpbmcgYW4gaW5zdGFuY2UuXG4gKiBAZXhhbXBsZVxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5kcmFnID0gZmFsc2U7XG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uID0gJ3Bhbi15JztcbiAqICBkZWxldGUgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3Q7XG4gKiBgYGBgXG4gKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cyA9IHtcbiAgYmVoYXZpb3I6IHtcbiAgICAvLyB1c2VyU2VsZWN0OiAnbm9uZScsIC8vIEFsc28gZGlzYWJsZXMgc2VsZWN0aW9uIGluIGBpbnB1dGAgY2hpbGRyZW5cbiAgICB0b3VjaEFjdGlvbjogJ3Bhbi15JyxcbiAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcbiAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuICAgIHVzZXJEcmFnOiAnbm9uZScsXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICB9XG59O1xuXG4vKipcbiAqIEdlc3R1cmVEZXRlY3RvciBkb2N1bWVudCB3aGVyZSB0aGUgYmFzZSBldmVudHMgYXJlIGFkZGVkIGF0XG4gKiBAcHJvcGVydHkgRE9DVU1FTlRcbiAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAqIEBkZWZhdWx0IHdpbmRvdy5kb2N1bWVudFxuICovXG5HZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQgPSBkb2N1bWVudDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgcG9pbnRlciBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfUE9JTlRFUkVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgdG91Y2ggZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1RPVUNIRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4vKipcbiAqIGRldGVjdCBtb2JpbGUgYnJvd3NlcnNcbiAqIEBwcm9wZXJ0eSBJU19NT0JJTEVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBkZXRlY3QgaWYgd2Ugd2FudCB0byBzdXBwb3J0IG1vdXNlZXZlbnRzIGF0IGFsbFxuICogQHByb3BlcnR5IE5PX01PVVNFRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTID0gKEdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgJiYgR2VzdHVyZURldGVjdG9yLklTX01PQklMRSkgfHwgR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTO1xuXG4vKipcbiAqIGludGVydmFsIGluIHdoaWNoIEdlc3R1cmVEZXRlY3RvciByZWNhbGN1bGF0ZXMgY3VycmVudCB2ZWxvY2l0eS9kaXJlY3Rpb24vYW5nbGUgaW4gbXNcbiAqIEBwcm9wZXJ0eSBDQUxDVUxBVEVfSU5URVJWQUxcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCAyNVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuQ0FMQ1VMQVRFX0lOVEVSVkFMID0gMjU7XG5cbi8qKlxuICogZXZlbnR0eXBlcyBwZXIgdG91Y2hldmVudCAoc3RhcnQsIG1vdmUsIGVuZCkgYXJlIGZpbGxlZCBieSBgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlc2Agb24gYHNldHVwYFxuICogdGhlIG9iamVjdCBjb250YWlucyB0aGUgRE9NIGV2ZW50IG5hbWVzIHBlciB0eXBlIChgRVZFTlRfU1RBUlRgLCBgRVZFTlRfTU9WRWAsIGBFVkVOVF9FTkRgKVxuICogQHByb3BlcnR5IEVWRU5UX1RZUEVTXG4gKiBAcHJpdmF0ZVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge307XG5cbi8qKlxuICogZGlyZWN0aW9uIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgRElSRUNUSU9OX0RPV058TEVGVHxVUHxSSUdIVFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ2Rvd24nICdsZWZ0JyAndXAnICdyaWdodCdcbiAqL1xudmFyIERJUkVDVElPTl9ET1dOID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9ET1dOID0gJ2Rvd24nO1xudmFyIERJUkVDVElPTl9MRUZUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xudmFyIERJUkVDVElPTl9VUCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fVVAgPSAndXAnO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xuXG4vKipcbiAqIHBvaW50ZXJ0eXBlIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5cbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdtb3VzZScgJ3RvdWNoJyAncGVuJ1xuICovXG52YXIgUE9JTlRFUl9NT1VTRSA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX01PVVNFID0gJ21vdXNlJztcbnZhciBQT0lOVEVSX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfVE9VQ0ggPSAndG91Y2gnO1xudmFyIFBPSU5URVJfUEVOID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfUEVOID0gJ3Blbic7XG5cbi8qKlxuICogZXZlbnR0eXBlc1xuICogQHByb3BlcnR5IEVWRU5UX1NUQVJUfE1PVkV8RU5EfFJFTEVBU0V8VE9VQ0hcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdzdGFydCcgJ2NoYW5nZScgJ21vdmUnICdlbmQnICdyZWxlYXNlJyAndG91Y2gnXG4gKi9cbnZhciBFVkVOVF9TVEFSVCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9TVEFSVCA9ICdzdGFydCc7XG52YXIgRVZFTlRfTU9WRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9NT1ZFID0gJ21vdmUnO1xudmFyIEVWRU5UX0VORCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9FTkQgPSAnZW5kJztcbnZhciBFVkVOVF9SRUxFQVNFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1JFTEVBU0UgPSAncmVsZWFzZSc7XG52YXIgRVZFTlRfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfVE9VQ0ggPSAndG91Y2gnO1xuXG4vKipcbiAqIGlmIHRoZSB3aW5kb3cgZXZlbnRzIGFyZSBzZXQuLi5cbiAqIEBwcm9wZXJ0eSBSRUFEWVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSBmYWxzZTtcblxuLyoqXG4gKiBwbHVnaW5zIG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHBsdWdpbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zID0gR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgfHwge307XG5cbi8qKlxuICogZ2VzdHVyZXMgbmFtZXNwYWNlXG4gKiBzZWUgYC9nZXN0dXJlc2AgZm9yIHRoZSBkZWZpbml0aW9uc1xuICogQHByb3BlcnR5IGdlc3R1cmVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgPSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgfHwge307XG5cbi8qKlxuICogc2V0dXAgZXZlbnRzIHRvIGRldGVjdCBnZXN0dXJlcyBvbiB0aGUgZG9jdW1lbnRcbiAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYW4gbmV3IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgaWYoR2VzdHVyZURldGVjdG9yLlJFQURZKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzKCk7XG5cbiAgLy8gUmVnaXN0ZXIgYWxsIGdlc3R1cmVzIGluc2lkZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgVXRpbHMuZWFjaChHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcbiAgICBEZXRlY3Rpb24ucmVnaXN0ZXIoZ2VzdHVyZSk7XG4gIH0pO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9NT1ZFLCBEZXRlY3Rpb24uZGV0ZWN0KTtcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCk7XG5cbiAgLy8gR2VzdHVyZURldGVjdG9yIGlzIHJlYWR5Li4uIVxuICBHZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSB0cnVlO1xufVxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFV0aWxzXG4gKiBAc3RhdGljXG4gKi9cblV0aWxzID0gR2VzdHVyZURldGVjdG9yLnV0aWxzID0ge1xuICAvKipcbiAgICogZXh0ZW5kIG1ldGhvZCwgY291bGQgYWxzbyBiZSB1c2VkIGZvciBjbG9uaW5nIHdoZW4gYGRlc3RgIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICogY2hhbmdlcyB0aGUgZGVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV0gIGRvIGEgbWVyZ2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChkZXN0W2tleV0gPT09IHVuZGVmaW5lZCB8fCAhbWVyZ2UpKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIHJlbW92ZUV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3JFYWNoIG92ZXIgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHBhcmFtIHthbnl9IGl0ZXJhdG9yLml0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdG9yLmluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBpdGVyYXRvci5vYmogdGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYCBpbiB0aGUgaXRlcmF0b3JcbiAgICovXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpLCBsZW47XG5cbiAgICAvLyBuYXRpdmUgZm9yRWFjaCBvbiBhcnJheXNcbiAgICBpZignZm9yRWFjaCcgaW4gb2JqKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAvLyBhcnJheXNcbiAgICB9IGVsc2UgaWYob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZihpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG9iamVjdHNcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIHN0cmluZyBjb250YWlucyB0aGUgc3RyaW5nIHVzaW5nIGluZGV4T2ZcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgaW5TdHI6IGZ1bmN0aW9uIGluU3RyKHNyYywgZmluZCkge1xuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICovXG4gIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kKSB7XG4gICAgaWYoc3JjLmluZGV4T2YpIHtcbiAgICAgIHZhciBpbmRleCA9IHNyYy5pbmRleE9mKGZpbmQpO1xuICAgICAgcmV0dXJuIChpbmRleCA9PT0gLTEpID8gZmFsc2UgOiBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0IChgYXJndW1lbnRzYCwgYHRvdWNobGlzdGApIHRvIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBoYXNQYXJlbnQ6IGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZShub2RlKSB7XG4gICAgICBpZihub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHBhZ2VYYCwgYHBhZ2VZYCwgYGNsaWVudFhgIGFuZCBgY2xpZW50WWAgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIodG91Y2hlcykge1xuICAgIHZhciBwYWdlWCA9IFtdLFxuICAgICAgICBwYWdlWSA9IFtdLFxuICAgICAgICBjbGllbnRYID0gW10sXG4gICAgICAgIGNsaWVudFkgPSBbXSxcbiAgICAgICAgbWluID0gTWF0aC5taW4sXG4gICAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZih0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVg6IHRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgIHBhZ2VZOiB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICBjbGllbnRYOiB0b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBVdGlscy5lYWNoKHRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcbiAgICAgIHBhZ2VZLnB1c2godG91Y2gucGFnZVkpO1xuICAgICAgY2xpZW50WC5wdXNoKHRvdWNoLmNsaWVudFgpO1xuICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VYOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VYKSArIG1heC5hcHBseShNYXRoLCBwYWdlWCkpIC8gMixcbiAgICAgIHBhZ2VZOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VZKSArIG1heC5hcHBseShNYXRoLCBwYWdlWSkpIC8gMixcbiAgICAgIGNsaWVudFg6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WCkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WCkpIC8gMixcbiAgICAgIGNsaWVudFk6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WSkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WSkpIC8gMlxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5hYnMoZGVsdGFYIC8gZGVsdGFUaW1lKSB8fCAwLFxuICAgICAgeTogTWF0aC5hYnMoZGVsdGFZIC8gZGVsdGFUaW1lKSB8fCAwXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG4gIGdldEFuZ2xlOiBmdW5jdGlvbiBnZXRBbmdsZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGRvIGEgc21hbGwgY29tcGFyaXNvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9MRUZUfFJJR0hUfFVQfERPV05gXG4gICAqL1xuICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgIHkgPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZKTtcblxuICAgIGlmKHggPj0geSkge1xuICAgICAgcmV0dXJuIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHRvdWNoZXNcbiAgICogQHBhcmFtIHtUb3VjaH10b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdKSAvIHRoaXMuZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgKi9cbiAgZ2V0Um90YXRpb246IGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLSB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIG91dCBpZiB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9VUHxET1dOYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCB8fCBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCBjc3MgcHJvcGVydGllcyB3aXRoIHRoZWlyIHByZWZpeGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2V0UHJlZml4ZWRDc3M6IGZ1bmN0aW9uIHNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpIHtcbiAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICBwcm9wID0gVXRpbHMudG9DYW1lbENhc2UocHJvcCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHJvcDtcbiAgICAgIC8vIHByZWZpeGVzXG4gICAgICBpZihwcmVmaXhlc1tpXSkge1xuICAgICAgICBwID0gcHJlZml4ZXNbaV0gKyBwLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXN0IHRoZSBzdHlsZVxuICAgICAgaWYocCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcF0gPSAodG9nZ2xlID09PSBudWxsIHx8IHRvZ2dsZSkgJiYgdmFsdWUgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogdG9nZ2xlIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvciBieSBzZXR0aW5nIGNzcyBwcm9wZXJ0aWVzLlxuICAgKiBgdXNlclNlbGVjdD0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbnNlbGVjdHN0YXJ0YCB0byBmYWxzZVxuICAgKiBgdXNlckRyYWc9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25kcmFnc3RhcnRgIHRvIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKi9cbiAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcbiAgICBpZighcHJvcHMgfHwgIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgVXRpbHMuZWFjaChwcm9wcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgIFV0aWxzLnNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpO1xuICAgIH0pO1xuXG4gICAgdmFyIGZhbHNlRm4gPSB0b2dnbGUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGFsc28gdGhlIGRpc2FibGUgb25zZWxlY3RzdGFydFxuICAgIGlmKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICAgIH1cbiAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxuICAgIGlmKHByb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGEgc3RyaW5nIHdpdGggdW5kZXJzY29yZXMgdG8gY2FtZWxDYXNlXG4gICAqIHNvIHByZXZlbnRfZGVmYXVsdCBiZWNvbWVzIHByZXZlbnREZWZhdWx0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7U3RyaW5nfSBjYW1lbENhc2VTdHJcbiAgICovXG4gIHRvQ2FtZWxDYXNlOiBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tfLV0oW2Etel0pL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG4vKipcbiAqIEBjbGFzcyBFdmVudFxuICogQHN0YXRpY1xuICovXG5FdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ldmVudCA9IHtcbiAgLyoqXG4gICAqIHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYmVlbiBmaXJlZCwgdGhpcyBpcyB0cnVlXG4gICAqIHRoaXMgaXMgdXNlZCB0byBzdG9wIG1vdXNlIGV2ZW50c1xuICAgKiBAcHJvcGVydHkgcHJldmVudF9tb3VzZWV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHByZXZlbnRNb3VzZUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIGlmIEVWRU5UX1NUQVJUIGhhcyBiZWVuIGZpcmVkXG4gICAqIEBwcm9wZXJ0eSBzdGFydGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhcnRlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHdoZW4gdGhlIG1vdXNlIGlzIGhvbGQgZG93biwgdGhpcyBpcyB0cnVlXG4gICAqIEBwcm9wZXJ0eSBzaG91bGRfZGV0ZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcblxuICAvKipcbiAgICogc2ltcGxlIGV2ZW50IGJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtob29rXVxuICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIGV2ZW50IHVuYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgVXRpbHMuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgVXRpbHMub2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSB0b3VjaCBldmVudCBoYW5kbGVyLlxuICAgKiB0aGlzIGZpbmRzIG91dCBpZiB3ZSBzaG91bGQgdG8gZGV0ZWN0IGdlc3R1cmVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIG9uVG91Y2hIYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNvcmUgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xuICAgICAgdmFyIHNyY1R5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaXNQb2ludGVyID0gR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTLFxuICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcbiAgICAgICAgICB0cmlnZ2VyVHlwZTtcblxuICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXG4gICAgICAvLyB3ZSB3YW50IHRvIGRvIG5vdGhpbmcuIHNpbXBseSBicmVhayBvdXQgb2YgdGhlIGV2ZW50LlxuICAgICAgaWYoaXNNb3VzZSAmJiBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cykge1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duXG4gICAgICB9IGVsc2UgaWYoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gKGV2LmJ1dHRvbnMgPT09IDEgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1RPVUNILCBldikpO1xuICAgICAgICAvLyBqdXN0IGEgdmFsaWQgc3RhcnQgZXZlbnQsIGJ1dCBubyBtb3VzZVxuICAgICAgfSBlbHNlIGlmKCFpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyIGV2ZW50IGJlZm9yZSBlbnRlcmluZyB0aGUgZGV0ZWN0aW9uXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgYXJlIGluIGEgdG91Y2gvZG93biBzdGF0ZSwgc28gYWxsb3dlZCBkZXRlY3Rpb24gb2YgZ2VzdHVyZXNcbiAgICAgIGlmKHNlbGYuc2hvdWxkRGV0ZWN0KSB7XG4gICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IGZhbHNlO1xuICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyZXZlbnQgb2JqZWN0IGFmdGVyIHRoZSBkZXRlY3Rpb25cbiAgICAgIH1cblxuICAgICAgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oZWxlbWVudCwgRVZFTlRfVFlQRVNbZXZlbnRUeXBlXSwgb25Ub3VjaEhhbmRsZXIpO1xuICAgIHJldHVybiBvblRvdWNoSGFuZGxlcjtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgZGV0ZWN0aW9uIG1ldGhvZFxuICAgKiB0aGlzIGZpbmRzIG91dCB3aGF0IEdlc3R1cmVEZXRlY3Rvci10b3VjaC1ldmVudHMgdG8gdHJpZ2dlclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdHJpZ2dlclR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqL1xuICBkb0RldGVjdDogZnVuY3Rpb24gZG9EZXRlY3QoZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcikge1xuICAgIHZhciB0b3VjaExpc3QgPSB0aGlzLmdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKTtcbiAgICB2YXIgdG91Y2hMaXN0TGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aDtcbiAgICB2YXIgdHJpZ2dlclR5cGUgPSBldmVudFR5cGU7XG4gICAgdmFyIHRyaWdnZXJDaGFuZ2UgPSB0b3VjaExpc3QudHJpZ2dlcjsgLy8gdXNlZCBieSBmYWtlTXVsdGl0b3VjaCBwbHVnaW5cbiAgICB2YXIgY2hhbmdlZExlbmd0aCA9IHRvdWNoTGlzdExlbmd0aDtcblxuICAgIC8vIGF0IGVhY2ggdG91Y2hzdGFydC1saWtlIGV2ZW50IHdlIHdhbnQgYWxzbyB3YW50IHRvIHRyaWdnZXIgYSBUT1VDSCBldmVudC4uLlxuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1RPVUNIO1xuICAgICAgLy8gLi4udGhlIHNhbWUgZm9yIGEgdG91Y2hlbmQtbGlrZSBldmVudFxuICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfUkVMRUFTRTtcblxuICAgICAgLy8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtICgoZXYuY2hhbmdlZFRvdWNoZXMpID8gZXYuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDogMSk7XG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgb24gdGhlIHNjcmVlbixcbiAgICAvLyB3ZSBqdXN0IHdhbnQgdG8gdHJpZ2dlciBhIE1PVkUgZXZlbnQuIHNvIGNoYW5nZSB0aGUgU1RBUlQgb3IgRU5EIHRvIGEgTU9WRVxuICAgIC8vIGJ1dCBvbmx5IGFmdGVyIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB0aGUgZmlyc3QgdGltZSB3ZSBhY3R1YWxseSB3YW50IGEgU1RBUlRcbiAgICBpZihjaGFuZ2VkTGVuZ3RoID4gMCAmJiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRyaWdnZXJUeXBlID0gRVZFTlRfTU9WRTtcbiAgICB9XG5cbiAgICAvLyBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGlzLCBzZWUgYWJvdmVcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgLy8gZ2VuZXJhdGUgc29tZSBldmVudCBkYXRhLCBzb21lIGJhc2ljIGluZm9ybWF0aW9uXG4gICAgdmFyIGV2RGF0YSA9IHRoaXMuY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCB0cmlnZ2VyVHlwZSwgdG91Y2hMaXN0LCBldik7XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSB0cmlnZ2VyVHlwZSBldmVudCBiZWZvcmUgdGhlIGNoYW5nZSAoVE9VQ0gsIFJFTEVBU0UpIGV2ZW50c1xuICAgIC8vIGJ1dCB0aGUgRU5EIGV2ZW50IHNob3VsZCBiZSBhdCBsYXN0XG4gICAgaWYoZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGEgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnQsIHRoaXMgbWVhbnMgdGhlIGxlbmd0aCBvZiB0aGUgdG91Y2hlcyBjaGFuZ2VkXG4gICAgaWYodHJpZ2dlckNoYW5nZSkge1xuICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJDaGFuZ2U7XG5cbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyVHlwZTtcbiAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBFTkQgZXZlbnRcbiAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaWdnZXJUeXBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiB3ZSBoYXZlIGRpZmZlcmVudCBldmVudHMgZm9yIGVhY2ggZGV2aWNlL2Jyb3dzZXJcbiAgICogZGV0ZXJtaW5lIHdoYXQgd2UgbmVlZCBhbmQgc2V0IHRoZW0gaW4gdGhlIEVWRU5UX1RZUEVTIGNvbnN0YW50XG4gICAqIHRoZSBgb25Ub3VjaGAgbWV0aG9kIGlzIGJpbmQgdG8gdGhlc2UgcHJvcGVydGllcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBldmVudHNcbiAgICovXG4gIGRldGVybWluZUV2ZW50VHlwZXM6IGZ1bmN0aW9uIGRldGVybWluZUV2ZW50VHlwZXMoKSB7XG4gICAgdmFyIHR5cGVzO1xuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgaWYod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICB0eXBlcyA9IFtcbiAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICdwb2ludGVybW92ZScsXG4gICAgICAgICAgJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIGxvc3Rwb2ludGVyY2FwdHVyZSdcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAnTVNQb2ludGVyTW92ZScsXG4gICAgICAgICAgJ01TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCBNU0xvc3RQb2ludGVyQ2FwdHVyZSdcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTKSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJ1xuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsXG4gICAgICAgICd0b3VjaG1vdmUgbW91c2Vtb3ZlJyxcbiAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAnXG4gICAgICBdO1xuICAgIH1cblxuICAgIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSA9IHR5cGVzWzBdO1xuICAgIEVWRU5UX1RZUEVTW0VWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfRU5EXSA9IHR5cGVzWzJdO1xuICAgIHJldHVybiBFVkVOVF9UWVBFUztcbiAgfSxcblxuICAvKipcbiAgICogY3JlYXRlIHRvdWNoTGlzdCBkZXBlbmRpbmcgb24gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGVzXG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKSB7XG4gICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICBpZihHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIHJldHVybiBQb2ludGVyRXZlbnQuZ2V0VG91Y2hMaXN0KCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB0b3VjaGxpc3RcbiAgICBpZihldi50b3VjaGVzKSB7XG4gICAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfTU9WRSkge1xuICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0KFV0aWxzLnRvQXJyYXkoZXYudG91Y2hlcyksIFV0aWxzLnRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpKTtcbiAgICAgIHZhciB0b3VjaExpc3QgPSBbXTtcblxuICAgICAgVXRpbHMuZWFjaChjb25jYXQsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIGlmKFV0aWxzLmluQXJyYXkoaWRlbnRpZmllcnMsIHRvdWNoLmlkZW50aWZpZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRvdWNoTGlzdC5wdXNoKHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRvdWNoLmlkZW50aWZpZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0b3VjaExpc3Q7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBmYWtlIHRvdWNoTGlzdCBmcm9tIG1vdXNlIHBvc2l0aW9uXG4gICAgZXYuaWRlbnRpZmllciA9IDE7XG4gICAgcmV0dXJuIFtldl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbGxlY3QgYmFzaWMgZXZlbnQgZGF0YVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGNvbGxlY3RFdmVudERhdGE6IGZ1bmN0aW9uIGNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgZXZlbnRUeXBlLCB0b3VjaGVzLCBldikge1xuICAgIC8vIGZpbmQgb3V0IHBvaW50ZXJUeXBlXG4gICAgdmFyIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9UT1VDSDtcbiAgICBpZihVdGlscy5pblN0cihldi50eXBlLCAnbW91c2UnKSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfTU9VU0UsIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX01PVVNFO1xuICAgIH0gZWxzZSBpZihQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfUEVOLCBldikpIHtcbiAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9QRU47XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlcjogVXRpbHMuZ2V0Q2VudGVyKHRvdWNoZXMpLFxuICAgICAgdGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXG4gICAgICB0b3VjaGVzOiB0b3VjaGVzLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXYsXG5cbiAgICAgIC8qKlxuICAgICAgICogcHJldmVudCB0aGUgYnJvd3NlciBkZWZhdWx0IGFjdGlvbnNcbiAgICAgICAqIG1vc3RseSB1c2VkIHRvIGRpc2FibGUgc2Nyb2xsaW5nIG9mIHRoZSBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gdGhpcy5zcmNFdmVudDtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0ICYmIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHN0b3AgYnViYmxpbmcgdGhlIGV2ZW50IHVwIHRvIGl0cyBwYXJlbnRzXG4gICAgICAgKi9cbiAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICAqIG1pZ2h0IGJlIHVzZWZ1bCBhZnRlciBhIHN3aXBlIHdhcyBkZXRlY3RlZFxuICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAqL1xuICAgICAgc3RvcERldGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBEZXRlY3Rpb24uc3RvcERldGVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBQb2ludGVyRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xuUG9pbnRlckV2ZW50ID0gR2VzdHVyZURldGVjdG9yLlBvaW50ZXJFdmVudCA9IHtcbiAgLyoqXG4gICAqIGhvbGRzIGFsbCBwb2ludGVycywgYnkgYGlkZW50aWZpZXJgXG4gICAqIEBwcm9wZXJ0eSBwb2ludGVyc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9pbnRlcnM6IHt9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHBvaW50ZXJzIGFzIGFuIGFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGxpc3RcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KCkge1xuICAgIHZhciB0b3VjaGxpc3QgPSBbXTtcbiAgICAvLyB3ZSBjYW4gdXNlIGZvckVhY2ggc2luY2UgcG9pbnRlckV2ZW50cyBvbmx5IGlzIGluIElFMTBcbiAgICBVdGlscy5lYWNoKHRoaXMucG9pbnRlcnMsIGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBwb2ludGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcbiAgICovXG4gIHVwZGF0ZVBvaW50ZXI6IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBwb2ludGVyRXZlbnQpIHtcbiAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EIHx8IChldmVudFR5cGUgIT0gRVZFTlRfRU5EICYmIHBvaW50ZXJFdmVudC5idXR0b25zICE9PSAxKSkge1xuICAgICAgZGVsZXRlIHRoaXMucG9pbnRlcnNbcG9pbnRlckV2ZW50LnBvaW50ZXJJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJFdmVudC5pZGVudGlmaWVyID0gcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgIHRoaXMucG9pbnRlcnNbcG9pbnRlckV2ZW50LnBvaW50ZXJJZF0gPSBwb2ludGVyRXZlbnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjaGVjayBpZiBldiBtYXRjaGVzIHBvaW50ZXJ0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludGVyVHlwZSBtYXRjaGVzIGBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTmBcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2XG4gICAqL1xuICBtYXRjaFR5cGU6IGZ1bmN0aW9uIG1hdGNoVHlwZShwb2ludGVyVHlwZSwgZXYpIHtcbiAgICBpZighZXYucG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHQgPSBldi5wb2ludGVyVHlwZSxcbiAgICAgICAgdHlwZXMgPSB7fTtcblxuICAgIHR5cGVzW1BPSU5URVJfTU9VU0VdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgUE9JTlRFUl9NT1VTRSkpO1xuICAgIHR5cGVzW1BPSU5URVJfVE9VQ0hdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgUE9JTlRFUl9UT1VDSCkpO1xuICAgIHR5cGVzW1BPSU5URVJfUEVOXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1BFTiB8fCBQT0lOVEVSX1BFTikpO1xuICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlc2V0IHRoZSBzdG9yZWQgcG9pbnRlcnNcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XG4gICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgRGV0ZWN0aW9uXG4gKiBAc3RhdGljXG4gKi9cbkRldGVjdGlvbiA9IEdlc3R1cmVEZXRlY3Rvci5kZXRlY3Rpb24gPSB7XG4gIC8vIGNvbnRhaW5zIGFsbCByZWdpc3RlcmVkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICBnZXN0dXJlczogW10sXG5cbiAgLy8gZGF0YSBvZiB0aGUgY3VycmVudCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gc2Vzc2lvblxuICBjdXJyZW50OiBudWxsLFxuXG4gIC8vIHRoZSBwcmV2aW91cyBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBzZXNzaW9uIGRhdGFcbiAgLy8gaXMgYSBmdWxsIGNsb25lIG9mIHRoZSBwcmV2aW91cyBnZXN0dXJlLmN1cnJlbnQgb2JqZWN0XG4gIHByZXZpb3VzOiBudWxsLFxuXG4gIC8vIHdoZW4gdGhpcyBiZWNvbWVzIHRydWUsIG5vIGdlc3R1cmVzIGFyZSBmaXJlZFxuICBzdG9wcGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogc3RhcnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSB7R2VzdHVyZURldGVjdG9yLkluc3RhbmNlfSBpbnN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICovXG4gIHN0YXJ0RGV0ZWN0OiBmdW5jdGlvbiBzdGFydERldGVjdChpbnN0LCBldmVudERhdGEpIHtcbiAgICAvLyBhbHJlYWR5IGJ1c3kgd2l0aCBhIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBvbiBhbiBlbGVtZW50XG4gICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvLyBob2xkcyBjdXJyZW50IHNlc3Npb25cbiAgICB0aGlzLmN1cnJlbnQgPSB7XG4gICAgICBpbnN0OiBpbnN0LCAvLyByZWZlcmVuY2UgdG8gR2VzdHVyZURldGVjdG9ySW5zdGFuY2Ugd2UncmUgd29ya2luZyBmb3JcbiAgICAgIHN0YXJ0RXZlbnQ6IFV0aWxzLmV4dGVuZCh7fSwgZXZlbnREYXRhKSwgLy8gc3RhcnQgZXZlbnREYXRhIGZvciBkaXN0YW5jZXMsIHRpbWluZyBldGNcbiAgICAgIGxhc3RFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhXG4gICAgICBsYXN0Q2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGZ1dHVyZUNhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICBsYXN0Q2FsY0RhdGE6IHt9LCAvLyBsYXN0IGxhc3RDYWxjRGF0YVxuICAgICAgbmFtZTogJycgLy8gY3VycmVudCBnZXN0dXJlIHdlJ3JlIGluL2RldGVjdGVkLCBjYW4gYmUgJ3RhcCcsICdob2xkJyBldGNcbiAgICB9O1xuXG4gICAgdGhpcy5kZXRlY3QoZXZlbnREYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZGV0ZWN0OiBmdW5jdGlvbiBkZXRlY3QoZXZlbnREYXRhKSB7XG4gICAgaWYoIXRoaXMuY3VycmVudCB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgZXZlbnQgZGF0YSB3aXRoIGNhbGN1bGF0aW9ucyBhYm91dCBzY2FsZSwgZGlzdGFuY2UgZXRjXG4gICAgZXZlbnREYXRhID0gdGhpcy5leHRlbmRFdmVudERhdGEoZXZlbnREYXRhKTtcblxuICAgIC8vIEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZSBhbmQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIHZhciBpbnN0ID0gdGhpcy5jdXJyZW50Lmluc3QsXG4gICAgICAgIGluc3RPcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgLy8gY2FsbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYW5kbGVyc1xuICAgIFV0aWxzLmVhY2godGhpcy5nZXN0dXJlcywgZnVuY3Rpb24gdHJpZ2dlckdlc3R1cmUoZ2VzdHVyZSkge1xuICAgICAgLy8gb25seSB3aGVuIHRoZSBpbnN0YW5jZSBvcHRpb25zIGhhdmUgZW5hYmxlZCB0aGlzIGdlc3R1cmVcbiAgICAgIGlmKCF0aGlzLnN0b3BwZWQgJiYgaW5zdC5lbmFibGVkICYmIGluc3RPcHRpb25zW2dlc3R1cmUubmFtZV0pIHtcbiAgICAgICAgZ2VzdHVyZS5oYW5kbGVyLmNhbGwoZ2VzdHVyZSwgZXZlbnREYXRhLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHN0b3JlIGFzIHByZXZpb3VzIGV2ZW50IGV2ZW50XG4gICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGFzdEV2ZW50ID0gZXZlbnREYXRhO1xuICAgIH1cblxuICAgIGlmKGV2ZW50RGF0YS5ldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICB0aGlzLnN0b3BEZXRlY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnREYXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIH0sXG5cbiAgLyoqXG4gICAqIGNsZWFyIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB2YXJzXG4gICAqIHRoaXMgaXMgY2FsbGVkIG9uIGVuZERldGVjdCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgd2hlbiBhIGZpbmFsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhcyBiZWVuIGRldGVjdGVkXG4gICAqIHRvIHN0b3Agb3RoZXIgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGZyb20gYmVpbmcgZmlyZWRcbiAgICovXG4gIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uIHN0b3BEZXRlY3QoKSB7XG4gICAgLy8gY2xvbmUgY3VycmVudCBkYXRhIHRvIHRoZSBzdG9yZSBhcyB0aGUgcHJldmlvdXMgZ2VzdHVyZVxuICAgIC8vIHVzZWQgZm9yIHRoZSBkb3VibGUgdGFwIGdlc3R1cmUsIHNpbmNlIHRoaXMgaXMgYW4gb3RoZXIgZ2VzdHVyZSBkZXRlY3Qgc2Vzc2lvblxuICAgIHRoaXMucHJldmlvdXMgPSBVdGlscy5leHRlbmQoe30sIHRoaXMuY3VycmVudCk7XG5cbiAgICAvLyByZXNldCB0aGUgY3VycmVudFxuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHZlbG9jaXR5LCBhbmdsZSBhbmQgZGlyZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAqL1xuICBnZXRDYWxjdWxhdGVkRGF0YTogZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgIHJlY2FsYyA9IGZhbHNlLFxuICAgICAgICBjYWxjRXYgPSBjdXIubGFzdENhbGNFdmVudCxcbiAgICAgICAgY2FsY0RhdGEgPSBjdXIubGFzdENhbGNEYXRhO1xuXG4gICAgaWYoY2FsY0V2ICYmIGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXAgPiBHZXN0dXJlRGV0ZWN0b3IuQ0FMQ1VMQVRFX0lOVEVSVkFMKSB7XG4gICAgICBjZW50ZXIgPSBjYWxjRXYuY2VudGVyO1xuICAgICAgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcDtcbiAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gY2FsY0V2LmNlbnRlci5jbGllbnRYO1xuICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBjYWxjRXYuY2VudGVyLmNsaWVudFk7XG4gICAgICByZWNhbGMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGlmKCFjdXIubGFzdENhbGNFdmVudCB8fCByZWNhbGMpIHtcbiAgICAgIGNhbGNEYXRhLnZlbG9jaXR5ID0gVXRpbHMuZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBjYWxjRGF0YS5hbmdsZSA9IFV0aWxzLmdldEFuZ2xlKGNlbnRlciwgZXYuY2VudGVyKTtcbiAgICAgIGNhbGNEYXRhLmRpcmVjdGlvbiA9IFV0aWxzLmdldERpcmVjdGlvbihjZW50ZXIsIGV2LmNlbnRlcik7XG5cbiAgICAgIGN1ci5sYXN0Q2FsY0V2ZW50ID0gY3VyLmZ1dHVyZUNhbGNFdmVudCB8fCBldjtcbiAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICB9XG5cbiAgICBldi52ZWxvY2l0eVggPSBjYWxjRGF0YS52ZWxvY2l0eS54O1xuICAgIGV2LnZlbG9jaXR5WSA9IGNhbGNEYXRhLnZlbG9jaXR5Lnk7XG4gICAgZXYuaW50ZXJpbUFuZ2xlID0gY2FsY0RhdGEuYW5nbGU7XG4gICAgZXYuaW50ZXJpbURpcmVjdGlvbiA9IGNhbGNEYXRhLmRpcmVjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogZXh0ZW5kIGV2ZW50RGF0YSBmb3IgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAqL1xuICBleHRlbmRFdmVudERhdGE6IGZ1bmN0aW9uIGV4dGVuZEV2ZW50RGF0YShldikge1xuICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgIHN0YXJ0RXYgPSBjdXIuc3RhcnRFdmVudCxcbiAgICAgICAgbGFzdEV2ID0gY3VyLmxhc3RFdmVudCB8fCBzdGFydEV2O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzdGFydCB0b3VjaGxpc3QgdG8gY2FsY3VsYXRlIHRoZSBzY2FsZS9yb3RhdGlvblxuICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgc3RhcnRFdi50b3VjaGVzID0gW107XG4gICAgICBVdGlscy5lYWNoKGV2LnRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHN0YXJ0RXYudG91Y2hlcy5wdXNoKHtcbiAgICAgICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gc3RhcnRFdi50aW1lU3RhbXAsXG4gICAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WCxcbiAgICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBzdGFydEV2LmNlbnRlci5jbGllbnRZO1xuXG4gICAgdGhpcy5nZXRDYWxjdWxhdGVkRGF0YShldiwgbGFzdEV2LmNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICBVdGlscy5leHRlbmQoZXYsIHtcbiAgICAgIHN0YXJ0RXZlbnQ6IHN0YXJ0RXYsXG5cbiAgICAgIGRlbHRhVGltZTogZGVsdGFUaW1lLFxuICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICBkZWx0YVk6IGRlbHRhWSxcblxuICAgICAgZGlzdGFuY2U6IFV0aWxzLmdldERpc3RhbmNlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgYW5nbGU6IFV0aWxzLmdldEFuZ2xlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgZGlyZWN0aW9uOiBVdGlscy5nZXREaXJlY3Rpb24oc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBzY2FsZTogVXRpbHMuZ2V0U2NhbGUoc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcbiAgICAgIHJvdGF0aW9uOiBVdGlscy5nZXRSb3RhdGlvbihzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVyIG5ldyBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnZXN0dXJlIG9iamVjdCwgc2VlIGBnZXN0dXJlcy9gIGZvciBkb2N1bWVudGF0aW9uXG4gICAqIEByZXR1cm4ge0FycmF5fSBnZXN0dXJlc1xuICAgKi9cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGdlc3R1cmUpIHtcbiAgICAvLyBhZGQgYW4gZW5hYmxlIGdlc3R1cmUgb3B0aW9ucyBpZiB0aGVyZSBpcyBubyBnaXZlblxuICAgIHZhciBvcHRpb25zID0gZ2VzdHVyZS5kZWZhdWx0cyB8fCB7fTtcbiAgICBpZihvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9uc1tnZXN0dXJlLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgR2VzdHVyZURldGVjdG9yIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBvcHRpb25zXG4gICAgVXRpbHMuZXh0ZW5kKEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAvLyBzZXQgaXRzIGluZGV4XG4gICAgZ2VzdHVyZS5pbmRleCA9IGdlc3R1cmUuaW5kZXggfHwgMTAwMDtcblxuICAgIC8vIGFkZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB0byB0aGUgbGlzdFxuICAgIHRoaXMuZ2VzdHVyZXMucHVzaChnZXN0dXJlKTtcblxuICAgIC8vIHNvcnQgdGhlIGxpc3QgYnkgaW5kZXhcbiAgICB0aGlzLmdlc3R1cmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYoYS5pbmRleCA8IGIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqL1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqXG4gKiBAY2xhc3MgSW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzYFxuICogQHJldHVybiB7R2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBzZXR1cCBHZXN0dXJlRGV0ZWN0b3JKUyB3aW5kb3cgZXZlbnRzIGFuZCByZWdpc3RlciBhbGwgZ2VzdHVyZXNcbiAgLy8gdGhpcyBhbHNvIHNldHMgdXAgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICBzZXR1cCgpO1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZWxlbWVudFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZW5hYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogb3B0aW9ucywgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRzXG4gICAqIG9wdGlvbnMgd2l0aCBhbiBfIGFyZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBVdGlscy5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgb3B0aW9uc1tVdGlscy50b0NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgdGhpcy5vcHRpb25zID0gVXRpbHMuZXh0ZW5kKFV0aWxzLmV4dGVuZCh7fSwgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzKSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gYWRkIHNvbWUgY3NzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZyBpdHMgbmF0aXZlIGJlaGF2aW9yXG4gIGlmKHRoaXMub3B0aW9ucy5iZWhhdmlvcikge1xuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBldmVudCBzdGFydCBoYW5kbGVyIG9uIHRoZSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBkZXRlY3Rpb25cbiAgICogQHByb3BlcnR5IGV2ZW50U3RhcnRIYW5kbGVyXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyID0gRXZlbnQub25Ub3VjaChlbGVtZW50LCBFVkVOVF9TVEFSVCwgZnVuY3Rpb24oZXYpIHtcbiAgICBpZihzZWxmLmVuYWJsZWQgJiYgZXYuZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICBEZXRlY3Rpb24uc3RhcnREZXRlY3Qoc2VsZiwgZXYpO1xuICAgIH0gZWxzZSBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgIERldGVjdGlvbi5kZXRlY3QoZXYpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGtlZXAgYSBsaXN0IG9mIHVzZXIgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbmVlZHMgdG8gYmUgcmVtb3ZlZCB3aGVuIGNhbGxpbmcgJ2Rpc3Bvc2UnXG4gICAqIEBwcm9wZXJ0eSBldmVudEhhbmRsZXJzXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xufTtcblxuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBtZXRob2Qgb25cbiAgICogQHNpZ25hdHVyZSBvbihnZXN0dXJlcywgaGFuZGxlcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQWRkcyBhbiBldmVudCBoYW5kbGVyIGZvciBhIGdlc3R1cmUuIEF2YWlsYWJsZSBnZXN0dXJlcyBhcmU6IGRyYWcsIGRyYWdsZWZ0LCBkcmFncmlnaHQsIGRyYWd1cCwgZHJhZ2Rvd24sIGhvbGQsIHJlbGVhc2UsIHN3aXBlLCBzd2lwZWxlZnQsIHN3aXBlcmlnaHQsIHN3aXBldXAsIHN3aXBlZG93biwgdGFwLCBkb3VibGV0YXAsIHRvdWNoLCB0cmFuc2Zvcm0sIHBpbmNoLCBwaW5jaGluLCBwaW5jaG91dCBhbmQgcm90YXRlLiBbL2VuXVxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+OBq+WvvuOBmeOCi+OCpOODmeODs+ODiOODj+ODs+ODieODqeOCkui/veWKoOOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OCuOOCp+OCueODgeODo+WQjeOBr+OAgWRyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBob2xkIHJlbGVhc2Ugc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24gdGFwIGRvdWJsZXRhcCB0b3VjaCB0cmFuc2Zvcm0gcGluY2ggcGluY2hpbiBwaW5jaG91dCByb3RhdGUg44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICogICBbamFd5qSc55+l44GZ44KL44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgRXZlbnQub24oc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnB1c2goeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9mZlxuICAgKiBAc2lnbmF0dXJlIG9mZihnZXN0dXJlcywgaGFuZGxlcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICogICBbamFd44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIEV2ZW50Lm9mZihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICAgIGlmKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICBzZWxmLmV2ZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogdHJpZ2dlciBnZXN0dXJlIGV2ZW50XG4gICAqIEBtZXRob2QgdHJpZ2dlclxuICAgKiBAc2lnbmF0dXJlIHRyaWdnZXIoZ2VzdHVyZSwgZXZlbnREYXRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV1cbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChnZXN0dXJlLCBldmVudERhdGEpIHtcbiAgICAvLyBvcHRpb25hbFxuICAgIGlmKCFldmVudERhdGEpIHtcbiAgICAgIGV2ZW50RGF0YSA9IHt9O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBET00gZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGdlc3R1cmUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50Lmdlc3R1cmUgPSBldmVudERhdGE7XG5cbiAgICAvLyB0cmlnZ2VyIG9uIHRoZSB0YXJnZXQgaWYgaXQgaXMgaW4gdGhlIGluc3RhbmNlIGVsZW1lbnQsXG4gICAgLy8gdGhpcyBpcyBmb3IgZXZlbnQgZGVsZWdhdGlvbiB0cmlja3NcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZihVdGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZW5hYmxlXG4gICAqIEBzaWduYXR1cmUgZW5hYmxlKHN0YXRlKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbmFibGUgb3IgZGlzYWJsZSBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+aknOefpeOCkuacieWKueWMli/nhKHlirnljJbjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIGVuYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeacieWKueOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICogQHNpZ25hdHVyZSBkaXNwb3NlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuZCBkZXN0cm95IGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5bL2VuXVxuICAgKiAgW2phXeOBk+OBruOCpOODs+OCueOCv+ODs+OCueOBp+OBruOCuOOCp+OCueODgeODo+OBruaknOefpeOChOOAgeOCpOODmeODs+ODiOODj+ODs+ODieODqeOCkuWFqOOBpuino+mZpOOBl+OBpuW7g+ajhOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHZhciBpLCBlaDtcblxuICAgIC8vIHVuZG8gYWxsIGNoYW5nZXMgbWFkZSBieSBzdG9wX2Jyb3dzZXJfYmVoYXZpb3JcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xuXG4gICAgLy8gdW5iaW5kIGFsbCBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgICBmb3IoaSA9IC0xOyAoZWggPSB0aGlzLmV2ZW50SGFuZGxlcnNbKytpXSk7KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgIFV0aWxzLm9mZih0aGlzLmVsZW1lbnQsIGVoLmdlc3R1cmUsIGVoLmhhbmRsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgLy8gdW5iaW5kIHRoZSBzdGFydCBldmVudCBsaXN0ZW5lclxuICAgIEV2ZW50Lm9mZih0aGlzLmVsZW1lbnQsIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSwgdGhpcy5ldmVudFN0YXJ0SGFuZGxlcik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS5cbiAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy5cbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihldikge1xuICogICAgY29uc29sZS5sb2coZXYpO1xuICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICogIH0pO1xuICogYGBgYFxuICpcbiAqIEBjbGFzcyBEcmFnXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhcGxlZnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFncmlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFndXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZG93blxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZHJhZ0dlc3R1cmUoZXYsIGluc3QpIHtcbiAgICB2YXIgY3VyID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAvLyBtYXggdG91Y2hlc1xuICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcyA+IDAgJiZcbiAgICAgIGV2LnRvdWNoZXMubGVuZ3RoID4gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgaWYoZXYuZGlzdGFuY2UgPCBpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlICYmXG4gICAgICAgIGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRDZW50ZXIgPSBjdXIuc3RhcnRFdmVudC5jZW50ZXI7XG5cbiAgICAgIC8vIHdlIGFyZSBkcmFnZ2luZyFcbiAgICAgIGlmKGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgY3VyLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgZnJvbSB0aGUgb3JpZ2luYWwgZXZlbnQgY2VudGVyLlxuICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyBjb3JyZWN0aW9uLCB0aGUgZHJhZ2dlZCBkaXN0YW5jZSB3b3VsZCBqdW1wc3RhcnQgYXQgZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBpbnN0ZWFkIG9mIGF0IDAuXG4gICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdXNlZnVsIHRvIHNhdmUgdGhlIG9yaWdpbmFsIHN0YXJ0IHBvaW50IHNvbWV3aGVyZVxuICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG5cbiAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxuICAgICAgICAgIGV2ID0gRGV0ZWN0aW9uLmV4dGVuZEV2ZW50RGF0YShldik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbG9jayBkcmFnIHRvIGF4aXM/XG4gICAgICBpZihjdXIubGFzdEV2ZW50LmRyYWdMb2NrVG9BeGlzIHx8XG4gICAgICAgICggaW5zdC5vcHRpb25zLmRyYWdMb2NrVG9BeGlzICYmXG4gICAgICAgICAgaW5zdC5vcHRpb25zLmRyYWdMb2NrTWluRGlzdGFuY2UgPD0gZXYuZGlzdGFuY2VcbiAgICAgICAgKSkge1xuICAgICAgICAgIGV2LmRyYWdMb2NrVG9BeGlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgZGlyZWN0aW9uIG9uIHRoZSBheGlzIHRoYXQgdGhlIGRyYWcgZ2VzdHVyZSBzdGFydGVkIG9uXG4gICAgICAgIHZhciBsYXN0RGlyZWN0aW9uID0gY3VyLmxhc3RFdmVudC5kaXJlY3Rpb247XG4gICAgICAgIGlmKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgIGlmKFV0aWxzLmlzVmVydGljYWwobGFzdERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFYIDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRzXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG5cbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSBVdGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbik7XG5cbiAgICAgICAgLy8gYmxvY2sgdGhlIGJyb3dzZXIgZXZlbnRzXG4gICAgICAgIGlmKChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrVmVydGljYWwgJiYgaXNWZXJ0aWNhbCkgfHxcbiAgICAgICAgICAoaW5zdC5vcHRpb25zLmRyYWdCbG9ja0hvcml6b250YWwgJiYgIWlzVmVydGljYWwpKSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8PSBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkRyYWcgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDUwLFxuICAgICAgaGFuZGxlcjogZHJhZ0dlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBtb3ZlbWVudCB0aGF0IGhhdmUgdG8gYmUgbWFkZSBiZWZvcmUgdGhlIGRyYWcgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xuICAgICAgICAgKiBiZSBjYWxjdWxhdGVkIGZyb20gd2hlcmUgdGhlIGRyYWcgd2FzIHRyaWdnZXJlZCwgbm90IGZyb20gd2hlcmUgdGhlIHRvdWNoIHN0YXJ0ZWQuXG4gICAgICAgICAqIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgICAgICAgKiB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWF4VG91Y2hlczogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igd2hlbiBkcmFnZ2luZyBvY2N1cnNcbiAgICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIGl0LCBpdCBtYWtlcyB0aGUgZWxlbWVudCBhIGJsb2NraW5nIGVsZW1lbnRcbiAgICAgICAgICogd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tIb3Jpem9udGFsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrSG9yaXpvbnRhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhbWUgYXMgYGRyYWdCbG9ja0hvcml6b250YWxgLCBidXQgZm9yIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tWZXJ0aWNhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja1ZlcnRpY2FsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZ0xvY2tUb0F4aXMga2VlcHMgdGhlIGRyYWcgZ2VzdHVyZSBvbiB0aGUgYXhpcyB0aGF0IGl0IHN0YXJ0ZWQgb24sXG4gICAgICAgICAqIEl0IGRpc2FsbG93cyB2ZXJ0aWNhbCBkaXJlY3Rpb25zIGlmIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB3YXMgaG9yaXpvbnRhbCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrVG9BeGlzOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogVGhpcyB3YXksIGxvY2tpbmcgb2NjdXJzIG9ubHkgd2hlbiB0aGUgZGlzdGFuY2UgaGFzIGJlY29tZSBsYXJnZSBlbm91Z2ggdG8gcmVsaWFibHkgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrTWluRGlzdGFuY2U6IDI1XG4gICAgICB9XG4gICAgfTtcbiAgfSkoJ2RyYWcnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXIgYSBzaW1wbGUgZ2VzdHVyZSBldmVudCwgc28geW91IGNhbiBkbyBhbnl0aGluZyBpbiB5b3VyIGhhbmRsZXIuXG4gICAqIG9ubHkgdXNhYmxlIGlmIHlvdSBrbm93IHdoYXQgeW91ciBkb2luZy4uLlxuICAgKlxuICAgKiBAY2xhc3MgR2VzdHVyZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuR2VzdHVyZSA9IHtcbiAgICBuYW1lOiAnZ2VzdHVyZScsXG4gICAgaW5kZXg6IDEzMzcsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBUb3VjaCBzdGF5cyBhdCB0aGUgc2FtZSBwbGFjZSBmb3IgeCB0aW1lXG4gICAqXG4gICAqIEBjbGFzcyBIb2xkXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgaG9sZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBnZXN0dXJlIHNvIHdlIGNhbiBjaGVjayBpbiB0aGUgdGltZW91dCBpZiBpdCBzdGlsbCBpc1xuICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIHNldCB0aW1lciBhbmQgaWYgYWZ0ZXIgdGhlIHRpbWVvdXQgaXQgc3RpbGwgaXMgaG9sZCxcbiAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoY3VycmVudCAmJiBjdXJyZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuaG9sZFRpbWVvdXQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBpZihldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkhvbGQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCA1MDBcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaW1lb3V0OiA1MDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmVtZW50IGFsbG93ZWQgd2hpbGUgaG9sZGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGhyZXNob2xkOiAyXG4gICAgICB9LFxuICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcbiAgICB9O1xuICB9KSgnaG9sZCcpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHJlbGVhc2VkIGZyb20gdGhlIHBhZ2VcbiAgICpcbiAgICogQGNsYXNzIFJlbGVhc2VcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByZWxlYXNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlJlbGVhc2UgPSB7XG4gICAgbmFtZTogJ3JlbGVhc2UnLFxuICAgIGluZGV4OiBJbmZpbml0eSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXJzIHN3aXBlIGV2ZW50cyB3aGVuIHRoZSBlbmQgdmVsb2NpdHkgaXMgYWJvdmUgdGhlIHRocmVzaG9sZFxuICAgKiBmb3IgYmVzdCB1c2FnZSwgc2V0IGBwcmV2ZW50RGVmYXVsdGAgKG9uIHRoZSBkcmFnIGdlc3R1cmUpIHRvIGB0cnVlYFxuICAgKiBgYGBgXG4gICAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ2xlZnQgc3dpcGVsZWZ0XCIsIGZ1bmN0aW9uKGV2KSB7XG4gICAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAgICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgKiAgfSk7XG4gICAqIGBgYGBcbiAgICpcbiAgICogQGNsYXNzIFN3aXBlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlbGVmdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVyaWdodFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGV1cFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlN3aXBlID0ge1xuICAgIG5hbWU6ICdzd2lwZScsXG4gICAgaW5kZXg6IDQwLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1pblRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWluVG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNYXhUb3VjaGVzXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBzd2lwZU1heFRvdWNoZXM6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICogaG9yaXpvbnRhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlYXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlYOiAwLjYsXG5cbiAgICAgIC8qKlxuICAgICAgICogdmVydGljYWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WVxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICovXG4gICAgICBzd2lwZVZlbG9jaXR5WTogMC42XG4gICAgfSxcblxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHN3aXBlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICAgaWYodG91Y2hlcyA8IG9wdGlvbnMuc3dpcGVNaW5Ub3VjaGVzIHx8XG4gICAgICAgICAgdG91Y2hlcyA+IG9wdGlvbnMuc3dpcGVNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKGV2LnZlbG9jaXR5WCA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVggfHxcbiAgICAgICAgICBldi52ZWxvY2l0eVkgPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlZKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBzd2lwZSBldmVudHNcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogU2luZ2xlIHRhcCBhbmQgYSBkb3VibGUgdGFwIG9uIGEgcGxhY2VcbiAgICpcbiAgICogQGNsYXNzIFRhcFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRhcFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZG91YmxldGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGhhc01vdmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0YXBHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgcHJldiA9IERldGVjdGlvbi5wcmV2aW91cyxcbiAgICAgICAgICBzaW5jZVByZXYsXG4gICAgICAgICAgZGlkRG91YmxlVGFwO1xuXG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBoYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBoYXNNb3ZlZCA9IGhhc01vdmVkIHx8IChldi5kaXN0YW5jZSA+IG9wdGlvbnMudGFwTWF4RGlzdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIGlmKCFVdGlscy5pblN0cihldi5zcmNFdmVudC50eXBlLCAnY2FuY2VsJykgJiYgZXYuZGVsdGFUaW1lIDwgb3B0aW9ucy50YXBNYXhUaW1lICYmICFoYXNNb3ZlZCkge1xuICAgICAgICAgIC8vIHByZXZpb3VzIGdlc3R1cmUsIGZvciB0aGUgZG91YmxlIHRhcCBzaW5jZSB0aGVzZSBhcmUgdHdvIGRpZmZlcmVudCBnZXN0dXJlIGRldGVjdGlvbnNcbiAgICAgICAgICBzaW5jZVByZXYgPSBwcmV2ICYmIHByZXYubGFzdEV2ZW50ICYmIGV2LnRpbWVTdGFtcCAtIHByZXYubGFzdEV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgICBkaWREb3VibGVUYXAgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGRvdWJsZSB0YXBcbiAgICAgICAgICBpZihwcmV2ICYmIHByZXYubmFtZSA9PSBuYW1lICYmXG4gICAgICAgICAgICAoc2luY2VQcmV2ICYmIHNpbmNlUHJldiA8IG9wdGlvbnMuZG91YmxlVGFwSW50ZXJ2YWwpICYmXG4gICAgICAgICAgICBldi5kaXN0YW5jZSA8IG9wdGlvbnMuZG91YmxlVGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcignZG91YmxldGFwJywgZXYpO1xuICAgICAgICAgICAgZGlkRG91YmxlVGFwID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkbyBhIHNpbmdsZSB0YXBcbiAgICAgICAgICBpZighZGlkRG91YmxlVGFwIHx8IG9wdGlvbnMudGFwQWx3YXlzKSB7XG4gICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKGN1cnJlbnQubmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVGFwID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMDAsXG4gICAgICBoYW5kbGVyOiB0YXBHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAgICAgKi9cbiAgICAgICAgdGFwTWF4VGltZTogMjUwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggZGlzdGFuY2Ugb2YgbW92ZW1lbnQgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhEaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFsd2F5cyB0cmlnZ2VyIHRoZSBgdGFwYCBldmVudCwgZXZlbiB3aGlsZSBkb3VibGUtdGFwcGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwQWx3YXlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0YXBBbHdheXM6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwRGlzdGFuY2U6IDIwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggdGltZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBJbnRlcnZhbFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAzMDBcbiAgICAgICAgICovXG4gICAgICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcbiAgICAgIH1cbiAgICB9O1xuICB9KSgndGFwJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgdG91Y2hlZCBhdCB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgVG91Y2hcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0b3VjaFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ub3VjaCA9IHtcbiAgICBuYW1lOiAndG91Y2gnLFxuICAgIGluZGV4OiAtSW5maW5pdHksXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnkgZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsXG4gICAgICAgKiBidXQgaXQgaW1wcm92ZXMgZ2VzdHVyZXMgbGlrZSB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxuICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIHVzaW5nIHRoaXMsIGl0IGNhbiBiZSB2ZXJ5IGFubm95aW5nIGZvciB1c2VycyB0byBiZSBzdHVjayBvbiB0aGUgcGFnZVxuICAgICAgICogQHByb3BlcnR5IHByZXZlbnREZWZhdWx0XG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudE1vdXNlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnRNb3VzZTogZmFsc2VcbiAgICB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHRvdWNoR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnRNb3VzZSAmJiBldi5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX01PVVNFKSB7XG4gICAgICAgIGV2LnN0b3BEZXRlY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcigndG91Y2gnLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICAgKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCB0aGVcbiAgICogYHByZXZlbnREZWZhdWx0YCBvcHRpb24uXG4gICAqXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1lbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNoaW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNob3V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByb3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1HZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxuICAgICAgICBpZihldi50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NhbGVUaHJlc2hvbGQgPSBNYXRoLmFicygxIC0gZXYuc2NhbGUpO1xuICAgICAgICB2YXIgcm90YXRpb25UaHJlc2hvbGQgPSBNYXRoLmFicyhldi5yb3RhdGlvbik7XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKHNjYWxlVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlICYmXG4gICAgICAgICAgcm90YXRpb25UaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICBEZXRlY3Rpb24uY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxuXG4gICAgICAgIC8vIHRyaWdnZXIgcm90YXRlIGV2ZW50XG4gICAgICAgIGlmKHJvdGF0aW9uVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdyb3RhdGUnLCBldik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIHBpbmNoIGV2ZW50XG4gICAgICAgIGlmKHNjYWxlVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArIChldi5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCcpLCBldik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPCAyKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UcmFuc2Zvcm0gPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDQ1LFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgc2NhbGUgZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5TY2FsZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5TY2FsZTogMC4wMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluUm90YXRpb25cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluUm90YXRpb246IDFcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZXI6IHRyYW5zZm9ybUdlc3R1cmVcbiAgICB9O1xuICB9KSgndHJhbnNmb3JtJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVEZXRlY3RvcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8qKlxuICogQG9iamVjdCBvbnMucGxhdGZvcm1cbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBkZXRlY3QgY3VycmVudCBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFd54++5Zyo5a6f6KGM44GV44KM44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqL1xuY2xhc3MgUGxhdGZvcm0ge1xuXG4gIC8qKlxuICAgKiBBbGwgZWxlbWVudHMgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiB0aGUgYXBwIHdhcyBydW5uaW5nIG9uIHRoaXMgcGxhdGZvcm0uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZWxlY3RcbiAgICogQHNpZ25hdHVyZSBzZWxlY3QocGxhdGZvcm0pXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGxhdGZvcm0gTmFtZSBvZiB0aGUgcGxhdGZvcm0uXG4gICAqICAgW2VuXVBvc3NpYmxlIHZhbHVlcyBhcmU6IFwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiIG9yIFwid3BcIi5bL2VuXVxuICAgKiAgIFtqYV1cIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiwgXCJ3cFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNldHMgdGhlIHBsYXRmb3JtIHVzZWQgdG8gcmVuZGVyIHRoZSBlbGVtZW50cy4gVXNlZnVsIGZvciB0ZXN0aW5nLlsvZW5dXG4gICAqICAgW2phXeimgee0oOOCkuaPj+eUu+OBmeOCi+OBn+OCgeOBq+WIqeeUqOOBmeOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOWQjeOCkuioreWumuOBl+OBvuOBmeOAguODhuOCueODiOOBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuICBzZWxlY3QocGxhdGZvcm0pIHtcbiAgICBpZiAodHlwZW9mIHBsYXRmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcmVuZGVyUGxhdGZvcm0gPSBwbGF0Zm9ybS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1dlYlZpZXdcbiAgICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIENvcmRvdmEuWy9lbl1cbiAgICogICBbamFdQ29yZG92YeWGheOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dlYlZpZXcoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1dlYlZpZXcoKSBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIGRvbSBjb250ZW50cyBsb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1MoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpb3MnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYW5kcm9pZCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgcGhvbmUuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOaQuuW4r+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRQaG9uZSgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkVGFibGV0XG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgdGFibGV0LlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkVGFibGV0KCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dQKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnd3AnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL1dpbjMyTlR8V2luQ0UvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvV2luZG93cyBQaG9uZXxJRU1vYmlsZXxXUERlc2t0b3AvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9zIGlzSVBob25lXG4gICAqIEBzaWduYXR1cmUgaXNJUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBob25lLlsvZW5dXG4gICAqICAgW2phXWlQaG9uZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lQYWRcbiAgICogQHNpZ25hdHVyZSBpc0lQYWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBhZC5bL2VuXVxuICAgKiAgIFtqYV1pUGFk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBhZCgpIHtcbiAgICByZXR1cm4gL2lQYWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQb2QoKSB7XG4gICAgcmV0dXJuIC9pUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQmxhY2tCZXJyeVxuICAgKiBAc2lnbmF0dXJlIGlzQmxhY2tCZXJyeSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBCbGFja0JlcnJ5LlsvZW5dXG4gICAqICAgW2phXUJsYWNrQmVycnnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNCbGFja0JlcnJ5KCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYmxhY2tiZXJyeSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5fFJJTSBUYWJsZXQgT1N8QkIxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVyYVxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIE9wZXJhLlsvZW5dXG4gICAqICAgW2phXU9wZXJh5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT3BlcmEoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdvcGVyYSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRmlyZWZveFxuICAgKiBAc2lnbmF0dXJlIGlzRmlyZWZveCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRmlyZWZveC5bL2VuXVxuICAgKiAgIFtqYV1GaXJlZm945LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRmlyZWZveCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2ZpcmVmb3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzU2FmYXJpXG4gICAqIEBzaWduYXR1cmUgaXNTYWZhcmkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIFNhZmFyaS5bL2VuXVxuICAgKiAgIFtqYV1TYWZhcmnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTYWZhcmkoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdzYWZhcmknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0Nocm9tZVxuICAgKiBAc2lnbmF0dXJlIGlzQ2hyb21lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBDaHJvbWUuWy9lbl1cbiAgICogICBbamFdQ2hyb21l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQ2hyb21lKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnY2hyb21lJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICghIXdpbmRvdy5jaHJvbWUgJiYgISghIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMCkgJiYgIShuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBFZGdlLycpID49IDApKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lFXG4gICAqIEBzaWduYXR1cmUgaXNJRSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXIuWy9lbl1cbiAgICogICBbamFdSW50ZXJuZXQgRXhwbG9yZXLkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJRSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2llJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRWRnZVxuICAgKiBAc2lnbmF0dXJlIGlzRWRnZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRWRnZS5bL2VuXVxuICAgKiAgIFtqYV1FZGdl5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRWRnZSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2VkZ2UnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSU9TN2Fib3ZlXG4gICAqIEBzaWduYXR1cmUgaXNJT1M3YWJvdmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBpT1MgdmVyc2lvbiBpcyA3IG9yIGFib3ZlLlsvZW5dXG4gICAqICAgW2phXWlPUzfku6XkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1M3YWJvdmUoKSB7XG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuICgvaU9TL2kudGVzdChkZXZpY2UucGxhdGZvcm0pICYmIChwYXJzZUludChkZXZpY2UudmVyc2lvbi5zcGxpdCgnLicpWzBdKSA+PSA3KSk7XG4gICAgfSBlbHNlIGlmKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc3QgdmVyID0gKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcYlswLTldK19bMC05XSsoPzpfWzAtOV0rKT9cXGIvKSB8fCBbJyddKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICByZXR1cm4gKHBhcnNlSW50KHZlci5zcGxpdCgnLicpWzBdKSA+PSA3KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vYmlsZU9TKCkge1xuICAgIGlmICh0aGlzLmlzQW5kcm9pZCgpKSB7XG4gICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcbiAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc1dQKCkpIHtcbiAgICAgIHJldHVybiAnd3AnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRJT1NEZXZpY2UoKSB7XG4gICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xuICAgICAgcmV0dXJuICdpcGhvbmUnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBhZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwYWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBvZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwb2QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnbmEnO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQbGF0Zm9ybSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmNvbnN0IHJlYWR5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gaXNDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlYWR5TWFwLmhhcyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgcmVhZHlNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDYWxsYmFjayhlbGVtZW50LCBmbikge1xuICBpZiAoIXF1ZXVlTWFwLmhhcyhlbGVtZW50KSkge1xuICAgIHF1ZXVlTWFwLnNldChlbGVtZW50LCBbXSk7XG4gIH1cbiAgcXVldWVNYXAuZ2V0KGVsZW1lbnQpLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lUXVldWUoZWxlbWVudCkge1xuICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZU1hcC5nZXQoZWxlbWVudCwgW10pIHx8IFtdO1xuICBxdWV1ZU1hcC5kZWxldGUoZWxlbWVudCk7XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250ZW50UmVhZHkoZWxlbWVudCwgZm4gPSAoKSA9PiB7fSkge1xuICBhZGRDYWxsYmFjayhlbGVtZW50LCBmbik7XG5cbiAgaWYgKGlzQ29udGVudFJlYWR5KGVsZW1lbnQpKSB7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIGFsZXJ0IGRpYWxvZ3MuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KClgXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZyBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgYTjgY/jgaTjgYvjga7nqK7poZ7jga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLkvZzmiJDjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ0hlbGxvLCB3b3JsZCEnKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oJ0FyZSB5b3UgcmVhZHk/JylcbiAqICAgLnRoZW4oXG4gKiAgICAgZnVuY3Rpb24oYW5zd2VyKSB7XG4gKiAgICAgICBpZiAoYW5zd2VyID09PSAxKSB7XG4gKiAgICAgICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ0xldFxcJ3MgZ28hJyk7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICApO1xuICpcbiAqIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KCdIb3cgb2xkIGFyZSA/JylcbiAqICAgLnRoZW4oXG4gKiAgICAgZnVuY3Rpb24oYWdlKSB7XG4gKiAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdZb3UgYXJlICcgKyBhZ2UgKyAnIHllYXJzIG9sZC4nKTtcbiAqICAgICB9XG4gKiAgICk7XG4gKi9cbmNvbnN0IG5vdGlmaWNhdGlvbiA9IHt9O1xuXG5ub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nID0gb3B0aW9ucyA9PiB7XG4gIC8vIFByb21wdCBpbnB1dCBzdHJpbmdcbiAgbGV0IGlucHV0U3RyaW5nID0gJyc7XG4gIGlmIChvcHRpb25zLmlzUHJvbXB0KSB7XG4gICAgaW5wdXRTdHJpbmcgPSBgXG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3M9XCJ0ZXh0LWlucHV0IHRleHQtaW5wdXQtLXVuZGVyYmFyXCJcbiAgICAgICAgdHlwZT1cIiR7b3B0aW9ucy5pbnB1dFR5cGUgfHwgJ3RleHQnfVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiJHtvcHRpb25zLnBsYWNlaG9sZGVyIHx8ICcnfVwiXG4gICAgICAgIHZhbHVlPVwiJHtvcHRpb25zLmRlZmF1bHRWYWx1ZSB8fCAnJ31cIlxuICAgICAgICBzdHlsZT1cIndpZHRoOiAxMDAlOyBtYXJnaW4tdG9wOiAxMHB4O1wiXG4gICAgICAvPlxuICAgIGA7XG4gIH1cblxuICAvLyBCdXR0b25zIHN0cmluZ1xuICBsZXQgYnV0dG9ucyA9ICcnO1xuICBvcHRpb25zLmJ1dHRvbkxhYmVscy5mb3JFYWNoKChsYWJlbCwgaW5kZXgpID0+IHtcbiAgICBidXR0b25zICs9IGBcbiAgICAgIDxidXR0b24gY2xhc3M9XCJcbiAgICAgICAgYWxlcnQtZGlhbG9nLWJ1dHRvblxuICAgICAgICAke2luZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/ICcgYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyA6ICcnfVxuICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctYnV0dG9uLS1vbmUnIDogJyd9XG4gICAgICBcIj5cbiAgICAgICAgJHtsYWJlbH1cbiAgICAgIDwvYnV0dG9uPlxuICAgIGA7XG4gIH0pO1xuXG4gIC8vIERpYWxvZyBFbGVtZW50XG4gIGxldCBlbCA9IHt9O1xuICBjb25zdCBfZGVzdHJveURpYWxvZyA9ICgpID0+IHtcbiAgICBpZiAoZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsKSB7XG4gICAgICBlbC5kaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoZWwpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBlbFtrZXldKTtcbiAgICBlbCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBlbC5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gIGlubmVySFRNTChlbC5kaWFsb2csIGBcbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+XG4gICAgICAgICAgJHtvcHRpb25zLnRpdGxlIHx8ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gICAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTH1cbiAgICAgICAgICAke2lucHV0U3RyaW5nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIlxuICAgICAgICAgIGFsZXJ0LWRpYWxvZy1mb290ZXJcbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUnIDogJyd9XG4gICAgICAgIFwiPlxuICAgICAgICAgICR7YnV0dG9uc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCk7XG4gIGNvbnRlbnRSZWFkeShlbC5kaWFsb2cpO1xuXG4gIC8vIFNldCBhdHRyaWJ1dGVzXG4gIFsnaWQnLCAnY2xhc3MnLCAnYW5pbWF0aW9uJ11cbiAgICAuZm9yRWFjaChhID0+IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoYSkgJiYgZWwuZGlhbG9nLnNldEF0dHJpYnV0ZShhLCBvcHRpb25zW2FdKSk7XG4gIGlmIChvcHRpb25zLm1vZGlmaWVyKSB7XG4gICAgdXRpbC5hZGRNb2RpZmllcihlbC5kaWFsb2csIG9wdGlvbnMubW9kaWZpZXIpO1xuICB9XG5cbiAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG5cbiAgLy8gUHJvbXB0IGV2ZW50c1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLnN1Ym1pdE9uRW50ZXIpIHtcbiAgICBlbC5pbnB1dCA9IGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yKCcudGV4dC1pbnB1dCcpO1xuICAgIGVsLmlucHV0Lm9ua2V5cHJlc3MgPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGVsLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQnV0dG9uIGV2ZW50c1xuICBlbC5mb290ZXIgPSBlbC5kaWFsb2cucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1mb290ZXInKTtcbiAgdXRpbC5hcnJheUZyb20oZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbGVydC1kaWFsb2ctYnV0dG9uJykpLmZvckVhY2goKGJ1dHRvbkVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9uRWxlbWVudC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZVZhbHVlID0gb3B0aW9ucy5pc1Byb21wdCA/IGVsLmlucHV0LnZhbHVlIDogaW5kZXg7XG4gICAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgIF9kZXN0cm95RGlhbG9nKCk7XG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGVsLmZvb3Rlci5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcbiAgfSk7XG5cbiAgLy8gQ2FuY2VsIGV2ZW50c1xuICBpZiAob3B0aW9ucy5jYW5jZWxhYmxlKSB7XG4gICAgZWwuZGlhbG9nLmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCA9ICgpID0+IHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIGVsLmRpYWxvZy5yZW1vdmUoKTtcbiAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzb2x2ZVZhbHVlID0gb3B0aW9ucy5pc1Byb21wdCA/IG51bGwgOiAtMTtcbiAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgIGRlZmVycmVkLnJlamVjdChyZXNvbHZlVmFsdWUpO1xuICAgIH07XG4gICAgZWwuZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFNob3cgZGlhbG9nXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwuZGlhbG9nKTtcbiAgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZWwuZGlhbG9nLnNob3coKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuaW5wdXQgJiYgb3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLmF1dG9mb2N1cykge1xuICAgICAgICAgIGVsLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbmNvbnN0IF9ub3JtYWxpemVBcmd1bWVudHMgPSAobWVzc2FnZSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGVydCBkaWFsb2cgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbHMnKSB8fCBvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbCcpKSB7XG4gICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBvcHRpb25zLmJ1dHRvbkxhYmVscyB8fCBvcHRpb25zLmJ1dHRvbkxhYmVsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmJ1dHRvbkxhYmVscykpIHtcbiAgICAgIG9wdGlvbnMuYnV0dG9uTGFiZWxzID0gW29wdGlvbnMuYnV0dG9uTGFiZWxzIHx8ICcnXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dGlsLmV4dGVuZCh7XG4gICAgICBjb21waWxlOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGNhbGxiYWNrOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGJ1dHRvbkxhYmVsczogWydPSyddLFxuICAgICAgcHJpbWFyeUJ1dHRvbkluZGV4OiAwLFxuICAgICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH0sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhbGVydFxuICogQHNpZ25hdHVyZSBhbGVydChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL5paH5a2X5YiX44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UgaW4gSFRNTC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KLSFRNTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIGAwYC5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDAg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsYWJsZV1cbiAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gRGVmYXVsdCBpcyBgZmFsc2VgLiBJZiB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSBjbGlja2luZyB0aGUgYmFja2dyb3VuZCBvciBwcmVzc2luZyB0aGUgQW5kcm9pZCBiYWNrIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBub25lYCBhbmQgYGZhZGVgLiBEZWZhdWx0IGlzIGBmYWRlYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2xhc3NdXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIGNsYXNzLlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuY2xhc3PjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICogICBbZW5dRGlhbG9nIHRpdGxlLiBEZWZhdWx0IGlzIGBcIkFsZXJ0XCJgLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7kuIrpg6jjgavooajnpLrjgZnjgovjgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIkFsZXJ0XCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBrm1vZGlmaWVy5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgonjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGFuIGFsZXJ0IGRpYWxvZyB0byBzaG93IHRoZSB1c2VyIGEgbWVzc2FnZS5cbiAqXG4gKiAgICAgVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgY2FuIGJlIGVpdGhlciBzaW1wbGUgdGV4dCBvciBIVE1MLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244O844G444Oh44OD44K744O844K444KS6KaL44Gb44KL44Gf44KB44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg6KGo56S644GZ44KL44Oh44OD44K744O844K444Gv44CB44OG44Kt44K544OI44GL44KC44GX44GP44GvSFRNTOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmFsZXJ0ID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIHRpdGxlOiAnQWxlcnQnXG4gIH0pO1xuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbmZpcm1cbiAqIEBzaWduYXR1cmUgY29uZmlybShtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDFgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHRvIGFzayB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICogICAgIFRoZSBkZWZhdWx0IGJ1dHRvbiBsYWJlbHMgYXJlIGBcIkNhbmNlbFwiYCBhbmQgYFwiT0tcImAgYnV0IHRoZXkgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0obWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244Gr56K66KqN44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44OH44Kq44Or44Go44Gu44Oc44K/44Oz44Op44OZ44Or44Gv44CBXCJDYW5jZWxcIuOBqFwiT0tcIuOBp+OBmeOBjOOAgeOBk+OCjOOBr+OBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBp+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmNvbmZpcm0gPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxuICAgIHByaW1hcnlCdXR0b25JbmRleDogMSxcbiAgICB0aXRsZTogJ0NvbmZpcm0nXG4gIH0pO1xuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHByb21wdFxuICogQHNpZ25hdHVyZSBwcm9tcHQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5wdXQgdmFsdWUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyBgMGAuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXG4gKiAgIFtlbl1QbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXVxuICogICBbZW5dRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW5wdXRUeXBlXVxuICogICBbZW5dVHlwZSBvZiB0aGUgaW5wdXQgZWxlbWVudCAoYHBhc3N3b3JkYCwgYGRhdGVgLi4uKS4gRGVmYXVsdCBpcyBgdGV4dGAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9mb2N1c11cbiAqICAgW2VuXUF1dG9mb2N1cyB0aGUgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXWlucHV06KaB57Sg44Gr6Ieq5YuV55qE44Gr44OV44Kp44O844Kr44K544GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1Ym1pdE9uRW50ZXJdXG4gKiAgIFtlbl1TdWJtaXQgYXV0b21hdGljYWxseSB3aGVuIGVudGVyIGlzIHByZXNzZWQuIERlZmF1bHQgaXMgYHRydWVgLlsvZW5dXG4gKiAgIFtqYV1FbnRlcuOBjOaKvOOBleOCjOOBn+mam+OBq+OBneOBrmZvcm3jgpJzdWJtaXTjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB3aXRoIGEgcHJvbXB0IHRvIGFzayB0aGUgdXNlciBhIHF1ZXN0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgavlhaXlipvjgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5wcm9tcHQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgdGl0bGU6ICdBbGVydCcsXG4gICAgaXNQcm9tcHQ6IHRydWUsXG4gICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgIHN1Ym1pdE9uRW50ZXI6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBub3RpZmljYXRpb247XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cbmNvbnN0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0ge1xuICBfdmFyaWFibGVzOiB7fSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIGRlZmluZSBhIHZhcmlhYmxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlxuICAgKi9cbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQuYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxuICAgKi9cbiAgcmVtb3ZlVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QWxsVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xuICB9LFxuICBfcGFyc2VQYXJ0OiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgbGV0IGMsXG4gICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBpO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgIGlmICghaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uLicpO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgcGFydC5sZW5ndGgpKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH0sXG4gIF9yZXBsYWNlVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgY29uc3QgcmUgPSAvXlxcJHsoLio/KX0kLyxcbiAgICAgIG1hdGNoID0gdG9rZW4ubWF0Y2gocmUpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmdldFZhcmlhYmxlKG5hbWUpO1xuXG4gICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gdmFyaWFibGUoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCByZXR1cm4gYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5pbXBvcnQgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5cbmNvbnN0IGludGVybmFsID0ge307XG5cbmludGVybmFsLmNvbmZpZyA9IHtcbiAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXG4gIGFuaW1hdGlvbnNEaXNhYmxlZDogZmFsc2Vcbn07XG5cbmludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gaHRtbCA9PiB7XG4gIGh0bWwgPSAoJycgKyBodG1sKS50cmltKCk7XG5cbiAgaWYgKCFodG1sLm1hdGNoKC9ePG9ucy1wYWdlLykpIHtcbiAgICBodG1sID0gJzxvbnMtcGFnZSBfbXV0ZWQ+JyArIGh0bWwgKyAnPC9vbnMtcGFnZT4nO1xuICB9XG5cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgd2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwgPSBhY3Rpb24gPT4ge1xuICBjb25zdCBvblJlYWR5ID0gKCkgPT4ge1xuICAgIGlmIChpbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyKCkpIHtcbiAgICAgIGFjdGlvbigpO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBvblJlYWR5KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9IGVsc2UgaWYgKFsnY29tcGxldGUnLCAnaW50ZXJhY3RpdmUnXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID09PSAtMSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIG9uUmVhZHkoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvblJlYWR5KCk7XG4gIH1cbn07XG5cbmludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIgPSAoKSA9PiBpbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCgpICYmIHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCk7XG5cbmludGVybmFsLnRlbXBsYXRlU3RvcmUgPSB7XG4gIF9zdG9yYWdlOiB7fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtTdHJpbmcvbnVsbH0gdGVtcGxhdGVcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzZXQoa2V5LCB0ZW1wbGF0ZSkge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSA9IHRlbXBsYXRlO1xuICB9XG59O1xuXG53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignX3RlbXBsYXRlbG9hZGVkJywgZnVuY3Rpb24oZSkge1xuICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10ZW1wbGF0ZScpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChlLnRlbXBsYXRlSWQsIGUudGVtcGxhdGUpO1xuICB9XG59LCBmYWxzZSk7XG5cbndpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvb25zLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiXScpO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgdGVtcGxhdGVzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldCh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZW1wbGF0ZXNbaV0udGV4dENvbnRlbnQpO1xuICAgIH1cbiAgfVxufSwgZmFsc2UpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGUgPSBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLmdldChwYWdlKTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB0eXBlb2YgY2FjaGUgPT09ICdzdHJpbmcnID8gY2FjaGUgOiBjYWNoZVsxXTtcbiAgICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgcGFnZSwgdHJ1ZSk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICByZWplY3QoaHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcGFnZSBpcyBub3QgZm91bmQ6ICR7cGFnZX1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgY29uc3QgcGFnZXMgPSBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5ldmFsdWF0ZShwYWdlKTtcblxuICBjb25zdCBnZXRQYWdlID0gKHBhZ2UpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ011c3Qgc3BlY2lmeSBhIHBhZ2UuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHBhZ2UpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBpZiAocGFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAudGhlbihodG1sID0+IGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpKTtcbiAgfTtcblxuICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hbmltYXRvcnMgVGhlIGRpY3Rpb25hcnkgZm9yIGFuaW1hdG9yIGNsYXNzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5iYXNlQ2xhc3NOYW1lXSBUaGUgbmFtZSBvZiB0aGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25dIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcbiAgICB0aGlzLl9iYXNlQ2xhc3MgPSBvcHRzLmJhc2VDbGFzcztcbiAgICB0aGlzLl9iYXNlQ2xhc3NOYW1lID0gb3B0cy5iYXNlQ2xhc3NOYW1lIHx8IG9wdHMuYmFzZUNsYXNzLm5hbWU7XG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBhbmltYXRpb246ICcgKyB0aGlzLl9hbmltYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3QvbnVsbH1cbiAgICovXG4gIHN0YXRpYyBwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcoanNvblN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGpzb25TdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0QW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl0gVGhlIGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXSBUaGUgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRBbmltYXRvciBUaGUgZGVmYXVsdCBhbmltYXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFuaW1hdG9yIGluc3RhbmNlXG4gICAqL1xuICBuZXdBbmltYXRvcihvcHRpb25zID0ge30sIGRlZmF1bHRBbmltYXRvcikge1xuXG4gICAgbGV0IGFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGxldCBBbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgQW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcnNbb3B0aW9ucy5hbmltYXRpb25dO1xuICAgIH1cblxuICAgIGlmICghQW5pbWF0b3IgJiYgZGVmYXVsdEFuaW1hdG9yKSB7XG4gICAgICBhbmltYXRvciA9IGRlZmF1bHRBbmltYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQW5pbWF0b3IgPSBBbmltYXRvciB8fCB0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID8ge2R1cmF0aW9uOiAwLCBkZWxheTogMH0gOiB7fVxuICAgICAgKTtcblxuICAgICAgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgYW5pbWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGFuaW1hdG9yIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImFuaW1hdG9yXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mICcgKyB0aGlzLl9iYXNlQ2xhc3NOYW1lICsgJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGlmaWVyVXRpbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKi9cbiAgc3RhdGljIGRpZmYobGFzdCwgY3VycmVudCkge1xuICAgIGxhc3QgPSBtYWtlRGljdCgoJycgKyBsYXN0KS50cmltKCkpO1xuICAgIGN1cnJlbnQgPSBtYWtlRGljdCgoJycgKyBjdXJyZW50KS50cmltKCkpO1xuXG4gICAgY29uc3QgcmVtb3ZlZCA9IE9iamVjdC5rZXlzKGxhc3QpLnJlZHVjZSgocmVzdWx0LCB0b2tlbikgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50W3Rva2VuXSkge1xuICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGFkZGVkID0gT2JqZWN0LmtleXMoY3VycmVudCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWxhc3RbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHthZGRlZCwgcmVtb3ZlZH07XG5cbiAgICBmdW5jdGlvbiBtYWtlRGljdChtb2RpZmllcikge1xuICAgICAgY29uc3QgZGljdCA9IHt9O1xuICAgICAgTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKS5mb3JFYWNoKHRva2VuID0+IGRpY3RbdG9rZW5dID0gdG9rZW4pO1xuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc0xpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgY2xhc3NMaXN0LCB0ZW1wbGF0ZSkge1xuICAgIGRpZmYuYWRkZWRcbiAgICAgIC5tYXAobW9kaWZpZXIgPT4gdGVtcGxhdGUucmVwbGFjZSgvXFwqL2csIG1vZGlmaWVyKSlcbiAgICAgIC5mb3JFYWNoKGtsYXNzID0+IGNsYXNzTGlzdC5hZGQoa2xhc3MpKTtcblxuICAgIGRpZmYucmVtb3ZlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4gY2xhc3NMaXN0LnJlbW92ZShrbGFzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGFwcGx5RGlmZlRvRWxlbWVudChkaWZmLCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gKGUsIHMpID0+IChlLm1hdGNoZXMgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvcikuY2FsbChlLCBzKTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIGluIHNjaGVtZSkge1xuICAgICAgaWYgKHNjaGVtZS5oYXNPd25Qcm9wZXJ0eShzZWxlY3RvcikpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSAhc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikgPyBbZWxlbWVudF0gOiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIHRhcmdldEVsZW1lbnRzW2ldLmNsYXNzTGlzdCwgc2NoZW1lW3NlbGVjdG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgb25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYobGFzdCwgY3VycmVudCksIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgaW5pdE1vZGlmaWVyKGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIGNvbnN0IG1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICAgaWYgKHR5cGVvZiBtb2RpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9FbGVtZW50KHtcbiAgICAgIHJlbW92ZWQ6IFtdLFxuICAgICAgYWRkZWQ6IE1vZGlmaWVyVXRpbC5zcGxpdChtb2RpZmllcilcbiAgICB9LCBlbGVtZW50LCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIHNwbGl0KG1vZGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZXIudHJpbSgpLnNwbGl0KC8gKy8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbiAhPT0gJycpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0RGVsZWdhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHVzZXJEZWxlZ2F0ZSwgdGVtcGxhdGVFbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdXNlckRlbGVnYXRlICE9PSAnb2JqZWN0JyB8fCB1c2VyRGVsZWdhdGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB1c2VyRGVsZWdhdGU7XG5cbiAgICBpZiAoISh0ZW1wbGF0ZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSAmJiB0ZW1wbGF0ZUVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcInRlbXBsYXRlRWxlbWVudFwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQgb3IgbnVsbC4nKTtcbiAgICB9XG4gICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGl0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5pdGVtSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNSZW5kZXJGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX3JlbmRlcihpdGVtcywgaGVpZ2h0KSB7XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIoaXRlbXMsIGhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQSBmdW5jdGlvbiB0aGF0IHRha2UgaXRlbSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgKi9cbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBwYXJlbnQsIGRvbmUpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KGluZGV4LCBwYXJlbnQsIGVsZW1lbnQgPT4gZG9uZSh7ZWxlbWVudH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudChpbmRleCwgdGhpcy5fdGVtcGxhdGVFbGVtZW50KTtcbiAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY3JlYXRlSXRlbUNvbnRlbnQoKSBtdXN0IHJldHVybiBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb3VudEl0ZW1zKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdW50SXRlbXMoKSBtdXN0IHJldHVybiBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxuICAgKi9cbiAgdXBkYXRlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignY2FsY3VsYXRlSXRlbUhlaWdodCgpIG11c3QgcmV0dXJuIGEgbnVtYmVyLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKi9cbiAgZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhenlSZXBlYXRQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlckVsZW1lbnRcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgTGF6eVJlcGVhdERlbGVnYXRlLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQ7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcblxuICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdGhpcy5fZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCk7XG5cbiAgICBpZiAoIXRoaXMuX3BhZ2VDb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ucy1sYXp5LXJlcGVhdCBtdXN0IGJlIGEgZGVzY2VuZGFudCBvZiBhbiA8b25zLXBhZ2U+IG9yIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdG9wUG9zaXRpb25zID0gW107XG4gICAgdGhpcy5fcmVuZGVyZWRJdGVtcyA9IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0ICYmICF0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KDApKSB7XG4gICAgICB0aGlzLl91bmtub3duSXRlbUhlaWdodCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgfVxuXG4gIF9maW5kUGFnZUNvbnRlbnRFbGVtZW50KHdyYXBwZXJFbGVtZW50KSB7XG4gICAgY29uc3QgcGFnZUNvbnRlbnQgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICcucGFnZV9fY29udGVudCcpO1xuXG4gICAgaWYgKHBhZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gcGFnZUNvbnRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh3cmFwcGVyRWxlbWVudCwgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmZpbmRDaGlsZChwYWdlLCAnLmNvbnRlbnQnKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCgwLCB0aGlzLl93cmFwcGVyRWxlbWVudCwgaXRlbSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91bmtub3duSXRlbUhlaWdodDtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2l0ZW1IZWlnaHQgPSBpdGVtLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5faXRlbUhlaWdodCA+IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHJ5IHRvIG1lYXN1cmUgb2Zmc2V0IGhlaWdodFxuICAgICAgLy8gZGlydHkgZml4IGZvciBhbmd1bGFyMiBkaXJlY3RpdmVcbiAgICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eTtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2l0ZW1IZWlnaHQgPSBpdGVtLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5faXRlbUhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IHRoaXMuX2l0ZW1IZWlnaHQgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gbGFzdFZpc2liaWxpdHk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHN0YXRpY0l0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgfHwgdGhpcy5faXRlbUhlaWdodDtcbiAgfVxuXG4gIF9jb3VudEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XG4gIH1cblxuICBfZ2V0SXRlbUhlaWdodChpKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljSXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGkpO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBfcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrSXRlbUhlaWdodCh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0luVmlldygpO1xuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLl9yZW5kZXIoaXRlbXMsIHRoaXMuX2xpc3RIZWlnaHQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qga2VlcCA9IHt9O1xuXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaXRlbSk7XG4gICAgICBrZWVwW2l0ZW0uaW5kZXhdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IGtlZXBba2V5XSB8fCB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fbGlzdEhlaWdodCArICdweCc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0uaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0udG9wXG4gICAqL1xuICBfcmVuZGVyRWxlbWVudCh7aW5kZXgsIHRvcH0pIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLnVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pOyAvLyB1cGRhdGUgaWYgaXQgZXhpc3RzXG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoaW5kZXgsIHRoaXMuX3dyYXBwZXJFbGVtZW50LCBpdGVtID0+IHtcbiAgICAgIHV0aWwuZXh0ZW5kKGl0ZW0uZWxlbWVudC5zdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdID0gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG4gIF9yZW1vdmVFbGVtZW50KGluZGV4KSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuXG4gICAgdGhpcy5fZGVsZWdhdGUuZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pO1xuXG4gICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgfVxuXG4gIF9yZW1vdmVBbGxFbGVtZW50cygpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZVN0YXJ0SW5kZXgoY3VycmVudCkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IHRoaXMuX2l0ZW1Db3VudCAtIDE7XG5cbiAgICBpZiAodGhpcy5zdGF0aWNJdGVtSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoLWN1cnJlbnQgLyB0aGlzLnN0YXRpY0l0ZW1IZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGluZGV4IGF0IHRvcCBvZiBzY3JlZW4gc28gd2UgY2FuIHNwZWVkIHVwIHJlbmRlcmluZy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudCArIHRoaXMuX3RvcFBvc2l0aW9uc1ttaWRkbGVdO1xuXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IDAgJiYgdmFsdWUgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KG1pZGRsZSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKCkge1xuICAgIGNvbnN0IGwgPSBNYXRoLm1pbih0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoLCB0aGlzLl9pdGVtQ291bnQpO1xuICAgIHRoaXMuX3RvcFBvc2l0aW9uc1swXSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDEsIGw7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpXSA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpIC0gMV0gKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRJdGVtc0luVmlldygpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgY29uc3QgbGltaXQgPSA0ICogd2luZG93LmlubmVySGVpZ2h0IC0gb2Zmc2V0O1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRJdGVtcygpO1xuXG4gICAgaWYgKGNvdW50ICE9PSB0aGlzLl9pdGVtQ291bnQpe1xuICAgICAgdGhpcy5faXRlbUNvdW50ID0gY291bnQ7XG4gICAgICB0aGlzLl9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucygpO1xuICAgIH1cblxuICAgIGxldCBpID0gTWF0aC5tYXgoMCwgdGhpcy5fY2FsY3VsYXRlU3RhcnRJbmRleChvZmZzZXQpIC0gMzApO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciB0b3AgPSB0aGlzLl90b3BQb3NpdGlvbnNbaV07IGkgPCBjb3VudCAmJiB0b3AgPCBsaW1pdDsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoKSB7IC8vIHBlcmYgb3B0aW1pemF0aW9uXG4gICAgICAgIHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGggKz0gMTAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaV0gPSB0b3A7XG4gICAgICBpdGVtcy5wdXNoKHt0b3AsIGluZGV4OiBpfSk7XG4gICAgICB0b3AgKz0gdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdEhlaWdodCA9IHRvcDtcblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9kZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9kb3VibGVGaXJlT25Ub3VjaGVuZCgpIHtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB0aGlzLl9kZWJvdW5jZSh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSwgMTAwKTtcbiAgfVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB1dGlsLmJpbmRMaXN0ZW5lcnModGhpcywgWydfb25DaGFuZ2UnLCAnX2RvdWJsZUZpcmVPblRvdWNoZW5kJ10pO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9kZWJvdW5jZSh0aGlzLl9ib3VuZE9uQ2hhbmdlLCAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9wYXJlbnRFbGVtZW50ID0gdGhpcy5fZGVsZWdhdGUgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICB9XG59XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4vYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4vbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQge0xhenlSZXBlYXRQcm92aWRlciwgTGF6eVJlcGVhdERlbGVnYXRlfSBmcm9tICcuL2xhenktcmVwZWF0JztcblxuaW50ZXJuYWwuQW5pbWF0b3JGYWN0b3J5ID0gQW5pbWF0b3JGYWN0b3J5O1xuaW50ZXJuYWwuTW9kaWZpZXJVdGlsID0gTW9kaWZpZXJVdGlsO1xuaW50ZXJuYWwuTGF6eVJlcGVhdFByb3ZpZGVyID0gTGF6eVJlcGVhdFByb3ZpZGVyO1xuaW50ZXJuYWwuTGF6eVJlcGVhdERlbGVnYXRlID0gTGF6eVJlcGVhdERlbGVnYXRlO1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbDtcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY29uc3QgY3JlYXRlID0gKCkgPT4ge1xuXG4gIC8qKlxuICAgKiBAb2JqZWN0IG9ucy5vcmllbnRhdGlvblxuICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXRpbGl0eSBtZXRob2RzIGZvciBvcmllbnRhdGlvbiBkZXRlY3Rpb24uWy9lbl1cbiAgICogICBbamFd55S76Z2i44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz5qSc55+l44Gu44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gm44GE44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGNvbnN0IG9iaiA9IHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZXMuWy9lbl1cbiAgICAgKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1BvcnRyYWl0XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3nj77lnKjjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOOBruWgtOWQiOOBq3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBzaWduYXR1cmUgb24oZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeOBk+OBruOCpOODmeODs+ODiOOBjOeZuueBq+OBleOCjOOBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAc2lnbmF0dXJlIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lciB0aGF0J3Mgb25seSB0cmlnZ2VyZWQgb25jZS5bL2VuXVxuICAgICAqICBbamFd5LiA5bqm44Gg44GR5ZG844Gz5Ye644GV44KM44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAc2lnbmF0dXJlIG9mZihldmVudE5hbWUsIFtsaXN0ZW5lcl0pXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuIElmIHRoZSBsaXN0ZW5lciBpcyBub3Qgc3BlY2lmaWVkIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5bL2VuXVxuICAgICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CC44KC44GX44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44Gq44GL44Gj44Gf5aC05ZCI44Gr44Gv44CB44Gd44Gu44Kk44OZ44Oz44OI44Gr57SQ44Gl44GP5YWo44Gm44Gu44Kk44OZ44Oz44OI44Oq44K544OK44O844GM5YmK6Zmk44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3liYrpmaTjgZnjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLy8gYWN0dWFsIGltcGxlbWVudGF0aW9uIHRvIGRldGVjdCBpZiB3aGV0aGVyIGN1cnJlbnQgc2NyZWVuIGlzIHBvcnRyYWl0IG9yIG5vdFxuICAgIF9pc1BvcnRyYWl0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaXNQb3J0cmFpdFxuICAgICAqIEBzaWduYXR1cmUgaXNQb3J0cmFpdCgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG4gICAgaXNQb3J0cmFpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzTGFuZHNjYXBlXG4gICAgICogQHNpZ25hdHVyZSBpc0xhbmRzY2FwZSgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzTGFuZHNjYXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc1BvcnRyYWl0KCk7XG4gICAgfSxcblxuICAgIF9pbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRPTUNvbnRlbnRMb2FkZWQuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25ET01Db250ZW50TG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24oKTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfSxcblxuICAgIF9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgaWYgKCEoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpKSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDkwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gdGhpcy5faXNQb3J0cmFpdCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZGltZW5zaW9ucyB0byBjaGFuZ2UgYmVjYXVzZVxuICAgICAgLy8gb2YgQW5kcm9pZCBpbmNvbnNpc3RlbmN5LlxuICAgICAgbGV0IG5JdGVyID0gMDtcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBuSXRlcisrO1xuXG4gICAgICAgIGNvbnN0IHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBpZiAoKGlzUG9ydHJhaXQgJiYgdyA8PSBoKSB8fFxuICAgICAgICAgICAoIWlzUG9ydHJhaXQgJiYgdyA+PSBoKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChuSXRlciA9PT0gNTApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIG9uIG5vdCBtb2JpbGUgYnJvd3Nlci5cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcbiAgICB9XG4gIH07XG5cbiAgTWljcm9FdmVudC5taXhpbihvYmopO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGUoKS5faW5pdCgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY29uc3Qgc29mdHdhcmVLZXlib2FyZCA9IG5ldyBNaWNyb0V2ZW50KCk7XG5zb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG5cbmNvbnN0IG9uU2hvdyA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IHRydWU7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnc2hvdycpO1xufTtcblxuY29uc3Qgb25IaWRlID0gKCkgPT4ge1xuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaGlkZScpO1xufTtcblxuY29uc3QgYmluZEV2ZW50cyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBLZXlib2FyZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFydGlubW9zZS9jb3Jkb3ZhLWtleWJvYXJkL2Jsb2IvOTVmM2RhM2EzOGQ4ZjhlMWZhNDFmYmY0MDE0NTM1MmMxMzUzNWEwMC9SRUFETUUubWRcbiAgICBLZXlib2FyZC5vbnNob3cgPSBvblNob3c7XG4gICAgS2V5Ym9hcmQub25oaWRlID0gb25IaWRlO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBLZXlib2FyZC5pc1Zpc2libGV9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RyaWZ0eWNvL2lvbmljLXBsdWdpbnMta2V5Ym9hcmQvYmxvYi9jYTI3ZWNmL1JFQURNRS5tZFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRzaG93Jywgb25TaG93KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIG9uSGlkZSk7XG4gICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0Jywge3Zpc2libGU6IGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5pc1Zpc2libGV9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3Qgbm9QbHVnaW5FcnJvciA9ICgpID0+IHtcbiAgY29uc29sZS53YXJuKCdvbnMta2V5Ym9hcmQ6IENvcmRvdmEgS2V5Ym9hcmQgcGx1Z2luIGlzIG5vdCBwcmVzZW50LicpO1xufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoKSA9PiB7XG4gIGlmICghYmluZEV2ZW50cygpKSB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtYWN0aXZlXScpIHx8XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWluYWN0aXZlXScpKSB7XG4gICAgICBub1BsdWdpbkVycm9yKCk7XG4gICAgfVxuXG4gICAgc29mdHdhcmVLZXlib2FyZC5vbiA9IG5vUGx1Z2luRXJyb3I7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2Z0d2FyZUtleWJvYXJkO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuXG5cbmNvbnN0IHV0aWwgPSB7XG4gIF9yZWFkeTogZmFsc2UsXG5cbiAgX2RvbUNvbnRlbnRMb2FkZWQ6IGZhbHNlLFxuXG4gIF9vbkRPTUNvbnRlbnRMb2FkZWQ6ICgpID0+IHtcbiAgICB1dGlsLl9kb21Db250ZW50TG9hZGVkID0gdHJ1ZTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc1dlYlZpZXcoKSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICAgICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuX3JlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgYWRkQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbihmbikge1xuICAgIGlmICghdGhpcy5fZG9tQ29udGVudExvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgRE9NQ29udGVudExvYWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4gdXRpbC5fb25ET01Db250ZW50TG9hZGVkKCksIGZhbHNlKTtcblxuY29uc3QgSGFuZGxlclJlcG9zaXRvcnkgPSB7XG4gIF9zdG9yZToge30sXG5cbiAgX2dlbklkOiAoKCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gKCkgPT4gaSsrO1xuICB9KSgpLFxuXG4gIHNldDogZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQgPSBIYW5kbGVyUmVwb3NpdG9yeS5fZ2VuSWQoKTtcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBoYW5kbGVyO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0b3JlW2VsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkXTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuXG4gICAgaWYgKCF0aGlzLl9zdG9yZVtpZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdG9yZVtpZF07XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LmRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuXG4gICAgcmV0dXJuICEhdGhpcy5fc3RvcmVbaWRdO1xuICB9XG59O1xuXG5jbGFzcyBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kQ2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB9XG5cblxuICAvKipcbiAgICogRW5hYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLmFkZEJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHV0aWwucmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmUgYSAnYmFja2J1dHRvbicgZXZlbnQgbWFudWFsbHkuXG4gICAqL1xuICBmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdiYWNrYnV0dG9uJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBfY2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBjcmVhdGVIYW5kbGVyKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgIF9jYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBfZWxlbWVudDogZWxlbWVudCxcblxuICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIHNldExpc3RlbmVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSxcblxuICAgICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkuc2V0KGVsZW1lbnQsIHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KSA9PT0gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXIuZW5hYmxlKCk7XG5cbiAgICByZXR1cm4gaGFuZGxlcjtcbiAgfVxuXG4gIF9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCB0cmVlID0gdGhpcy5fY2FwdHVyZVRyZWUoKTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpO1xuXG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCk7XG4gICAgaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQoZWxlbWVudCkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGNhbGxQYXJlbnRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KHBhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfY2FwdHVyZVRyZWUoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRyZWUoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmVlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGNoaWxkcmVuOiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheU9mKGVsZW1lbnQuY2hpbGRyZW4pLm1hcChmdW5jdGlvbihjaGlsZEVsZW1lbnQpIHtcblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhjaGlsZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlVHJlZShjaGlsZEVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhyZXN1bHQuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheU9mKHRhcmdldCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh0YXJnZXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKSB7XG4gICAgcmV0dXJuIGZpbmQodHJlZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5lbGVtZW50O1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlZnRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobGVmdCwgJycpLnpJbmRleCwgMTApO1xuICAgICAgICBjb25zdCByaWdodFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyaWdodCwgJycpLnpJbmRleCwgMTApO1xuXG4gICAgICAgIGlmICghaXNOYU4obGVmdFopICYmICFpc05hTihyaWdodFopKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnRaID4gcmlnaHRaID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXB0dXJpbmcgYmFja2J1dHRvbi1oYW5kbGVyIGlzIGZhaWx1cmUuJyk7XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5sZXQgYXV0b1N0eWxlRW5hYmxlZCA9IHRydWU7XG5cbi8vIE1vZGlmaWVyc1xuY29uc3QgbW9kaWZpZXJzTWFwID0ge1xuICAncXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnbGlnaHQnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnb3V0bGluZSc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdjdGEnOiAnJyxcbiAgJ2xhcmdlLS1xdWlldCc6ICdtYXRlcmlhbC0tZmxhdCBsYXJnZScsXG4gICdsYXJnZS0tY3RhJzogJ2xhcmdlJyxcbiAgJ25vYm9yZGVyJzogJycsXG4gICdjaGV2cm9uJzogJycsXG4gICd0YXBwYWJsZSc6ICcnXG59O1xuXG5jb25zdCBwbGF0Zm9ybXMgPSB7fTtcblxucGxhdGZvcm1zLmFuZHJvaWQgPSBlbGVtZW50ID0+IHtcblxuICBpZiAoIS9vbnMtZmFifG9ucy1zcGVlZC1kaWFsfG9ucy1wcm9ncmVzcy8udGVzdChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAhL21hdGVyaWFsLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSkge1xuXG4gICAgY29uc3Qgb2xkTW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcblxuICAgIGNvbnN0IG5ld01vZGlmaWVyID0gb2xkTW9kaWZpZXIudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gbW9kaWZpZXJzTWFwLmhhc093blByb3BlcnR5KGUpID8gbW9kaWZpZXJzTWFwW2VdIDogZSk7XG4gICAgbmV3TW9kaWZpZXIudW5zaGlmdCgnbWF0ZXJpYWwnKTtcblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLmpvaW4oJyAnKS50cmltKCkpO1xuICB9XG5cbiAgLy8gRWZmZWN0c1xuICBpZiAoL29ucy1idXR0b258b25zLWxpc3QtaXRlbXxvbnMtZmFifG9ucy1zcGVlZC1kaWFsfG9ucy10YWIkLy50ZXN0KGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJylcbiAgICAmJiAhdXRpbC5maW5kQ2hpbGQoZWxlbWVudCwgJ29ucy1yaXBwbGUnKSkge1xuXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QtaXRlbScpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnBsYXRmb3Jtcy5pb3MgPSBlbGVtZW50ID0+IHtcblxuIC8vIE1vZGlmaWVyc1xuIGlmICgvbWF0ZXJpYWwvLnRlc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpKSB7XG4gICB1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpO1xuXG4gICBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwtLWZsYXQnKSkge1xuICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdsYXJnZScpKSA/ICdsYXJnZS0tcXVpZXQnIDogJ3F1aWV0Jyk7XG4gICB9XG5cbiAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICB9XG4gfVxuXG4gLy8gRWZmZWN0c1xuIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcbiAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXBwYWJsZScsICcnKTtcbiAgIH1cblxuICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuIH1cbn07XG5cbmNvbnN0IHVubG9ja2VkID0ge1xuICBhbmRyb2lkOiB0cnVlXG59O1xuXG5jb25zdCBwcmVwYXJlQXV0b1N0eWxlID0gKGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGlmIChhdXRvU3R5bGVFbmFibGVkICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZS1hdXRvLXN0eWxpbmcnKSkge1xuICAgIGNvbnN0IG1vYmlsZU9TID0gb25zUGxhdGZvcm0uZ2V0TW9iaWxlT1MoKTtcbiAgICBpZiAocGxhdGZvcm1zLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSAmJiAodW5sb2NrZWQuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpIHx8IGZvcmNlKSkge1xuICAgICAgcGxhdGZvcm1zW21vYmlsZU9TXShlbGVtZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNFbmFibGVkOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkLFxuICBlbmFibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlLFxuICBkaXNhYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gZmFsc2UsXG4gIHByZXBhcmU6IHByZXBhcmVBdXRvU3R5bGVcbn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9vckxvY2sge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvY2tMaXN0ID0gW107XG4gICAgdGhpcy5fd2FpdExpc3QgPSBbXTtcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbG9jay5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXG4gICAqL1xuICBsb2NrKCkge1xuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3VubG9jayh1bmxvY2spO1xuICAgIH07XG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICB0aGlzLl9sb2coJ2xvY2s6ICcgKyAodW5sb2NrLmlkKSk7XG5cbiAgICByZXR1cm4gdW5sb2NrO1xuICB9XG5cbiAgX3VubG9jayhmbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9ja0xpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBsb2NrIGxpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9sb2coJ3VubG9jazogJyArIGZuLmlkKTtcblxuICAgIHRoaXMuX3RyeVRvRnJlZVdhaXRMaXN0KCk7XG4gIH1cblxuICBfdHJ5VG9GcmVlV2FpdExpc3QoKSB7XG4gICAgd2hpbGUgKCF0aGlzLmlzTG9ja2VkKCkgJiYgdGhpcy5fd2FpdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3YWl0aW5nIHVubG9ja2VkIGRvb3IuXG4gICAqXG4gICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICovXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FsbGJhY2sgcGFyYW0gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tMaXN0Lmxlbmd0aCA+IDA7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuXG4vLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBnbG9iYWwgUGFnZUxvYWRlci5cbmZ1bmN0aW9uIGxvYWRQYWdlKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbC50cmltKCkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwYWdlRWxlbWVudCk7XG5cbiAgICBkb25lKHBhZ2VFbGVtZW50KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVubG9hZFBhZ2UoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5fZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgZWxlbWVudC5fZGVzdHJveSgpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBhZ2VMb2FkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyBcImVsZW1lbnRcIiBwcm9wZXJ0eSBhbmQgXCJ1bmxvYWRcIiBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdW5sb2FkZXIpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGxvYWRlciA6IGxvYWRQYWdlO1xuICAgIHRoaXMuX3VubG9hZGVyID0gdW5sb2FkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHVubG9hZGVyIDogdW5sb2FkUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaW50ZXJuYWwgbG9hZGVyIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgc2V0IGludGVybmFsTG9hZGVyKGZuKSB7XG4gICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZXIgPSBmbjtcbiAgfVxuXG4gIGdldCBpbnRlcm5hbExvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcHRpb25zLnBhZ2VcbiAgICogQHBhcmFtIHtFbGVtZW50fSBvcHRpb25zLnBhcmVudCBBIGxvY2F0aW9uIHRvIGxvYWQgcGFnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmFtc10gRXh0cmEgcGFyYW1ldGVycyBmb3Igb25zLXBhZ2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgVGFrZSBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBsb2FkKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICAgIHRoaXMuX2xvYWRlcih7cGFnZSwgcGFyZW50LCBwYXJhbXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICBpZiAoIShwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdwYWdlRWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUocGFnZUVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgdW5sb2FkKHBhZ2VFbGVtZW50KSB7XG4gICAgaWYgKCEocGFnZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3BhZ2VFbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl91bmxvYWRlcihwYWdlRWxlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoKTtcblxuZXhwb3J0IGNvbnN0IGluc3RhbnRQYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoXG4gIGZ1bmN0aW9uKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQocGFnZS50cmltKCkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgIGRvbmUoZWxlbWVudCk7XG4gIH0sXG4gIHVubG9hZFBhZ2Vcbik7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IG5vdGlmaWNhdGlvbiBmcm9tICcuL25vdGlmaWNhdGlvbic7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi9vcmllbnRhdGlvbic7XG5pbXBvcnQgc29mdHdhcmVLZXlib2FyZCBmcm9tICcuL3NvZnR3YXJlLWtleWJvYXJkJztcbmltcG9ydCBQYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24nO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4vZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGFuaW1hdGlvbk9wdGlvbnNQYXJzZXIgZnJvbSAnLi9hbmltYXRpb24tb3B0aW9ucy1wYXJzZXInO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuL2F1dG9zdHlsZSc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XG5pbXBvcnQge2RlZmF1bHRQYWdlTG9hZGVyLCBQYWdlTG9hZGVyfSBmcm9tICcuL3BhZ2UtbG9hZGVyJztcblxuLyoqXG4gKiBAb2JqZWN0IG9uc1xuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbamFdT25zZW4gVUnjgafliKnnlKjjgafjgY3jgovjgrDjg63jg7zjg5Djg6vjgarjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogICBbZW5dQSBnbG9iYWwgb2JqZWN0IHRoYXQncyB1c2VkIGluIE9uc2VuIFVJLiBbL2VuXVxuICovXG5jb25zdCBvbnMgPSB7fTtcblxub25zLl91dGlsID0gdXRpbDtcbm9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcbm9ucy5faW50ZXJuYWwgPSBpbnRlcm5hbDtcbm9ucy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3I7XG5vbnMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbm9ucy5zb2Z0d2FyZUtleWJvYXJkID0gc29mdHdhcmVLZXlib2FyZDtcbm9ucy5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbiA9IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xub25zLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5vbnMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xub25zLl9hbmltYXRpb25PcHRpb25zUGFyc2VyID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlcjtcbm9ucy5fYXV0b1N0eWxlID0gYXV0b1N0eWxlO1xub25zLl9Eb29yTG9jayA9IERvb3JMb2NrO1xub25zLl9jb250ZW50UmVhZHkgPSBjb250ZW50UmVhZHk7XG5vbnMuZGVmYXVsdFBhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbm9ucy5QYWdlTG9hZGVyID0gUGFnZUxvYWRlcjtcblxub25zLl9yZWFkeUxvY2sgPSBuZXcgRG9vckxvY2soKTtcblxub25zLnBsYXRmb3JtLnNlbGVjdCgod2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvcGxhdGZvcm09KFtcXHctXSspLykgfHwgW10pWzFdKTtcblxud2FpdERldmljZVJlYWR5KCk7XG5cbi8qKlxuICogQG1ldGhvZCBpc1JlYWR5XG4gKiBAc2lnbmF0dXJlIGlzUmVhZHkoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFd5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmV0dXJucyB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOOBmeOBp+OBq+WIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1JlYWR5ID0gKCkgPT4ge1xuICByZXR1cm4gIW9ucy5fcmVhZHlMb2NrLmlzTG9ja2VkKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaXNXZWJWaWV3XG4gKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBDb3Jkb3ZhLlsvZW5dXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmlzV2ViVmlldyA9IG9ucy5wbGF0Zm9ybS5pc1dlYlZpZXc7XG5cbi8qKlxuICogQG1ldGhvZCByZWFkeVxuICogQHNpZ25hdHVyZSByZWFkeShjYWxsYmFjaylcbiAqIEBkZXNjcmlwdGlvblxuICogICBbamFd44Ki44OX44Oq44Gu5Yid5pyf5YyW44Gr5Yip55So44GZ44KL44Oh44K944OD44OJ44Gn44GZ44CC5rih44GV44KM44Gf6Zai5pWw44Gv44CBT25zZW4gVUnjga7liJ3mnJ/ljJbjgYzntYLkuobjgZfjgabjgYTjgovmmYLngrnjgaflv4XjgZrlkbzjgbDjgozjgb7jgZnjgIJbL2phXVxuICogICBbZW5dTWV0aG9kIHVzZWQgdG8gd2FpdCBmb3IgYXBwIGluaXRpYWxpemF0aW9uLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdW50aWwgT25zZW4gVUkgaGFzIGJlZW4gY29tcGxldGVseSBpbml0aWFsaXplZC5bL2VuXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgT25zZW4gVUkgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXU9uc2VuIFVJ44GM5Yid5pyf5YyW44GM5a6M5LqG44GX44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLnJlYWR5ID0gY2FsbGJhY2sgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgb25zLl9yZWFkeUxvY2sud2FpdFVubG9jayhjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyXG4gKiBAc2lnbmF0dXJlIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIobGlzdGVuZXIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIGRldmljZSBiYWNrIGJ1dHRvbiBpcyBwcmVzc2VkLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgYzmirzjgZXjgozjgZ/mmYLjgavlrp/ooYzjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TZXQgZGVmYXVsdCBoYW5kbGVyIGZvciBkZXZpY2UgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOBn+OCgeOBruODh+ODleOCqeODq+ODiOOBruODj+ODs+ODieODqeOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5zZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIuc2V0TGlzdGVuZXIobGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICogQHNpZ25hdHVyZSBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKVxuICogQGRlc2NyaXB0aW9uXG4gKiBbZW5dRGlzYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOBquOBhOOCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5kaXNhYmxlKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKVxuICogQGRlc2NyaXB0aW9uXG4gKiBbZW5dRW5hYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZW5hYmxlKCk7XG59O1xuXG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbFxuICogQHNpZ25hdHVyZSBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbCgpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iuOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gIH1cbiAgb25zLl9pbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbFxuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlLlsvZW5dXG4gKiAgIFtqYV1pT1M35Lul5LiK44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS54Sh5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gIH1cbiAgb25zLl9pbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQW5pbWF0aW9uc1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYWxsIGFuaW1hdGlvbnMuIENvdWxkIGJlIGhhbmR5IGZvciB0ZXN0aW5nIGFuZCBvbGRlciBkZXZpY2VzLlsvZW5dXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLlhajjgabnhKHlirnjgavjgZfjgb7jgZnjgILjg4bjgrnjg4jjga7pmpvjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQW5pbWF0aW9uc1xuICogQHNpZ25hdHVyZSBlbmFibGVBbmltYXRpb25zKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGFuaW1hdGlvbnMgKGRlZmF1bHQpLlsvZW5dXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgb25zLl9pbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBdXRvU3R5bGluZygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYXV0b21hdGljIHN0eWxpbmcuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0eWxpbmcgPSBvbnMuX2F1dG9TdHlsZS5kaXNhYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0eWxpbmdcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgYXV0b21hdGljIHN0eWxpbmcgYmFzZWQgb24gT1MgKGRlZmF1bHQpLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0eWxpbmcgPSBvbnMuX2F1dG9TdHlsZS5lbmFibGU7XG5cbi8qKlxuICogQG1ldGhvZCBmb3JjZVBsYXRmb3JtU3R5bGluZ1xuICogQHNpZ25hdHVyZSBmb3JjZVBsYXRmb3JtU3R5bGluZyhwbGF0Zm9ybSlcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVmcmVzaCBzdHlsaW5nIGZvciB0aGUgZ2l2ZW4gcGxhdGZvcm0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm0gTmV3IHBsYXRmb3JtIHRvIHN0eWxlIHRoZSBlbGVtZW50cy5cbiAqL1xub25zLmZvcmNlUGxhdGZvcm1TdHlsaW5nID0gbmV3UGxhdGZvcm0gPT4ge1xuICBvbnMuZW5hYmxlQXV0b1N0eWxpbmcoKTtcbiAgb25zLnBsYXRmb3JtLnNlbGVjdChuZXdQbGF0Zm9ybSB8fCAnaW9zJyk7XG5cbiAgb25zLl91dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWlmJykge1xuICAgICAgICBlbGVtZW50Ll9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUubWF0Y2goL15vbnMtL2kpKSB7XG4gICAgICAgIG9ucy5fYXV0b1N0eWxlLnByZXBhcmUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICAgICAgZWxlbWVudC5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubGlua11cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbm9ucy5fY3JlYXRlUG9wb3Zlck9yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgaWYgKCFwYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHVybCBtdXN0IGJlIGRlZmluZWQuJyk7XG4gIH1cblxuICByZXR1cm4gb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2goLzxvbnMtcG9wb3Zlci9naSkgPyBgPGRpdj4ke2h0bWx9PC9kaXY+YCA6IGA8b25zLXBvcG92ZXI+JHtodG1sfTwvb25zLXBvcG92ZXI+YDtcbiAgICBjb25zdCBkaXYgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcblxuICAgIGNvbnN0IHBvcG92ZXIgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLXBvcG92ZXInKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsocG9wb3Zlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcG92ZXI7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVBvcG92ZXJcbiAqIEBzaWduYXR1cmUgY3JlYXRlUG9wb3ZlcihwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlUG9wb3ZlciA9IG9ucy5fY3JlYXRlUG9wb3Zlck9yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xub25zLl9jcmVhdGVEaWFsb2dPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLWRpYWxvZy9naSkgPyBgPGRpdj4ke2h0bWx9PC9kaXY+YCA6IGA8b25zLWRpYWxvZz4ke2h0bWx9PC9vbnMtZGlhbG9nPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBkaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWRpYWxvZycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcblxuICAgIGlmIChvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgb3B0aW9ucy5saW5rKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpYWxvZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlRGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZURpYWxvZyhwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlRGlhbG9nID0gb25zLl9jcmVhdGVEaWFsb2dPcmlnaW5hbDtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubGlua11cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbm9ucy5fY3JlYXRlQWxlcnREaWFsb2dPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLWFsZXJ0LWRpYWxvZy9naSkgPyBgPGRpdj4ke2h0bWx9PC9kaXY+YCA6IGA8b25zLWFsZXJ0LWRpYWxvZz4ke2h0bWx9PC9vbnMtYWxlcnQtZGlhbG9nPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBhbGVydERpYWxvZyA9IGRpdi5xdWVyeVNlbGVjdG9yKCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhbGVydERpYWxvZyk7XG5cbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMubGluayhhbGVydERpYWxvZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsZXJ0RGlhbG9nO1xuICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVBbGVydERpYWxvZ1xuICogQHNpZ25hdHVyZSBjcmVhdGVBbGVydERpYWxvZyhwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1hbGVydC1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgYWxlcnQgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBhbGVydCBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlQWxlcnREaWFsb2cgPSBvbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtcbiAqL1xub25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBsaW5rKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnRzXG4gICAgICAuZmlsdGVyKGVsZW1lbnQgPT4gIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwYWdlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJywgcGFnZSk7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlLCBsaW5rKTtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gb25zLWxvYWRpbmctcGxhY2Vob2xkZXIgZXhpc3RzLicpO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlclxuICogQHNpZ25hdHVyZSByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKHBhZ2UpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1JZiBubyBwYWdlIGlzIGRlZmluZWQgZm9yIHRoZSBgb25zLWxvYWRpbmctcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSBpdCB3aWxsIHdhaXQgZm9yIHRoaXMgbWV0aG9kIGJlaW5nIGNhbGxlZCBiZWZvcmUgbG9hZGluZyB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWxvYWRpbmctcGxhY2Vob2xkZXLjga7lsZ7mgKflgKTjgajjgZfjgabjg5rjg7zjgrjjgYzmjIflrprjgZXjgozjgabjgYTjgarjgYTloLTlkIjjga/jgIHjg5rjg7zjgrjjg63jg7zjg4nliY3jgavlkbzjgbDjgozjgotvbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcuWHpueQhuOBjOihjOOCj+OCjOOCi+OBvuOBp+ihqOekuuOBleOCjOOBvuOBm+OCk+OAglsvamFdXG4gKi9cbm9ucy5yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyT3JpZ2luYWw7XG5cbm9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5yZWFkeSgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xuXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHBhZ2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb25zLWxvYWRpbmctcGxhY2Vob2xkZXInKTtcbiAgICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKGVsZW1lbnQsIHBhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbm9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHBhZ2UsIGxpbmspIHtcbiAgbGluayA9IGxpbmsgfHwgZnVuY3Rpb24oZWxlbWVudCwgZG9uZSkgeyBkb25lKCk7IH07XG4gIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuXG4gICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG4gICAgY29udGVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudEVsZW1lbnQpO1xuXG4gICAgbGluayhjb250ZW50RWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgfSk7XG5cbiAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlZCB0byByZXNvbHZlIHBsYWNlaG9sZGVyOiAnICsgZXJyb3IpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHdhaXREZXZpY2VSZWFkeSgpIHtcbiAgY29uc3QgdW5sb2NrRGV2aWNlUmVhZHkgPSBvbnMuX3JlYWR5TG9jay5sb2NrKCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIGlmIChvbnMuaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHVubG9ja0RldmljZVJlYWR5LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59XG5cbndpbmRvdy5fc3VwZXJTZWNyZXRPbnMgPSBvbnM7XG5leHBvcnQgZGVmYXVsdCBvbnM7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHsgLy8gY2FzZSBvZiBTYWZhcmlcbiAgICBjb25zdCBCYXNlRWxlbWVudCA9ICgpID0+IHt9O1xuICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBCYXNlRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUVsZW1lbnQgZXh0ZW5kcyBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICBzZWxmID0gc3VwZXIoc2VsZik7XG4gICAgc2VsZi5pbml0KCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBpbml0KCkgeyB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRlbXBsYXRlXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEZWZpbmUgYSBzZXBhcmF0ZSBIVE1MIGZyYWdtZW50IGFuZCB1c2UgYXMgYSB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgVGhlc2UgdGVtcGxhdGVzIGNhbiBiZSBsb2FkZWQgYXMgcGFnZXMgaW4gYDxvbnMtbmF2aWdhdG9yPmAsIGA8b25zLXRhYmJhcj5gIGFuZCBgPG9ucy1zcGxpdHRlcj5gLiBUaGV5IGNhbiBhbHNvIGJlIHVzZWQgdG8gZ2VuZXJhdGUgZGlhbG9ncy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBqOOBl+OBpuS9v+eUqOOBmeOCi+OBn+OCgeOBrkhUTUzjg5Xjg6njgrDjg6Hjg7Pjg4jjgpLlrprnvqnjgZfjgb7jgZnjgILjgZPjga7opoHntKDjgadIVE1M44KS5a6j6KiA44GZ44KL44Go44CBaWTlsZ7mgKfjgavmjIflrprjgZfjgZ/lkI3liY3jgpJwYWdl44GuVVJM44Go44GX44Gmb25zLW5hdmlnYXRvcuOBquOBqeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBi+OCieWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtbmF2aWdhdG9yXG4gKiAgIFtlbl1UaGUgYDxvbnMtbmF2aWdhdG9yPmAgY29tcG9uZW50IGVuYWJsZXMgc3RhY2sgYmFzZWQgbmF2aWdhdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWJiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBhZGQgdGFiIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBkcmFnZ2FibGUgbWVudSBvciBjb2x1bW4gYmFzZWQgbGF5b3V0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJmb29iYXIuaHRtbFwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgUGFnZSBjb250ZW50XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLW5hdmlnYXRvciBwYWdlPVwiZm9vYmFyLmh0bWxcIj5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVtcGxhdGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdGVtcGxhdGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGVtcGxhdGUgY29udGVudC4gVGhpcyBwcm9wZXJ0eSBjYW4gbm90IGJlIHVzZWQgd2l0aCBBbmd1bGFySlMgYmluZGluZ3MuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLmlubmVySFRNTDtcblxuICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ190ZW1wbGF0ZWxvYWRlZCcsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgZXZlbnQudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIGV2ZW50LnRlbXBsYXRlSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGVtcGxhdGUnLCBUZW1wbGF0ZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4uL29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pZlxuICogQGNhdGVnb3J5IGNvbmRpdGlvbmFsXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWZcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29uZGl0aW9uYWxseSBkaXNwbGF5IGNvbnRlbnQgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSwgZGV2aWNlIG9yaWVudGF0aW9uIG9yIGJvdGguXG4gKlxuICogICAgIFNvbWV0aW1lcyBpdCBpcyB1c2VmdWwgdG8gY29uZGl0aW9uYWxseSBoaWRlIG9yIHNob3cgY2VydGFpbiBjb21wb25lbnRzIGJhc2VkIG9uIHBsYXRmb3JtLiBXaGVuIHJ1bm5pbmcgb24gaU9TIHRoZSBgPG9ucy1pZj5gIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gaGlkZSB0aGUgYDxvbnMtZmFiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1pZiBvcmllbnRhdGlvbj1cImxhbmRzY2FwZVwiPlxuICogICAgIExhbmRzY2FwZSB2aWV3IVxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImFuZHJvaWRcIj5cbiAqICAgICBUaGlzIGlzIEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiaW9zIG90aGVyXCI+XG4gKiAgICAgVGhpcyBpcyBub3QgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhdGZvcm1cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwYWNlLXNlcGFyYXRlZCBwbGF0Zm9ybSBuYW1lcy4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJpb3NcImAsIGBcImFuZHJvaWRcImAsIGBcIndpbmRvd3NcImAgYW5kIGBcIm90aGVyXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3JpZW50YXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWl0aGVyIGBcInBvcnRyYWl0XCJgIG9yIGBcImxhbmRzY2FwZVwiYC5bL2VuXVxuICAgKiAgW2phXXBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GX44G+44GZWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHBsYXRmb3JtLl9yZW5kZXJQbGF0Zm9ybSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ29yaWVudGF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnb3JpZW50YXRpb24nKSB7XG4gICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgfVxuXG4gIF9wbGF0Zm9ybVVwZGF0ZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICBfaXNBbGxvd2VkUGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcbiAgfVxuXG4gIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb3JpZW50YXRpb24nKSAmJiB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25hbE9yaWVudGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKSA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gKGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPT09IGN1cnJlbnRPcmllbnRhdGlvbikgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWYnLCBJZkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGNsYXNzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gdGltaW5nO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDAuOSwgMC45LCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBJT1NBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7QWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hbGVydC1kaWFsb2cnOiAnYWxlcnQtZGlhbG9nLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy10aXRsZSc6ICdhbGVydC1kaWFsb2ctdGl0bGUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250ZW50JzogJ2FsZXJ0LWRpYWxvZy1jb250ZW50LS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24nOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWZvb3Rlci0tb25lJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLW9uZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLW9uZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbC0tKicsXG4gICcuYWxlcnQtZGlhbG9nLW1hc2snOiAnYWxlcnQtZGlhbG9nLW1hc2stLSonLFxuICAnLnRleHQtaW5wdXQnOiAndGV4dC1pbnB1dC0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdub25lJzogQWxlcnREaWFsb2dBbmltYXRvcixcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIDogSU9TQWxlcnREaWFsb2dBbmltYXRvcixcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIDogSU9TQWxlcnREaWFsb2dBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYWxlcnQtZGlhbG9nXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFsZXJ0IGRpYWxvZyB0aGF0IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgc2NyZWVuLiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgcXVlc3Rpb25zLCB3YXJuaW5ncyBvciBlcnJvciBtZXNzYWdlcyB0byB0aGUgdXNlci4gVGhlIHRpdGxlLCBjb250ZW50IGFuZCBidXR0b25zIGNhbiBiZSBlYXNpbHkgY3VzdG9taXplZCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHN3aXRjaCBzdHlsZSBiYXNlZCBvbiB0aGUgcGxhdGZvcm0uXG4gKlxuICogICAgIFRvIHVzZSB0aGUgZWxlbWVudCBpdCBjYW4gZWl0aGVyIGJlIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBgPGJvZHk+YCBlbGVtZW50IG9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlIHVzaW5nIHRoZSBgb25zLmNyZWF0ZUFsZXJ0RGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIFF3d3h5cFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1vbnMtZGlhbG9nIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1vbnMtcG9wb3ZlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMubm90aWZpY2F0aW9uXG4gKiAgIFtlbl1Vc2luZyBvbnMubm90aWZpY2F0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFsZXJ0LWRpYWxvZyBpZD1cImFsZXJ0LWRpYWxvZ1wiPlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgQW4gZXJyb3IgaGFzIG9jY3VycmVkIVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICA8YnV0dG9uIGlkPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPk9LPC9idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FsZXJ0LWRpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruihqOekuuOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBoaWRpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KI44GG44Go44GZ44KL44Gu44KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBp+OBr1wibm9uZVwi44GLXCJkZWZhdWx0XCLjgYzmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIi5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fYm91bmRDYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2cnKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX3RpdGxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy10aXRsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWxlcnREaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgcmVzdWx0IGFmdGVyIGNvbXBpbGU6XG4gICAgICpcbiAgICAgKiA8b25zLWFsZXJ0LWRpYWxvZyBzdHlsZT1cIm5vbmVcIj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGlmICghdGhpcy5fbWFzayAmJiAhdGhpcy5fZGlhbG9nKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2cnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGRpYWxvZywgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2csICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctY29udGFpbmVyJyk7XG4gICAgICB0aGlzLl9kaWFsb2cuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0uYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICB0aGlzLl9kaWFsb2cuc3R5bGUuekluZGV4ID0gMjAwMDE7XG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IGNhbmNlbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NhbmNlbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjga7jga/jgIFcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgYFByb21pc2VgIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlc2hvdycsIHtcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlTaG93ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcxJztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLnNob3codGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0c2hvdycsIHthbGVydERpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2FsZXJ0RGlhbG9nOiB0aGlzfSk7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeUhpZGUoKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlaGlkZSBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBbGVydERpYWxvZ0FuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc0FsZXJ0RGlhbG9nRWxlbWVudC5BbGVydERpYWxvZ0FuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWxlcnREaWFsb2dBbmltYXRvcigpIHtcbiAgICByZXR1cm4gQWxlcnREaWFsb2dBbmltYXRvcjtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hbGVydC1kaWFsb2cnLCBBbGVydERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbnZhciBzY2hlbWUgPSB7XG4gICcnOiAnYmFjay1idXR0b24tLSonLFxuICAnLmJhY2stYnV0dG9uX19pY29uJzogJ2JhY2stYnV0dG9uLS0qX19pY29uJyxcbiAgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnOiAnYmFjay1idXR0b24tLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYmFjay1idXR0b25cbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJhY2sgYnV0dG9uIGNvbXBvbmVudCBmb3IgYDxvbnMtdG9vbGJhcj5gLiBQdXQgaXQgaW4gdGhlIGxlZnQgcGFydCBvZiB0aGUgYDxvbnMtdG9vbGJhcj5gLlxuICpcbiAqICAgICBJdCB3aWxsIGZpbmQgdGhlIHBhcmVudCBgPG9ucy1uYXZpZ2F0b3I+YCBlbGVtZW50IGFuZCBwb3AgYSBwYWdlIHdoZW4gY2xpY2tlZC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNwZWNpZnlpbmcgdGhlIGBvbkNsaWNrYCBwcm9wZXJ0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5db25zLW5hdmlnYXRvciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW5hdmlnYXRvcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIFRpdGxlXG4gKiAgIDxkaXY+XG4gKiA8L29ucy10b29sYmFyPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYmFjayBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0ge307XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2JhY2stYnV0dG9uJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gdXRpbC5jcmVhdGUoJ3NwYW4uYmFjay1idXR0b25fX2xhYmVsJyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9faWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGUoJ3NwYW4uYmFjay1idXR0b25fX2ljb24nKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIFwiLWlvc1wiIG9yIFwiLW1kXCJcbiAgICogICAgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gXCJsaWZ0LWlvc1wiLCBcImxpZnQtbWRcIi4gRGVmYXVsdHMgdmFsdWVzIGFyZSBcInNsaWRlLWlvc1wiIGFuZCBcImZhZGUtbWRcIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMucmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIHBvcFBhZ2UgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25DbGlja1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmF2aWdhdG9yID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtbmF2aWdhdG9yJyk7XG4gICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5wb3BQYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYmFjay1idXR0b24nLCBCYWNrQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2JvdHRvbS1iYXItLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYm90dG9tLXRvb2xiYXJcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRvb2xiYXIgY29tcG9uZW50IHRoYXQgaXMgcG9zaXRpb25lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjkuIvpg6jjgavphY3nva7jgZXjgozjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1NYWtlIHRoZSB0b29sYmFyIHRyYW5zcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7og4zmma/jgpLpgI/mmI7jgavjgZfjgabooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXIgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJvdHRvbS10b29sYmFyPlxuICogICBDb250ZW50XG4gKiA8L29ucy1ib3R0b20tdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm90dG9tVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7opovjgZ/nm67jga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYm90dG9tLWJhcicpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1wYWdlJykpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdwYWdlLXdpdGgtYm90dG9tLXRvb2xiYXInKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYm90dG9tLXRvb2xiYXInLCBCb3R0b21Ub29sYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2J1dHRvbi0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1idXR0b25cbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxuICogICBbZW5dQnV0dG9uIHdpdGggb3V0bGluZSBhbmQgdHJhbnNwYXJlbnQgYmFja2dyb3VuZFsvZW5dXG4gKiAgIFtqYV3jgqLjgqbjg4jjg6njgqTjg7PjgpLmjIHjgaPjgZ/jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxpZ2h0XG4gKiAgIFtlbl1CdXR0b24gdGhhdCBkb2Vzbid0IHN0YW5kIG91dC5bL2VuXVxuICogICBbamFd55uu56uL44Gf44Gq44GE44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBxdWlldFxuICogICBbZW5dQnV0dG9uIHdpdGggbm8gb3V0bGluZSBhbmQgb3IgYmFja2dyb3VuZC4uWy9lbl1cbiAqICAgW2phXeaeoOe3muOChOiDjOaZr+OBjOeEoeOBhOaWh+Wtl+OBoOOBkeOBruODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY3RhXG4gKiAgIFtlbl1CdXR0b24gdGhhdCByZWFsbHkgc3RhbmRzIG91dC5bL2VuXVxuICogICBbamFd55uu56uL44Gk44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZVxuICogICBbZW5dTGFyZ2UgYnV0dG9uIHRoYXQgY292ZXJzIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgovlpKfjgY3jgarjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1xdWlldFxuICogICBbZW5dTGFyZ2UgcXVpZXQgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgotxdWlldOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLWN0YVxuICogICBbZW5dTGFyZ2UgY2FsbCB0byBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgotjdGHjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODnOOCv+ODs1svamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWwtLWZsYXRcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBmbGF0IGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5Xjg6njg4Pjg4jjg5zjgr/jg7NbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCdXR0b24gY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBwbGFjZSBhIGJ1dHRvbiBpbiBhIHRvb2xiYXIsIHVzZSBgPG9ucy10b29sYmFyLWJ1dHRvbj5gIG9yIGA8b25zLWJhY2stYnV0dG9uPmAgaW5zdGVhZC5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYXMgYSBNYXRlcmlhbCBEZXNpZ24gYnV0dG9uIHdpdGggYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgILjg4Tjg7zjg6vjg5Djg7zjgavjg5zjgr/jg7PjgpLoqK3nva7jgZnjgovloLTlkIjjga/jgIFvbnMtdG9vbGJhci1idXR0b27jgoLjgZfjgY/jga9vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9idXR0b25cbiAqIEBndWlkZSBCdXR0b24gW2VuXUd1aWRlIGZvciBgPG9ucy1idXR0b24+YFsvZW5dW2phXTxvbnMtYnV0dG9uPuOBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIG1vZGlmaWVyPVwibGFyZ2UtLWN0YVwiPlxuICogICBUYXAgTWVcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByaXBwbGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgdGhlIGJ1dHRvbiB3aWxsIGhhdmUgYSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbicpO1xuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJ1dHRvbicsIEJ1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdjYXJvdXNlbC1pdGVtLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbFxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXTxvbnMtY2Fyb3VzZWw+44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ11cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwtaXRlbScsIENhcm91c2VsSXRlbUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi4vb25zL2Rvb3Jsb2NrJztcblxuY29uc3QgVmVydGljYWxNb2RlVHJhaXQgPSB7XG5cbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgfSxcblxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUudmVsb2NpdHlZO1xuICB9LFxuXG4gIF9nZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gIH0sXG5cbiAgX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtOiBmdW5jdGlvbihzY3JvbGwpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKDBweCwgJyArIC1zY3JvbGwgKyAncHgsIDBweCknO1xuICB9LFxuXG4gIF91cGRhdGVEaW1lbnNpb25EYXRhOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZU9mZnNldDogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuX2RpbWVuc2lvbnMuaGVpZ2h0IHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ1RvcCwgMTApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gLShoZWlnaHQgLSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkpIC8gMjtcbiAgICB9XG4gIH0sXG5cbiAgX2xheW91dENhcm91c2VsSXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKTtcblxuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUuaGVpZ2h0ID0gc2l6ZUF0dHI7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gKGkgKiBzaXplSW5mby5udW1iZXIpICsgc2l6ZUluZm8udW5pdDtcbiAgICB9XG4gIH0sXG5cbiAgX3NldHVwOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbkRhdGEoKTtcbiAgICB0aGlzLl91cGRhdGVPZmZzZXQoKTtcbiAgICB0aGlzLl9sYXlvdXRDYXJvdXNlbEl0ZW1zKCk7XG4gIH1cbn07XG5cbmNvbnN0IEhvcml6b250YWxNb2RlVHJhaXQgPSB7XG5cbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWDtcbiAgfSxcblxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUudmVsb2NpdHlYO1xuICB9LFxuXG4gIF9nZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm06IGZ1bmN0aW9uKHNjcm9sbCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoJyArIC1zY3JvbGwgKyAncHgsIDBweCwgMHB4KSc7XG4gIH0sXG5cbiAgX3VwZGF0ZURpbWVuc2lvbkRhdGE6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICB0aGlzLl9kaW1lbnNpb25zID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBfdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XG4gICAgICBjb25zdCB3aWR0aCA9ICh0aGlzLl9kaW1lbnNpb25zLndpZHRoIHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0xlZnQsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gLSh3aWR0aCAtIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSkgLyAyO1xuICAgIH1cbiAgfSxcblxuICBfbGF5b3V0Q2Fyb3VzZWxJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS53aWR0aCA9IHNpemVBdHRyO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAoaSAqIHNpemVJbmZvLm51bWJlcikgKyBzaXplSW5mby51bml0O1xuICAgIH1cbiAgfSxcblxuICBfc2V0dXA6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBjb21wb25lbnQuIEEgY2Fyb3VzZWwgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBzZXZlcmFsIGl0ZW1zIGluIHRoZSBzYW1lIHNwYWNlLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBq+ihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSMOWni+OBvuOCiuOBruOCpOODs+ODh+ODg+OCr+OCueOBp+aMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOWApOOBryAwIOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5a2Q6KaB57Sg44Gu5pWw44GM5aSJ44KP44KL44Go44Kr44Or44O844K744Or44Gv6Ieq5YuV55qE44Gr5pu05paw44GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9zY3JvbGwgPSAwO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcblxuICAgIHRoaXMuX2JvdW5kT25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG4gIH1cblxuICBfb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgICBkZWxldGUgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gIH1cblxuICBfb25EaXJlY3Rpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1ggPSAnYXV0byc7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WCA9ICcnO1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBfc2F2ZUxhc3RTdGF0ZSgpIHtcbiAgICB0aGlzLl9sYXN0U3RhdGUgPSB7XG4gICAgICBlbGVtZW50U2l6ZTogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpLFxuICAgICAgY2Fyb3VzZWxFbGVtZW50Q291bnQ6IHRoaXMuaXRlbUNvdW50LFxuICAgICAgd2lkdGg6IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIHRoaXMuaXRlbUNvdW50XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIHtcbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG5cbiAgICBpZiAoc2l6ZUluZm8udW5pdCA9PT0gJyUnKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzaXplSW5mby5udW1iZXIgLyAxMDAgKiBlbGVtZW50U2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplSW5mby51bml0ID09PSAncHgnKSB7XG4gICAgICByZXR1cm4gc2l6ZUluZm8ubnVtYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldEluaXRpYWxJbmRleCgpIHtcbiAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdpbml0aWFsLWluZGV4JyksIDEwKTtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInICYmICFpc05hTihpbmRleCkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKSB7XG4gICAgY29uc3QgYXR0ck5hbWUgPSAnaXRlbS0nICsgKHRoaXMuX2lzVmVydGljYWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyk7XG4gICAgY29uc3QgaXRlbVNpemVBdHRyID0gKCcnICsgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKS50cmltKCk7XG5cbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHNpemUubWF0Y2goL14oXFxkKykocHh8JSkvKTtcblxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgIHVuaXQ6IG1hdGNoZXNbMl0sXG4gICAgfTtcbiAgfVxuXG4gIF9zZXR1cEluaXRpYWxJbmRleCgpIHtcbiAgICB0aGlzLl9zY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAqICAgW2phXWNhcm91c2Vs6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIGA8b25zLWNhcm91c2VsLWl0ZW0+YCB0byBzaG93LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSaW5kZXjjgafmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICB7IGR1cmF0aW9uOiAwLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScgfSxcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIDoge31cbiAgICApO1xuXG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSk7XG4gICAgY29uc3Qgc2Nyb2xsID0gKHRoaXMuX29mZnNldCB8fCAwKSArIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIGluZGV4O1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgdGhpcy5fc2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsLCBvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZUluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBl+OBpuOBhOOCi+OCq+ODq+ODvOOCu+ODq+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOBjOi/lOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBleOCjOOBpuOBhOOCi29ucy1jYXJvdXNlbC1pdGVt6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZUluZGV4KCkge1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbCAtICh0aGlzLl9vZmZzZXQgfHwgMCk7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuXG4gICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBpZiAoc2l6ZSAqIGkgPD0gc2Nyb2xsICYmIHNpemUgKiAoaSArIDEpID4gc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1heCBjYXJvdXNlbCBpbmRleFxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2lzRW5hYmxlZENoYW5nZUV2ZW50KCkge1xuICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcbiAgICBjb25zdCBjYXJvdXNlbEl0ZW1TaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuYXV0b1Njcm9sbCAmJiBNYXRoLmFicyhlbGVtZW50U2l6ZSAtIGNhcm91c2VsSXRlbVNpemUpIDwgMC41O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgX3ByZXBhcmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdMb2NrVG9BeGlzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHRoaXMucmVmcmVzaCgpKTtcblxuICAgIHRoaXMuX3VwZGF0ZVN3aXBlYWJsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZUF1dG9SZWZyZXNoKCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuXG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBfdXBkYXRlU3dpcGVhYmxlKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLnN3aXBlYWJsZSkge1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93bicsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBdXRvUmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKSkge1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKSB7XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5nZXRBY3RpdmVJbmRleCgpO1xuXG4gICAgaWYgKHRoaXMuX2xhc3RBY3RpdmVJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICBjb25zdCBsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXg7XG4gICAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjdXJyZW50SW5kZXg7XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICAgIGFjdGl2ZUluZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgIGxhc3RBY3RpdmVJbmRleDogbGFzdEFjdGl2ZUluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfaXNXcm9uZ0RpcmVjdGlvbihkKSB7XG4gICAgLy8gdGhpcy5fbGFzdERyYWdEaXJlY3Rpb24gPSBkO1xuICAgIHJldHVybiB0aGlzLl9pc1ZlcnRpY2FsKCkgPyAoZCA9PT0gJ2xlZnQnIHx8IGQgPT09ICdyaWdodCcpIDogKGQgPT09ICd1cCcgfHwgZCA9PT0gJ2Rvd24nKTtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNXcm9uZ0RpcmVjdGlvbihldmVudC5nZXN0dXJlLmRpcmVjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuX2xhc3REcmFnRXZlbnQgPSBldmVudDtcblxuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KTtcbiAgICB0aGlzLl9zY3JvbGxUbyhzY3JvbGwpO1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2xhc3REcmFnRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Njcm9sbCA9IHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KTtcblxuICAgIC8vIGlmICghdGhpcy5faXNXcm9uZ0RpcmVjdGlvbih0aGlzLl9sYXN0RHJhZ0RpcmVjdGlvbikgJiYgdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpICE9PSAwKSB7XG4gICAgLy8gICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyB9XG5cbiAgICBpZiAodGhpcy5faXNPdmVyU2Nyb2xsKHRoaXMuX3Njcm9sbCkpIHtcbiAgICAgIGxldCB3YWl0Rm9yQWN0aW9uID0gZmFsc2U7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ292ZXJzY3JvbGwnLCB7XG4gICAgICAgIGNhcm91c2VsOiB0aGlzLFxuICAgICAgICBhY3RpdmVJbmRleDogdGhpcy5nZXRBY3RpdmVJbmRleCgpLFxuICAgICAgICBkaXJlY3Rpb246IHRoaXMuX2dldE92ZXJTY3JvbGxEaXJlY3Rpb24oKSxcbiAgICAgICAgd2FpdFRvUmV0dXJuOiAocHJvbWlzZSkgPT4ge1xuICAgICAgICAgIHdhaXRGb3JBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIHByb21pc2UudGhlbigoKSA9PiB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF3YWl0Rm9yQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhcnRNb21lbnR1bVNjcm9sbCgpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gbnVsbDtcblxuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhaXRcbiAgICovXG4gIF9taXhpbih0cmFpdCkge1xuICAgIE9iamVjdC5rZXlzKHRyYWl0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpc1trZXldID0gdHJhaXRba2V5XTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgX3N0YXJ0TW9tZW50dW1TY3JvbGwoKSB7XG4gICAgaWYgKHRoaXMuX2xhc3REcmFnRXZlbnQpIHtcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGhpcy5fZ2V0U2Nyb2xsVmVsb2NpdHkodGhpcy5fbGFzdERyYWdFdmVudCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IDAuMztcbiAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0gZHVyYXRpb24gKiAxMDAgKiB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKFxuICAgICAgICB0aGlzLl9zY3JvbGwgKyAodGhpcy5fZ2V0U2Nyb2xsRGVsdGEodGhpcy5fbGFzdERyYWdFdmVudCkgPiAwID8gLXNjcm9sbERlbHRhIDogc2Nyb2xsRGVsdGEpXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9zY3JvbGwgPSBzY3JvbGw7XG5cbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0odGhpcy5fc2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKHNjcm9sbCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgaWYgKCF0aGlzLmF1dG9TY3JvbGwpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIH1cbiAgICBsZXQgYXJyID0gW107XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKTtcbiAgICBjb25zdCBuYnJPZkl0ZW1zID0gdGhpcy5pdGVtQ291bnQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ick9mSXRlbXM7IGkrKykge1xuICAgICAgaWYgKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0IDwgbWF4KSB7XG4gICAgICAgIGFyci5wdXNoKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJyLnB1c2gobWF4KTtcblxuICAgIGFyci5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBsZWZ0ID0gTWF0aC5hYnMobGVmdCAtIHNjcm9sbCk7XG4gICAgICByaWdodCA9IE1hdGguYWJzKHJpZ2h0IC0gc2Nyb2xsKTtcblxuICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICB9KTtcblxuICAgIGFyciA9IGFyci5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgcG9zKSB7XG4gICAgICByZXR1cm4gIXBvcyB8fCBpdGVtICE9IGFycltwb3MgLSAxXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuICAgIGxldCByZXN1bHQgPSBhcnJbMF07XG5cbiAgICBpZiAoc2Nyb2xsUmF0aW8gPD0gdGhpcy5hdXRvU2Nyb2xsUmF0aW8pIHtcbiAgICAgIHJlc3VsdCA9IGxhc3RTY3JvbGw7XG4gICAgfSBlbHNlIGlmIChzY3JvbGxSYXRpbyA8IDEuMCkge1xuICAgICAgaWYgKGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBhcnJbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgcmVzdWx0KSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1jYXJvdXNlbC1pdGVtJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50XG4gICAqL1xuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpc092ZXJzY3JvbGxhYmxlID0gdGhpcy5vdmVyc2Nyb2xsYWJsZTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZVNjcm9sbCA9IChzY3JvbGwpID0+IHtcbiAgICAgIGNvbnN0IHJhdGlvID0gMC4zNTtcblxuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGlzT3ZlcnNjcm9sbGFibGUgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IG1heFNjcm9sbCArIE1hdGgucm91bmQoKHNjcm9sbCAtIG1heFNjcm9sbCkgKiByYXRpbykgOiBtYXhTY3JvbGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY3JvbGw7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkpXG4gICAgICAgIH0sIG9wdGlvbnMuYW5pbWF0aW9uICAhPT0gJ25vbmUnID8gb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIDoge30pXG4gICAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY3VsYXRlTWF4U2Nyb2xsKCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuaXRlbUNvdW50ICogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIC0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG1heCA8IDAgPyAwIDogbWF4KTsgLy8gTmVlZCB0byByZXR1cm4gYW4gaW50ZWdlciB2YWx1ZS5cbiAgfVxuXG4gIF9pc092ZXJTY3JvbGwoc2Nyb2xsKSB7XG4gICAgaWYgKHNjcm9sbCA8IDAgfHwgc2Nyb2xsID4gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfZ2V0T3ZlclNjcm9sbERpcmVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgfVxuXG4gIF9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gMC40O1xuXG4gICAgaWYgKHRoaXMuX3Njcm9sbCA8IDApIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0oMClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAucGxheSgpO1xuICAgICAgdGhpcy5fc2Nyb2xsID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcblxuICAgIGlmIChtYXhTY3JvbGwgPCB0aGlzLl9zY3JvbGwpIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obWF4U2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjQsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgICB0aGlzLl9zY3JvbGwgPSBtYXhTY3JvbGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpdGVtQ291bnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbnVtYmVyIG9mIGNhcm91c2VsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+imgee0oOOBruaVsOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVwZGF0ZSB0aGUgbGF5b3V0IG9mIHRoZSBjYXJvdXNlbC4gVXNlZCB3aGVuIGFkZGluZyBgPG9ucy1jYXJvdXNlbC1pdGVtcz5gIGR5bmFtaWNhbGx5IG9yIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSBzaXplLlsvZW5dXG4gICAqICAgW2phXeODrOOCpOOCouOCpuODiOOChOWGhemDqOOBrueKtuaFi+OCkuacgOaWsOOBruOCguOBruOBq+abtOaWsOOBl+OBvuOBmeOAgm9ucy1jYXJvdXNlbC1pdGVt44KS5YuV55qE44Gr5aKX44KE44GX44Gf44KK44CBb25zLWNhcm91c2Vs44Gu5aSn44GN44GV44KS5YuV55qE44Gr5aSJ44GI44KL6Zqb44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgLy8gQnVnIGZpeFxuICAgIGlmICh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9taXhpbih0aGlzLl9pc1ZlcnRpY2FsKCkgPyBWZXJ0aWNhbE1vZGVUcmFpdCA6IEhvcml6b250YWxNb2RlVHJhaXQpO1xuICAgIHRoaXMuX3NldHVwKCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlICYmIHRoaXMuX2xhc3RTdGF0ZS53aWR0aCA+IDApIHtcbiAgICAgIGxldCBzY3JvbGwgPSB0aGlzLl9zY3JvbGw7Ly8gLSB0aGlzLl9vZmZzZXQ7XG5cbiAgICAgIGlmICh0aGlzLl9pc092ZXJTY3JvbGwoc2Nyb2xsKSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hdXRvU2Nyb2xsKSB7XG4gICAgICAgICAgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHNjcm9sbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywge2Nhcm91c2VsOiB0aGlzfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBmaXJzdFxuICAgKiBAc2lnbmF0dXJlIGZpcnN0KClcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBmaXJzdCBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZmlyc3Qob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KDAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbGFzdFxuICAgKiBAc2lnbmF0dXJlIGxhc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbGFzdCBvbnMtY2Fyb3VzZWwgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3mnIDlvozjga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBsYXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldEFjdGl2ZUluZGV4KFxuICAgICAgTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuX3NldHVwKCk7XG4gICAgdGhpcy5fc2V0dXBJbml0aWFsSW5kZXgoKTtcblxuICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcblxuICAgIC8vIEZpeCByZW5kZXJpbmcgZ2xpdGNoIG9uIEFuZHJvaWQgNC4xXG4gICAgaWYgKHRoaXMub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N3aXBlYWJsZScsICdhdXRvLXJlZnJlc2gnLCAnZGlyZWN0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXV0by1yZWZyZXNoJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlQXV0b1JlZnJlc2goKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9vbkRpcmVjdGlvbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxSYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgYXV0byBzY3JvbGwgcmF0aW8uIFsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsUmF0aW8oKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycpO1xuXG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICByZXR1cm4gMC41O1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gcGFyc2VGbG9hdChhdHRyKTtcbiAgICBpZiAoc2Nyb2xsUmF0aW8gPCAwLjAgfHwgc2Nyb2xsUmF0aW8gPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOYU4oc2Nyb2xsUmF0aW8pID8gMC41IDogc2Nyb2xsUmF0aW87XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmF0aW8uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIHRoZSBjYXJvdXNlbCBpcyBzd2lwZWFibGUuWy9lbl1cbiAgICogICBbamFdc3dpcGVhYmxl44Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgc3dpcGVhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJyk7XG4gIH1cblxuICBzZXQgc3dpcGVhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzd2lwZWFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Kq44O844OI44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgYXV0b1Njcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYXV0by1zY3JvbGwnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3ZlcnNjcm9sbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBvdmVyc2Nyb2xsYWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFdb3ZlcnNjcm9sbOOBp+OBjeOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG92ZXJzY3JvbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnb3ZlcnNjcm9sbGFibGUnKTtcbiAgfVxuXG4gIHNldCBvdmVyc2Nyb2xsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnb3ZlcnNjcm9sbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNlbnRlcmVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgY2VudGVyZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXWNlbnRlcmVk54q25oWL44Gr44Gq44Gj44Gm44GE44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgY2VudGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjZW50ZXJlZCcpO1xuICB9XG5cbiAgc2V0IGNlbnRlcmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjZW50ZXJlZCcsIHZhbHVlKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJvdXNlbCcsIENhcm91c2VsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNvbFxuICogQGNhdGVnb3J5IGdyaWRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIGNvbHVtbiBpbiB0aGUgZ3JpZCBzeXN0ZW0uIFVzZSB3aXRoIGA8b25zLXJvdz5gIHRvIGxheW91dCBjb21wb25lbnRzLlsvZW5dXG4gKiAgIFtqYV3jgrDjg6rjg4Pjg4njgrfjgrnjg4bjg6DjgavjgabliJfjgpLlrprnvqnjgZfjgb7jgZnjgIJvbnMtcm9344Go44Go44KC44Gr5L2/55So44GX44CB44Kz44Oz44Od44O844ON44Oz44OI44Gu44Os44Kk44Ki44Km44OI44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBub3RlXG4gKiAgIFtlbl1Gb3IgQW5kcm9pZCA0LjMgYW5kIGVhcmxpZXIsIGFuZCBpT1M2IGFuZCBlYXJsaWVyLCB3aGVuIHVzaW5nIG1peGVkIGFsaWdubWVudCB3aXRoIG9ucy1yb3cgYW5kIG9ucy1jb2x1bW4sIHRoZXkgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LiBZb3UgY2FuIHVzZSBvbmx5IG9uZSBhbGlnbm1lbnQuWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29sdW1u44KS57WE44G/5ZCI44KP44Gb44Gf5aC05ZCI44Gr5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxuICogQGd1aWRlIGxheW91dGluZyBbZW5dTGF5b3V0aW5nIGd1aWRlWy9lbl1bamFd44Os44Kk44Ki44Km44OI5qmf6IO9Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yb3dcbiAqICAgW2VuXVRoZSBgPG9ucy1yb3c+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBvZiBgPG9ucy1jb2w+YC5bL2VuXVxuICogICBbamFdb25zLXJvd+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yb3c+XG4gKiAgIDxvbnMtY29sIHdpZHRoPVwiNTBweFwiPjxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+PC9vbnMtY29sPlxuICogICA8b25zLWNvbD5UZXh0PC9vbnMtY29sPlxuICogPC9vbnMtcm93PlxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB2ZXJ0aWNhbC1hbGlnblxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgXCJ0b3BcIiwgXCJjZW50ZXJcIiwgYW5kIFwiYm90dG9tXCIuWy9lbl1cbiAqICAgW2phXee4puOBrumFjee9ruOCkuaMh+WumuOBmeOCi+OAglwidG9wXCIsIFwiY2VudGVyXCIsIFwiYm90dG9tXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB3aWR0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgY3NzIHdpZHRoIHZhbHVlcyAoXCIxMCVcIiwgXCI1MHB4XCIpLlsvZW5dXG4gKiAgIFtqYV3jgqvjg6njg6Djga7mqKrluYXjgpLmjIflrprjgZnjgovjgILjg5Hjg7zjgrvjg7Pjg4jjgoLjgZfjgY/jga/jg5Tjgq/jgrvjg6vjgafmjIflrprjgZfjgb7jgZnvvIgxMCXjgoQ1MHB477yJ44CCWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3aWR0aCA9ICgnJyArIHdpZHRoKS50cmltKCk7XG4gICAgICB3aWR0aCA9IHdpZHRoLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHRoaXMuc3R5bGUud2Via2l0Qm94RmxleCA9ICcwJztcbiAgICAgIHRoaXMuc3R5bGUud2Via2l0RmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5tb3pCb3hGbGV4ID0gJzAnO1xuICAgICAgdGhpcy5zdHlsZS5tb3pGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLm1zRmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5mbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLm1heFdpZHRoID0gd2lkdGg7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNvbCcsIENvbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGNsYXNzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IHRpbWluZztcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0RpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbi1vdXQnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAzMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWRlRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC0zNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtMzUwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHtEaWFsb2dBbmltYXRvciwgSU9TRGlhbG9nQW5pbWF0b3IsIEFuZHJvaWREaWFsb2dBbmltYXRvciwgU2xpZGVEaWFsb2dBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmRpYWxvZyc6ICdkaWFsb2ctLSonLFxuICAnLmRpYWxvZy1jb250YWluZXInOiAnZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuZGlhbG9nLW1hc2snOiAnZGlhbG9nLW1hc2stLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZERpYWxvZ0FuaW1hdG9yIDogSU9TRGlhbG9nQW5pbWF0b3IsXG4gICdzbGlkZSc6IFNsaWRlRGlhbG9nQW5pbWF0b3IsXG4gICdub25lJzogRGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLiBBcyBvcHBvc2VkIHRvIHRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50LCB0aGlzIGNvbXBvbmVudCBjYW4gY29udGFpbiBhbnkga2luZCBvZiBjb250ZW50LlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVEaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4genh4YUdhXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZ3VpZGUgZGlhbG9nc1xuICogICBbZW5dRGlhbG9nIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFdRGlhbG9nIGNvbXBvbmVudHNbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWFsZXJ0LWRpYWxvZ1xuICogICBbZW5dYDxvbnMtYWxlcnQtZGlhbG9nPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBvcG92ZXJcbiAqICAgW2VuXWA8b25zLXBvcG92ZXI+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXBvcG92ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLW1vZGFsXG4gKiAgIFtlbl1gPG9ucy1tb2RhbD5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbW9kYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtZGlhbG9nIGlkPVwiZGlhbG9nXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBkaWFsb2chPC9wPlxuICogPC9vbnMtZGlhbG9nPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWFsb2cnKS5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlhbG9nRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBrumdnuihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeODgOOCpOOCouODreOCsOOBr2Rpc2FibGVk54q25oWL44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgoLjgZfjgY/jga9cImRlZmF1bHRcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgYFwicmdiYSgwLCAwLCAwLCAwLjIpXCJgLlsvZW5dXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9kaWFsb2coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuZGlhbG9nJyk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fYm91bmRDYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogRGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnRGlhbG9nQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIC8qIEV4cGVjdGVkIHJlc3VsdDpcbiAgICAgKiAgIDxvbnMtZGlhbG9nPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZ1wiPlxuICAgICAqICAgICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICAgPC9vbnMtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZycpO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2ctY29udGFpbmVyJyk7XG5cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNob3cgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XG4gICAgICBkaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVoaWRlJywge1xuICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWhpZGUgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2FuaW1hdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RGlhbG9nQW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIERpYWxvZ0FuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc0RpYWxvZ0VsZW1lbnQuRGlhbG9nQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBEaWFsb2dBbmltYXRvcigpIHtcbiAgICByZXR1cm4gRGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZGlhbG9nJywgRGlhbG9nRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSonXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1mYWJcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxuICpcbiAqICAgICBJdCBjYW4gYmUgZGlzcGxheWVkIGVpdGhlciBhcyBhbiBpbmxpbmUgZWxlbWVudCBvciBpbiBvbmUgb2YgdGhlIGNvcm5lcnMuIE5vcm1hbGx5IGl0IHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ZhYlxuICogQGd1aWRlIGNyb3NzLXBsYXRmb3JtLXN0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudCBpcyBhIEZsb2F0aW5nIGFjdGlvbiBidXR0b24gdGhhdCBkaXNwbGF5cyBhIG1lbnUgd2hlbiB0YXBwZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgcG9zaXRpb24gb2YgdGhlIGJ1dHRvbi4gU2hvdWxkIGJlIGEgc3RyaW5nIGxpa2UgYFwiYm90dG9tIHJpZ2h0XCJgIG9yIGBcInRvcCBsZWZ0XCJgLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmZhYl9faWNvbicpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYWJfX2ljb24nKTtcblxuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1yaXBwbGUnKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ3Bvc2l0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUhpZGUgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZS50cmFuc2Zvcm0gPT09ICdzY2FsZSgxKScgJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWZhYicsIEZhYkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWdlc3R1cmUtZGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0byBkZXRlY3QgZmluZ2VyIGdlc3R1cmVzIHdpdGhpbiB0aGUgd3JhcHBlZCBlbGVtZW50LiBGb2xsb3dpbmcgZ2VzdHVyZXMgYXJlIHN1cHBvcnRlZDpcbiAqICAgICAtIERyYWcgZ2VzdHVyZXM6IGBkcmFnYCwgYGRyYWdsZWZ0YCwgYGRyYWdyaWdodGAsIGBkcmFndXBgLCBgZHJhZ2Rvd25gXG4gKiAgICAgLSBIb2xkIGdlc3R1cmVzOiBgaG9sZGAsIGByZWxlYXNlYFxuICogICAgIC0gU3dpcGUgZ2VzdHVyZXM6IGBzd2lwZWAsIGBzd2lwZWxlZnRgLCBgc3dpcGVyaWdodGAsIGBzd2lwZXVwYCwgYHN3aXBlZG93bmBcbiAqICAgICAtIFRhcCBnZXN0dXJlczogYHRhcGAsIGBkb3VibGV0YXBgXG4gKiAgICAgLSBQaW5jaCBnZXN0dXJlczogYHBpbmNoYCwgYHBpbmNoaW5gLCBgcGluY2hvdXRgXG4gKiAgICAgLSBPdGhlciBnZXN0dXJlczogYHRvdWNoYCwgYHRyYW5zZm9ybWAsIGByb3RhdGVgXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3opoHntKDlhoXjga7jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjgpLmpJznn6XjgZfjgb7jgZnjgILoqbPjgZfjgY/jga/jgqzjgqTjg4njgpLlj4LnhafjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICogQGd1aWRlIGdlc3R1cmUtZGV0ZWN0b3JcbiAqICAgW2VuXURldGVjdGluZyBmaW5nZXIgZ2VzdHVyZXNbL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44O85pON5L2c44Gu5qSc55+lWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gKiAgIDxkaXYgaWQ9XCJkZXRlY3QtYXJlYVwiIHN0eWxlPVwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDEwMHB4O1wiPlxuICogICAgIFN3aXBlIEhlcmVcbiAqICAgPC9kaXY+XG4gKiA8L29ucy1nZXN0dXJlLWRldGVjdG9yPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXBlbGVmdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgaWYgKGV2ZW50LnRhcmdldC5tYXRjaGVzKCcjZGV0ZWN0LWFyZWEnKSkge1xuICogICAgICAgY29uc29sZS5sb2coJ1N3aXBlIGxlZnQgaXMgZGV0ZWN0ZWQuJyk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICBpbml0KCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZ2VzdHVyZS1kZXRlY3RvcicsIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWNvblxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5cyBhbiBpY29uLiBUaGUgZm9sbG93aW5nIGljb24gc3VpdGVzIGFyZSBhdmFpbGFibGU6XG4gKlxuICogICAgICogW0ZvbnQgQXdlc29tZV0oaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lLylcbiAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbS8pXG4gKiAgICAgKiBbTWF0ZXJpYWwgRGVzaWduIEljb25pYyBGb250XShodHRwOi8vemF2b2xva2xvbS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25pYy1mb250LylcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4QWh2Z1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ljb25cbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pY29uXG4gKiAgIGljb249XCJtZC1jYXJcIlxuICogICBzaXplPVwiMjBweFwiXG4gKiAgIHN0eWxlPVwiY29sb3I6IHJlZFwiPlxuICogPC9vbnMtaWNvbj5cbiAqXG4gKiA8b25zLWJ1dHRvbj5cbiAqICAgPG9ucy1pY29uIGljb249XCJtZC1jYXJcIj48L29ucy1pY29uPlxuICogICBDYXJcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lLiBgXCJtZC1cImAgcHJlZml4IGZvciBNYXRlcmlhbCBJY29ucywgYFwiZmEtXCJgIGZvciBGb250IEF3ZXNvbWUgYW5kIGBcImlvbi1cImAgcHJlZml4IGZvciBJb25pY29ucy5cbiAgICpcbiAgICogICAgIFNlZSBhbGwgYXZhaWxhYmxlIGljb25zIG9uIHRoZWlyIHJlc3BlY3RpdmUgc2l0ZXM6XG4gICAqXG4gICAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gICAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbSlcbiAgICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gICAqXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICpcbiAgICogICAgIFRoZSBjb2RlOlxuICAgKlxuICAgKiAgICAgYGBgXG4gICAqICAgICA8b25zLWljb25cbiAgICogICAgICAgaWNvbj1cImlvbi1lZGl0LCBtYXRlcmlhbDptZC1lZGl0XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIGRpc3BsYXkgYFwibWQtZWRpdFwiYCBmb3IgTWF0ZXJpYWwgRGVzaWduIGFuZCBgXCJpb24tZWRpdFwiYCBhcyB0aGUgZGVmYXVsdCBpY29uLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHNpemVzIG9mIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIGxnLCAyeCwgM3gsIDR4LCA1eCwgb3IgaW4gdGhlIHNpemUgaW4gcGl4ZWxzLlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdFwiXG4gICAqICAgICAgIHNpemU9XCIzMnB4LCBtYXRlcmlhbDoyNHB4XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIHJlbmRlciBhcyBhIGAyNHB4YCBpY29uIGlmIHRoZSBgXCJtYXRlcmlhbFwiYCBtb2RpZmllciBpcyBwcmVzZW50IGFuZCBgMzJweGAgb3RoZXJ3aXNlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZfjgabooajnpLrjgZfjgb7jgZnjgII5MCwgMTgwLCAyNzDjgYvjgonmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC13aWR0aFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dV2hlbiB1c2VkIGluIGEgbGlzdCwgeW91IHdhbnQgdGhlIGljb25zIHRvIGhhdmUgdGhlIHNhbWUgd2lkdGggc28gdGhhdCB0aGV5IGFsaWduIHZlcnRpY2FsbHkgYnkgZGVmaW5pbmcgdGhpcyBhdHRyaWJ1dGUuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzcGluXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoZXRoZXIgdGhlIGljb24gc2hvdWxkIGJlIHNwaW5uaW5nLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaWNvbicsICdzaXplJywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChbJ2ljb24nLCAnc2l6ZScsICdtb2RpZmllciddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIF91cGRhdGUoKSB7XG4gICAgdGhpcy5fY2xlYW5DbGFzc0F0dHJpYnV0ZSgpO1xuICAgIGNvbnN0IHtjbGFzc0xpc3QsIHN0eWxlfSA9IHRoaXMuX2J1aWxkQ2xhc3NBbmRTdHlsZSh0aGlzLl9nZXRBdHRyaWJ1dGUoJ2ljb24nKSwgdGhpcy5fZ2V0QXR0cmlidXRlKCdzaXplJykpO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMuc3R5bGUsIHN0eWxlKTtcblxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfZ2V0QXR0cmlidXRlKGF0dHIpIHtcbiAgICBjb25zdCBwYXJ0cyA9ICh0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSB8fCAnJykuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIGNvbnN0IGRlZiA9IHBhcnRzWzBdO1xuICAgIGxldCBtZCA9IHBhcnRzWzFdO1xuICAgIG1kID0gKG1kIHx8ICcnKS5zcGxpdCgvXFxzKjpcXHMqLyk7XG4gICAgcmV0dXJuICh1dGlsLmhhc01vZGlmaWVyKHRoaXMsIG1kWzBdKSA/IG1kWzFdIDogZGVmKSB8fCAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdW5uZWVkZWQgY2xhc3MgdmFsdWUuXG4gICAqL1xuICBfY2xlYW5DbGFzc0F0dHJpYnV0ZSgpIHtcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdClcbiAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IC9eKGZhJHxmYS18aW9uLXx6bWRpLSkvLnRlc3QoY2xhc3NOYW1lKSlcbiAgICAgIC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3ptZGknKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ29ucy1pY29uLS1pb24nKTtcbiAgfVxuXG4gIF9idWlsZENsYXNzQW5kU3R5bGUoaWNvbk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBjbGFzc0xpc3QgPSBbJ29ucy1pY29uJ107XG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcblxuICAgIC8vIEljb25cbiAgICBpZiAoaWNvbk5hbWUuaW5kZXhPZignaW9uLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLWlvbicpO1xuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUuaW5kZXhPZignZmEtJykgPT09IDApIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKGljb25OYW1lKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYScpO1xuICAgIH0gZWxzZSBpZihpY29uTmFtZS5pbmRleE9mKCdtZC0nKSA9PT0gMCkgIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCd6bWRpJyk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaS0nICsgaWNvbk5hbWUuc3BsaXQoL1xcLSguKyk/LylbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEnKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgaWNvbk5hbWUpO1xuICAgIH1cblxuICAgIC8vIFNpemVcbiAgICBpZiAoc2l6ZS5tYXRjaCgvXlsxLTVdeHxsZyQvKSkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhLScgKyBzaXplKTtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtc2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5mb250U2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTGlzdDogY2xhc3NMaXN0LFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1pY29uJywgSWNvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCB7TGF6eVJlcGVhdERlbGVnYXRlLCBMYXp5UmVwZWF0UHJvdmlkZXJ9IGZyb20gJy4uL29ucy9pbnRlcm5hbC9sYXp5LXJlcGVhdCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxhenktcmVwZWF0XG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVc2luZyB0aGlzIGNvbXBvbmVudCBhIGxpc3Qgd2l0aCBtaWxsaW9ucyBvZiBpdGVtcyBjYW4gYmUgcmVuZGVyZWQgd2l0aG91dCBhIGRyb3AgaW4gcGVyZm9ybWFuY2UuXG4gKiAgICAgSXQgZG9lcyB0aGF0IGJ5IFwibGF6aWx5XCIgbG9hZGluZyBlbGVtZW50cyBpbnRvIHRoZSBET00gd2hlbiB0aGV5IGNvbWUgaW50byB2aWV3IGFuZFxuICogICAgIHJlbW92aW5nIGl0ZW1zIGZyb20gdGhlIERPTSB3aGVuIHRoZXkgYXJlIG5vdCB2aXNpYmxlLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI5YaF44Gn5o+P55S744GV44KM44KL44Ki44Kk44OG44Og44GuRE9N6KaB57Sg44Gu6Kqt44G/6L6844G/44Gv44CB55S76Z2i44Gr6KaL44GI44Gd44GG44Gr44Gq44Gj44Gf5pmC44G+44Gn6Ieq5YuV55qE44Gr6YGF5bu244GV44KM44CBXG4gKiAgICAg55S76Z2i44GL44KJ6KaL44GI44Gq44GP44Gq44Gj44Gf5aC05ZCI44Gr44Gv44Gd44Gu6KaB57Sg44Gv5YuV55qE44Gr44Ki44Oz44Ot44O844OJ44GV44KM44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/44GG44GT44Go44Gn44CB44OR44OV44Kp44O844Oe44Oz44K544KS5Yqj5YyW44GV44Gb44KL44GT44Go54Sh44GX44Gr5beo5aSn44Gq5pWw44Gu6KaB57Sg44KS5o+P55S744Gn44GN44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBRd3JHQm1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9sYXp5LXJlcGVhdFxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIHJlbmRlciBhIGxpc3QuWy9lbl1cbiAqICAgW2phXWA8b25zLWxpc3Q+YOimgee0oOOBr+ODquOCueODiOOCkuaPj+eUu+OBmeOCi+OBruOBq+S9v+OCj+OCjOOBvuOBmeOAglsvamFdXG4gKiBAZ3VpZGUgaW5maW5pdGUtc2Nyb2xsXG4gKiAgIFtlbl1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9lbl1cbiAqICAgW2phXUxvYWRpbmcgbW9yZSBpdGVtcyBvbiBpbmZpbml0ZSBzY3JvbGxbL2phXVxuICogQGV4YW1wbGVcbiAqIDxzY3JpcHQ+XG4gKiAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgdmFyIGxhenlSZXBlYXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbGlzdCcpO1xuICogICAgIGxhenlSZXBlYXQuZGVsZWdhdGUgPSB7XG4gKiAgICAgIGNyZWF0ZUl0ZW1Db250ZW50OiBmdW5jdGlvbihpLCB0ZW1wbGF0ZSkge1xuICogICAgICAgIHZhciBkb20gPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gKiAgICAgICAgZG9tLmlubmVyVGV4dCA9IGk7XG4gKlxuICogICAgICAgIHJldHVybiBkb207XG4gKiAgICAgIH0sXG4gKiAgICAgIGNvdW50SXRlbXM6IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiAxMDAwMDAwMDtcbiAqICAgICAgfSxcbiAqICAgICAgZGVzdHJveUl0ZW06IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gKiAgICAgICAgY29uc29sZS5sb2coJ0Rlc3Ryb3llZCBpdGVtIHdpdGggaW5kZXg6ICcgKyBpbmRleCk7XG4gKiAgICAgIH1cbiAqICAgICB9O1xuICogICB9KTtcbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxvbnMtbGlzdCBpZD1cImxpc3RcIj5cbiAqICAgPG9ucy1sYXp5LXJlcGVhdD5cbiAqICAgICA8b25zLWxpc3QtaXRlbT48L29ucy1saXN0LWl0ZW0+XG4gKiAgIDwvb25zLWxhenktcmVwZWF0PlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF6eVJlcGVhdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdXRpbC51cGRhdGVQYXJlbnRQb3NpdGlvbih0aGlzKTtcblxuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHByb3BlcnR5IGNhbiBvbmx5IGJlIHVzZWQgdG8gc2V0IHRoZSBkZWxlZ2F0ZSBvYmplY3QuJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxhenktcmVwZWF0JywgTGF6eVJlcGVhdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0X19oZWFkZXItLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1oZWFkZXJcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUhlYWRlciBlbGVtZW50IGZvciBsaXN0IGl0ZW1zLiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXeODquOCueODiOimgee0oOOBq+S9v+eUqOOBmeOCi+ODmOODg+ODgOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN044Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdC1pdGVtPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIGxpc3RzIFtlbl1Vc2luZyBsaXN0c1svZW5dW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGhlYWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RIZWFkZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBoZWFkZXIuWy9lbl1cbiAgICogICBbamFd44OY44OD44OA44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2hlYWRlcicpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtaGVhZGVyJywgTGlzdEhlYWRlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5saXN0X19pdGVtJzogJ2xpc3RfX2l0ZW0tLSonLFxuICAnLmxpc3RfX2l0ZW1fX2xlZnQnOiAnbGlzdF9faXRlbS0tKl9fbGVmdCcsXG4gICcubGlzdF9faXRlbV9fY2VudGVyJzogJ2xpc3RfX2l0ZW0tLSpfX2NlbnRlcicsXG4gICcubGlzdF9faXRlbV9fcmlnaHQnOiAnbGlzdF9faXRlbS0tKl9fcmlnaHQnLFxuICAnLmxpc3RfX2l0ZW1fX2xhYmVsJzogJ2xpc3RfX2l0ZW0tLSpfX2xhYmVsJyxcbiAgJy5saXN0X19pdGVtX190aXRsZSc6ICdsaXN0X19pdGVtLS0qX190aXRsZScsXG4gICcubGlzdF9faXRlbV9fc3VidGl0bGUnOiAnbGlzdF9faXRlbS0tKl9fc3VidGl0bGUnLFxuICAnLmxpc3RfX2l0ZW1fX3RodW1ibmFpbCc6ICdsaXN0X19pdGVtLS0qX190aHVtYm5haWwnLFxuICAnLmxpc3RfX2l0ZW1fX2ljb24nOiAnbGlzdF9faXRlbS0tKl9faWNvbidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaXRlbVxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciB0YXBwYWJsZVxuICogICBbZW5dTWFrZSB0aGUgbGlzdCBpdGVtIGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gaXQncyB0YXBwZWQuIE9uIGlPUyBpdCBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBcInRhcHBhYmxlXCIgYW5kIFwidGFwLWJhY2tncm91bmQtY29sb3JcIiBhdHRyaWJ1dGUgZm9yIGJldHRlciBiZWhhdmlvciB3aGVuIHNjcm9sbGluZy5bL2VuXVxuICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44GX44Gf5pmC44Gr5Yq55p6c44GM6KGo56S644GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjaGV2cm9uXG4gKiAgIFtlbl1EaXNwbGF5IGEgY2hldnJvbiBhdCB0aGUgcmlnaHQgZW5kIG9mIHRoZSBsaXN0IGl0ZW0gYW5kIG1ha2UgaXQgY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiB0YXBwZWQuIFRoZSBjaGV2cm9uIGlzIG5vdCBkaXNwbGF5ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGxvbmdkaXZpZGVyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9kaXZpZGVyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIHRoZSBsaXN0LiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnQuXG4gKlxuICogICAgIFRoZSBsaXN0IGl0ZW0gaXMgY29tcG9zZWQgb2YgdGhyZWUgcGFydHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgYGxlZnRgLCBgY2VudGVyYCBhbmQgYHJpZ2h0YCBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBsaXN0IGl0ZW1zIGlzIHByb3Blcmx5IGFsaWduZWQuXG4gKlxuICogICAgIGBgYFxuICogICAgIDxvbnMtbGlzdC1pdGVtPlxuICogICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5MZWZ0PC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+Q2VudGVyPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5SaWdodDwvZGl2PlxuICogICAgIDwvb25zLWxpc3QtaXRlbT5cbiAqICAgICBgYGBcbiAqXG4gKiAgICAgVGhlcmUgaXMgYWxzbyBhIG51bWJlciBvZiBjbGFzc2VzIChwcmVmaXhlZCB3aXRoIGBsaXN0X19pdGVtX18qYCkgdGhhdCBoZWxwIHdoZW4gcHV0dGluZyB0aGluZ3MgbGlrZSBpY29ucyBhbmQgdGh1bWJuYWlscyBpbnRvIHRoZSBsaXN0IGl0ZW1zLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgbGlzdHNcbiAqICAgW2VuXVVzaW5nIGxpc3RzWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3QtaXRlbT5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cIm1kLWZhY2VcIiBjbGFzcz1cImxpc3RfX2l0ZW1fX2ljb25cIj48L29ucy1pY29uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0X19pdGVtX190aXRsZVwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3RfX2l0ZW1fX3N1YnRpdGxlXCI+U3VidGl0bGU8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtc3dpdGNoPjwvb25zLXN3aXRjaD5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1saXN0LWl0ZW0+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3lkITopoHntKDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsb2NrLW9uLWRyYWdcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgaG9yaXpvbnRhbGx5LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODpuODvOOCtuODvOOBjOOBk+OBruimgee0oOOCkuaoquaWueWQkeOBq+ODieODqeODg+OCsOOBl+OBpuOBhOOCi+aZguOBq+OAgee4puaWueWQkeOBruOCueOCr+ODreODvOODq+OBjOi1t+OBjeOBquOBhOOCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcHBhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgcmVhY3QgdG8gdGFwcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YXAtYmFja2dyb3VuZC1jb2xvclxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl0gQ2hhbmdlcyB0aGUgYmFja2dyb3VuZCBjb2xvciB3aGVuIHRhcHBlZC4gRm9yIHRoaXMgdG8gd29yaywgdGhlIGF0dHJpYnV0ZSBcInRhcHBhYmxlXCIgbmVlZHMgdG8gYmUgc2V0LiBUaGUgZGVmYXVsdCBjb2xvciBpcyBcIiNkOWQ5ZDlcIi4gSXQgd2lsbCBkaXNwbGF5IGFzIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbScpO1xuXG4gICAgbGV0IGxlZnQsIGNlbnRlciwgcmlnaHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnbGVmdCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW1fX2xlZnQnKTtcbiAgICAgICAgbGVmdCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICBjZW50ZXIgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19yaWdodCcpO1xuICAgICAgICByaWdodCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2VudGVyKSB7XG4gICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKCFsZWZ0ICYmICFyaWdodCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBpZiAoZWwgIT09IGxlZnQgJiYgZWwgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgICBjZW50ZXIuaW5zZXJ0QmVmb3JlKGVsLCBjZW50ZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNlbnRlciwgcmlnaHQgfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ2NlbnRlcicpO1xuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19jZW50ZXInKTtcblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuXG4gICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgfVxuXG4gIGdldCBfdHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gJ2JhY2tncm91bmQtY29sb3IgMC4wcyBsaW5lYXIgMC4wMnMsIGJveC1zaGFkb3cgMC4wcyBsaW5lYXIgMC4wMnMnO1xuICB9XG5cbiAgZ2V0IF90YXBwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gIH1cblxuICBnZXQgX3RhcEJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhcC1iYWNrZ3JvdW5kLWNvbG9yJykgfHwgJyNkOWQ5ZDknO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBnZXN0dXJlID0gZXZlbnQuZ2VzdHVyZTtcbiAgICAvLyBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyBpZiB0aGUgdXNlcnMgcGFucyBsZWZ0IG9yIHJpZ2h0LlxuICAgIGlmICh0aGlzLl9zaG91bGRMb2NrT25EcmFnKCkgJiYgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihnZXN0dXJlLmRpcmVjdGlvbikgPiAtMSkge1xuICAgICAgZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoKCkge1xuICAgIGlmICh0aGlzLnRhcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFwcGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcbiAgICB0aGlzLnN0eWxlLk1velRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuXG4gICAgaWYgKHRoaXMuX3RhcHBhYmxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl90YXBCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB0aGlzLnN0eWxlLmJveFNoYWRvdyA9IGAwcHggLTFweCAwcHggMHB4ICR7dGhpcy5fdGFwQmFja2dyb3VuZENvbG9yfWA7XG4gICAgfVxuICB9XG5cbiAgX29uUmVsZWFzZSgpIHtcbiAgICB0aGlzLnRhcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gJyc7XG5cbiAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgIHRoaXMuc3R5bGUuYm94U2hhZG93ID0gJyc7XG4gIH1cblxuICBfc2hvdWxkTG9ja09uRHJhZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtaXRlbScsIExpc3RJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciBpbnNldFxuICogICBbZW5dSW5zZXQgbGlzdCB0aGF0IGRvZXNuJ3QgY292ZXIgdGhlIHdob2xlIHdpZHRoIG9mIHRoZSBwYXJlbnQuWy9lbl1cbiAqICAgW2phXeimquimgee0oOOBrueUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCieOBquOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbm9ib3JkZXJcbiAqICAgW2VuXUEgbGlzdCB3aXRoIG5vIGJvcmRlcnMgYXQgdGhlIHRvcCBhbmQgYm90dG9tLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdG8gZGVmaW5lIGEgbGlzdCwgYW5kIHRoZSBjb250YWluZXIgZm9yIG9ucy1saXN0LWl0ZW0ocykuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuihqOePvuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN0LWl0ZW3jga7jgrPjg7Pjg4bjg4rjgajjgZfjgabkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5db25zLWxpc3QtaXRlbSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1sYXp5LXJlcGVhdFxuICogICBbZW5db25zLWxhenktcmVwZWF0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGF6eS1yZXBlYXTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIGxpc3RzXG4gKiAgIFtlbl1Vc2luZyBsaXN0c1svZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIGluZmluaXRlLXNjcm9sbFxuICogICBbZW5dTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvZW5dXG4gKiAgIFtqYV1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0Jyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdCcsIExpc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRleHQtaW5wdXQnOiAndGV4dC1pbnB1dC0tKicsXG4gICcudGV4dC1pbnB1dF9fbGFiZWwnOiAndGV4dC1pbnB1dC0tKl9fbGFiZWwnLFxuICAnLnJhZGlvLWJ1dHRvbic6ICdyYWRpby1idXR0b24tLSonLFxuICAnLnJhZGlvLWJ1dHRvbl9faW5wdXQnOiAncmFkaW8tYnV0dG9uLS0qX19pbnB1dCcsXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnLFxuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2NhcGl0YWxpemUnLFxuICAnYXV0b2NvbXBsZXRlJyxcbiAgJ2F1dG9jb3JyZWN0JyxcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbWF4JyxcbiAgJ21heGxlbmd0aCcsXG4gICdtaW4nLFxuICAnbWlubGVuZ3RoJyxcbiAgJ25hbWUnLFxuICAncGF0dGVybicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndHlwZScsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pbnB1dFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHVuZGVyYmFyXG4gKiAgW2VuXURpc3BsYXlzIGEgaG9yaXpvbnRhbCBsaW5lIHVuZGVybmVhdGggYSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdHJhbnNwYXJlbnRcbiAqICBbZW5dRGlzcGxheXMgYSB0cmFuc3BhcmVudCBpbnB1dC4gV29ya3MgZm9yIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQW4gaW5wdXQgZWxlbWVudC4gVGhlIGB0eXBlYCBhdHRyaWJ1dGUgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBpbnB1dCB0eXBlLiBBbGwgdGV4dCBpbnB1dCB0eXBlcyBhcyB3ZWxsIGFzIGBjaGVja2JveGAgYW5kIGByYWRpb2AgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIG9qUXhMalxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lucHV0XG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgYWRkaW5nLXBhZ2UtY29udGVudFxuICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pbnB1dCBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgZmxvYXQ+PC9vbnMtaW5wdXQ+XG4gKiA8b25zLWlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ+PC9vbnMtaW5wdXQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwbGFjZWhvbGRlclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGxhY2Vob2xkZXIgdGV4dC4gSW4gTWF0ZXJpYWwgRGVzaWduLCB0aGlzIHBsYWNlaG9sZGVyIHdpbGwgYmUgYSBmbG9hdGluZyBsYWJlbC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmbG9hdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBwcmVzZW50LCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBhbmltYXRlZCBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/mmYLjgIHjg6njg5njg6vjga/jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0eXBlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVxuICAgKiAgICBTcGVjaWZ5IHRoZSBpbnB1dCB0eXBlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBcInR5cGVcIiBhdHRyaWJ1dGUgZm9yIG5vcm1hbCBpbnB1dHMuIEhvd2V2ZXIsIGZvciBcInJhbmdlXCIgeW91IHNob3VsZCBpbnN0ZWFkIHVzZSA8b25zLXJhbmdlPiBlbGVtZW50LlxuICAgKlxuICAgKiAgICBQbGVhc2UgdGFrZSBhIGxvb2sgYXQgW01ETl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItdHlwZSkgZm9yIGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMuIERlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0gYW5kIGJyb3dzZXIgdmVyc2lvbiBzb21lIG9mIHRoZXNlIG1pZ2h0IG5vdCB3b3JrLlxuICAgKiAgWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyA8bGFiZWwgZm9yPVwiLi4uXCI+IGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29udGVudC1sZWZ0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBIVE1MIGNvbnRlbnQgb2YgYDxvbnMtaW5wdXQ+YCBpcyBwbGFjZWQgYmVmb3JlIHRoZSBhY3R1YWwgaW5wdXQgYXMgYSBsYWJlbC4gT21pdCB0aGlzIHRvIGRpc3BsYXkgaXQgYWZ0ZXIgdGhlIGlucHV0LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2NoZWNrZWQnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRm9jdXNpbiA9IHRoaXMuX29uRm9jdXNpbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCA9IHRoaXMuX2RlbGVnYXRlRXZlbnQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGVscGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGhlbHBlci5jbGFzc0xpc3QuYWRkKCdfaGVscGVyJyk7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVscGVyKTtcblxuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2lucHV0LWxhYmVsJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBsYWJlbC5hcHBlbmRDaGlsZChlbGVtZW50KSk7XG4gICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQtbGVmdCcpID8gY29udGFpbmVyLmluc2VydEJlZm9yZShsYWJlbCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94X19pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3hfX2NoZWNrbWFyaycpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdyYWRpby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uX19pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uX19jaGVja21hcmsnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0Jyk7XG4gICAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19sYWJlbCcpO1xuICAgICAgICB0aGlzLl9pbnB1dC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXRfX2NvbnRhaW5lcicpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbENsYXNzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5wdXQtaWQnKSkge1xuICAgICAgdGhpcy5faW5wdXQuaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaW5wdXQtaWQnKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdwbGFjZWhvbGRlcicsICdpbnB1dC1pZCcsICdjaGVja2VkJywgLi4uSU5QVVRfQVRUUklCVVRFU107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gY29udGVudFJlYWR5KHRoaXMsICgpID0+IE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwbGFjZWhvbGRlcicpIHtcbiAgICAgIHJldHVybiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlTGFiZWwoKSk7XG4gICAgfSBpZiAobmFtZSA9PT0gJ2lucHV0LWlkJykge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2lucHV0LmlkID0gY3VycmVudCk7XG4gICAgfSBpZiAobmFtZSA9PT0gJ2NoZWNrZWQnKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgcmV0dXJuIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dC50eXBlICE9PSAnY2hlY2tib3gnICYmIHRoaXMuX2lucHV0LnR5cGUgIT09ICdyYWRpbycpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX2JvdW5kT25Gb2N1c291dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXRMYWJlbCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faGVscGVyLnRleHRDb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faGVscGVyLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5faGVscGVyLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVMYWJlbCgpIHtcbiAgICB0aGlzLl9zZXRMYWJlbCh0aGlzLmhhc0F0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIDogJycpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVMYWJlbENsYXNzKCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtaW5wdXQtLW1hdGVyaWFsX19sYWJlbC0tYWN0aXZlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykpID09PSAtMSl7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gIH1cblxuICBfZGVsZWdhdGVFdmVudChldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQudHlwZSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgX29uSW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVMYWJlbENsYXNzKCk7XG4gIH1cblxuICBfb25Gb2N1c2luKGV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9oZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLl9oZWxwZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dCA9PT0gbnVsbFxuICAgICAgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgOiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB2YWw7XG4gICAgICB0aGlzLl9vbklucHV0KCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBjaGVja2VkIG9yIG5vdC4gT25seSB3b3JrcyBmb3IgYHJhZGlvYCBhbmQgYGNoZWNrYm94YCB0eXBlIGlucHV0cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LmNoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgZ2V0IF9pc1RleHRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlICE9PSAncmFkaW8nICYmIHRoaXMudHlwZSAhPT0gJ2NoZWNrYm94JztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlucHV0JywgSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwLjI7XG5cbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8IHRoaXMudGltaW5nO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogdGhpcy5kdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6IHRoaXMuZGVsYXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlTW9kYWxBbmltYXRvciBleHRlbmRzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8ICcwLjMnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlTW9kYWxBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdtb2RhbC0tKicsXG4gICdtb2RhbF9fY29udGVudCc6ICdtb2RhbC0tKl9fY29udGVudCdcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogTW9kYWxBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcbiAgJ25vbmUnOiBNb2RhbEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1tb2RhbFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBNb2RhbCBjb21wb25lbnQgdGhhdCBtYXNrcyBjdXJyZW50IHNjcmVlbi4gVW5kZXJseWluZyBjb21wb25lbnRzIGFyZSBub3Qgc3ViamVjdCB0byBhbnkgZXZlbnRzIHdoaWxlIHRoZSBtb2RhbCBjb21wb25lbnQgaXMgc2hvd24uXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGJsb2NrIHVzZXIgaW5wdXQgd2hpbGUgc29tZSBvcGVyYXRpb24gaXMgcnVubmluZyBvciB0byBzaG93IHNvbWUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcbiAqICAgICDjg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgabjgYTjgovplpPjga/jgqTjg5njg7Pjg4jpgJrnn6XjgYzooYzjgo/jgozjgb7jgZvjgpPjgIJcbiAqICAgWy9qYV1cbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImZhZGVcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE1vZGFsQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTW9kYWxBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBoYW5kbGVyKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbW9kYWwnKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5tb2RhbF9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgY29uc3QgdHJ5U2hvdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcbiAgICAgICAgICBhbmltYXRvci5zaG93KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5U2hvdygpKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIG1vZGFsIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44Gu6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIG1vZGFsLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc01vZGFsRWxlbWVudC5Nb2RhbEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTW9kYWxBbmltYXRvcigpIHtcbiAgICByZXR1cm4gTW9kYWxBbmltYXRvcjtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1tb2RhbCcsIE1vZGFsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgZHVyYXRpb246ICcwLjQnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy50aW1pbmcgPSBvcHRpb25zLnRpbWluZztcbiAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgc3RhdGljIGV4dGVuZChwcm9wZXJ0aWVzID0ge30pIHtcblxuICAgIGNvbnN0IGV4dGVuZGVkQW5pbWF0b3IgPSB0aGlzO1xuICAgIGNvbnN0IG5ld0FuaW1hdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBleHRlbmRlZEFuaW1hdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgbmV3QW5pbWF0b3IucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gbmV3QW5pbWF0b3I7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBuYXZpZ2F0b3IgdHJhbnNpdGlvbiBsaWtlIGlPUydzIHNjcmVlbiBzbGlkZSB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgdGltaW5nOiAnZWFzZScsXG4gICAgICBkZWxheTogMFxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwOyB6LWluZGV4OiAyXCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFyID0gcGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gdG9vbGJhci5fZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKTtcbiAgICBjb25zdCByaWdodCA9IHRvb2xiYXIuX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpO1xuXG4gICAgY29uc3QgZXhjbHVkZUJhY2tCdXR0b24gPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b24obGVmdC5jaGlsZHJlbikpXG4gICAgICAuY29uY2F0KHJpZ2h0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IHJpZ2h0IDogZXhjbHVkZUJhY2tCdXR0b24ocmlnaHQuY2hpbGRyZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b29sYmFyQ2VudGVyOiB0b29sYmFyLl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uSWNvbjogdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpLFxuICAgICAgYmFja0J1dHRvbkxhYmVsOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpLFxuICAgICAgb3RoZXI6IG90aGVyLFxuICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcbiAgICAgIGJhY2tncm91bmQ6IHBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCksXG4gICAgICB0b29sYmFyOiB0b29sYmFyLFxuICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxuICAgIH07XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICBjb25zdCBib3RoUGFnZUhhc1Rvb2xiYXIgPVxuICAgICAgZW50ZXJQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpICYmIGxlYXZlUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKTtcblxuICAgIHZhciBub01hdGVyaWFsVG9vbGJhciA9XG4gICAgICAhZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbmF2aWdhdGlvbi1iYXItLW1hdGVyaWFsJykgJiZcbiAgICAgICFsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXZpZ2F0aW9uLWJhci0tbWF0ZXJpYWwnKTtcblxuICAgIHJldHVybiBib3RoUGFnZUhhc1Rvb2xiYXIgJiYgbm9NYXRlcmlhbFRvb2xiYXI7XG4gIH1cblxuICBfY2FsY3VsYXRlRGVsdGEoZWxlbWVudCwgZGVjb21wb3NpdGlvbikge1xuICAgIGxldCB0aXRsZSwgbGFiZWw7XG5cbiAgICBjb25zdCBwYWdlUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsUmVjdCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGl0bGUgPSBNYXRoLnJvdW5kKChwYWdlUmVjdC53aWR0aCAvIDIpIC0gKGxhYmVsUmVjdC53aWR0aCAvIDIpIC0gbGFiZWxSZWN0LmxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9IE1hdGgucm91bmQoKHBhZ2VSZWN0LndpZHRoIC8gMikgKiAwLjYpO1xuICAgIH1cblxuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgbGFiZWwgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4ge3RpdGxlLCBsYWJlbH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnRlbnRSZWFkeShlbnRlclBhZ2UsICgpID0+IHtcbiAgICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlKTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlKTtcblxuICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGVudGVyUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjA1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoKGRvbmUpID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuXG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgZml4XG4gICAgICAgIGNvbnN0IGVudGVyUGFnZVRvb2xiYXJIZWlnaHQgPSBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5zdHlsZS50b3AgPSBlbnRlclBhZ2VUb29sYmFySGVpZ2h0O1xuXG4gICAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgICBtYXNrQ2xlYXIsXG5cbiAgICAgICAgICBhbmltaXQoW2VudGVyUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBlbnRlclBhZ2VUb29sYmFySGVpZ2h0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEyNSUsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBkZWx0YS50aXRsZSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyQ2VudGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLmxhYmVsICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuXG4gICAgICAgICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2UpO1xuICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwLjEsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAucXVldWUoKGRvbmUpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcblxuICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xuICAgICAgY29uc3QgZW50ZXJQYWdlVG9vbGJhckhlaWdodCA9IGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyAncHgnO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5zdHlsZS50b3AgPSBlbnRlclBhZ2VUb29sYmFySGVpZ2h0O1xuXG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoW2VudGVyUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLnRpdGxlICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YS5sYWJlbCArICdweCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdG9wOiBlbnRlclBhZ2VUb29sYmFySGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCgwKVxuICAgICAgICAgIC5xdWV1ZShmdW5jdGlvbihmaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEyNSUsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIGRlbHRhLnRpdGxlICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBtYXNrQ2xlYXIsXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5cbi8qKlxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcbiAgICAgIGRlbGF5OiAwXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGJsYWNrLCB3aGl0ZSk7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIG1hc2tDbGVhcixcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC0xMCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcblxuLyoqXG4gKiBGYWRlLWluIHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbZW50ZXJQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBlbnRlclBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoW2xlYXZlUGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgbGVhdmVQYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpXSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLFxuICAgICAgZGVsYXk6IDBcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyB6LWluZGV4OiAyO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgb3BhY2l0eTogMDtcIj48L2Rpdj5cbiAgICBgKTtcbiAgICB0aGlzLmJsYWNrTWFza09wYWNpdHkgPSAwLjQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eSxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCgwLjIpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihmaW5pc2gpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsXG4gICAgICBkZWxheTogMC4wNVxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1wiPjwvZGl2PlxuICAgIGApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UpO1xuXG4gICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBtYXNrQ2xlYXIsXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuXG4vKipcbiAqIEZhZGUtaW4gKyBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgdGltaW5nOiAnZWFzZS1vdXQnLFxuICAgICAgZHVyYXRpb246ICcwLjI1JyxcbiAgICAgIGRlbGF5OiAnMCdcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCA0MnB4LCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCgwLjE1KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMzhweCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4wNClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1zbGlkZS1hbmltYXRvcic7XG5pbXBvcnQgSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLWZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1zbGlkZS1hbmltYXRvcic7XG5pbXBvcnQgTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL25vbmUtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlciwgaW5zdGFudFBhZ2VMb2FkZXJ9IGZyb20gJy4uLy4uL29ucy9wYWdlLWxvYWRlcic7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ3NsaWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdsaWZ0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ3NsaWRlLWlvcyc6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnc2xpZGUtbWQnOiBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbGlmdC1pb3MnOiBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbGlmdC1tZCc6IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2ZhZGUtbWQnOiBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdub25lJzogTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5hdmlnYXRvclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShuYXZpZ2F0b3JFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLW5hdmlnYXRvclxuICogQGNhdGVnb3J5IG5hdmlnYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQSBjb21wb25lbnQgdGhhdCBwcm92aWRlcyBwYWdlIHN0YWNrIG1hbmFnZW1lbnQgYW5kIG5hdmlnYXRpb24uIFN0YWNrIG5hdmlnYXRpb24gaXMgdGhlIG1vc3QgY29tbW9uIG5hdmlnYXRpb24gcGF0dGVybiBmb3IgbW9iaWxlIGFwcHMuXG4gKlxuICogICAgIFdoZW4gYSBwYWdlIGlzIHB1c2hlZCBvbiB0b3Agb2YgdGhlIHN0YWNrIGl0IGlzIGRpc3BsYXllZCB3aXRoIGEgdHJhbnNpdGlvbiBhbmltYXRpb24uIFdoZW4gdGhlIHVzZXIgcmV0dXJucyB0byB0aGUgcHJldmlvdXMgcGFnZSB0aGUgdG9wIHBhZ2Ugd2lsbCBiZSBwb3BwZWQgZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFjayBhbmQgaGlkZGVuIHdpdGggYW4gb3Bwb3NpdGUgdHJhbnNpdGlvbiBhbmltYXRpb24uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geXJodHZcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICAgW2VuXUd1aWRlIGZvciBwYWdlIG5hdmlnYXRpb25bL2VuXVxuICogICBbamFd44Oa44O844K444OK44OT44Ky44O844K344On44Oz44Gu5qaC6KaBWy9qYV1cbiAqIEBndWlkZSB0ZW1wbGF0ZXNcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBndWlkZSBjcmVhdGluZy1hLXBhZ2VcbiAqICAgW2VuXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2VuXVxuICogICBbamFdU2V0dGluZyB1cCBhIHBhZ2UgaW4gaXRzIGBpbml0YCBldmVudFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdG9vbGJhciBvbiB0aGUgdG9wIG9mIGEgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGxldHMgdGhlIHVzZXIgcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbmF2aWdhdG9yIGlkPVwibmF2aWdhdG9yXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIFRpdGxlXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L29ucy10b29sYmFyPlxuICogICAgIDxwPlxuICogICAgICAgPG9ucy1idXR0b25cbiAqICAgICAgICAgb25jbGljaz1cImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYXZpZ2F0b3InKS5wdXNoUGFnZSgncGFnZS5odG1sJylcIj5cbiAqICAgICAgICAgUHVzaCBwYWdlXG4gKiAgICAgICA8L29ucy1idXR0b24+XG4gKiAgICAgPC9wPlxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtbmF2aWdhdG9yPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJwYWdlLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIEFub3RoZXIgcGFnZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJzdCBwYWdlIHRvIHNob3cgd2hlbiBuYXZpZ2F0b3IgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAgICogICBbamFd44OK44OT44Ky44O844K/44O844GM5Yid5pyf5YyW44GV44KM44Gf5pmC44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0uXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZXB1c2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmN1cnJlbnRQYWdlXG4gICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd54++5Zyo44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwdXNoLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXB1c2jlh6bnkIbjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZXBvcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcG9wLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXBhZ2Xjga5wb3DjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLkuobjgZfjgabjgYvjgonnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmVudGVyUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wdXNo44GV44KM44GfcGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3Rwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC44KP44Gj44Gf5b6M44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcG9w44GV44KM44Gm6KGo56S644GV44KM44KL44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxlYXZlUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cbiAgICogICBbamFdcG9w44GV44KM44Gm5raI44GI44KL44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IGFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0b3JGYWN0b3J5O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAdHlwZSB7UGFnZUxvYWRlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVBhZ2VMb2FkZXLjgqTjg7Pjgrnjgr/jg7PjgrnjgpLmoLzntI3jgZfjgabjgYTjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihwYWdlTG9hZGVyKSB7XG4gICAgaWYgKCEocGFnZUxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFd5Yid5pyf5YyW5pmC44Gr6Kqt44G/6L6844KA44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCYHBhZ2Vg5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCk44KI44KK44KCYHBhZ2Vg44OX44Ot44OR44OG44Kj44Gr5oyH5a6a44GX44Gf5YCk44KS5YSq5YWI44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcblxuXG4gICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAwICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnB1c2hQYWdlKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSwge2FuaW1hdGlvbjogJ25vbmUnfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlc1tpXS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2hpbGRyZW4gb2YgPG9ucy1uYXZpZ2F0b3I+IG5lZWQgdG8gYmUgb2YgdHlwZSA8b25zLXBhZ2U+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLnRvcFBhZ2UsICgpID0+XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy50b3BQYWdlLl9zaG93KCk7XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5fZ2V0UGFnZVRhcmdldCgpLCB7YW5pbWF0aW9uOiAnbm9uZSd9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ05hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwb3BQYWdlXG4gICAqIEBzaWduYXR1cmUgcG9wUGFnZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWZyZXNoXVxuICAgKiAgIFtlbl1UaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgcG9wUGFnZSBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mmI7jgonjgYvjgavjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBvcHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBwYWdlIHN0YWNrLiBUaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcG9wUGFnZShvcHRpb25zID0ge30pIHtcbiAgICAoe29wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKG51bGwsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHBvcFVwZGF0ZSA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDI7XG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuXG4gICAgaWYgKCFvbGRQYWdlLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCBwYWdlcyBkaXJlY3RseSBpbnNpZGUgdGhlIE5hdmlnYXRvci4gVXNlIG9ucy10ZW1wbGF0ZSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7cGFnZTogb2xkUGFnZS5uYW1lLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb2xkUGFnZS5wdXNoZWRPcHRpb25zLmRhdGF9O1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKG9wdGlvbnMsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIG5hbWU6IG9sZFBhZ2UubmFtZSxcbiAgICAgICAgICBkYXRhOiBvbGRQYWdlLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb2xkUGFnZS5wdXNoZWRPcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhZ2VFbGVtZW50LCBvbGRQYWdlID8gb2xkUGFnZSA6IG51bGwpO1xuICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRQYWdlKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG5cbiAgICB9KS50aGVuKCgpID0+IHRoaXMuX3BvcFBhZ2Uob3B0aW9ucywgcG9wVXBkYXRlKSk7XG4gIH1cblxuICBfcG9wUGFnZShvcHRpb25zLCB1cGRhdGUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncG9wUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnb25zLW5hdmlnYXRvclxcJ3MgcGFnZSBzdGFjayBpcyBlbXB0eS4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW1pdFByZVBvcEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcG9wIGV2ZW50LicpO1xuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMucGFnZXNbbGVuZ3RoIC0gMl0udXBkYXRlQmFja0J1dHRvbigobGVuZ3RoIC0gMikgPiAwKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHZhciBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdO1xuICAgICAgdmFyIGVudGVyUGFnZSA9IHRoaXMucGFnZXNbbGVuZ3RoIC0gMl07XG4gICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gfHwgbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb25PcHRpb25zLFxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICk7XG5cbiAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgZW50ZXJQYWdlLmRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLmRhdGEgfHwge30sIG9wdGlvbnMuZGF0YSB8fCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB1cGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGVudGVyUGFnZS5fc2hvdygpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHBvcCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgICAgIGFuaW1hdG9yLnBvcCh0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLCB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdLCBjYWxsYmFjayk7XG4gICAgfSkuY2F0Y2goKCkgPT4gdGhpcy5faXNSdW5uaW5nID0gZmFsc2UpO1xuICB9XG5cblxuICAvKipcbiAgICogQG1ldGhvZCBwdXNoUGFnZVxuICAgKiBAc2lnbmF0dXJlIHB1c2hQYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYSBIVE1MIGRvY3VtZW50IG9yIGEgdGVtcGxhdGUgZGVmaW5lZCB3aXRoIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBPbmx5IG5lY2Vzc2FyeSBpZiBgcGFnZWAgcGFyYW1ldGVyIGlzIG51bGwgb3IgdW5kZWZpbmVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cbiAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBwdXNoZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ov73liqDjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVB1c2hlcyB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2suWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuaWsOOBl+OBhOODmuODvOOCuOOCueOCv+ODg+OCr+OBq+i/veWKoOOBl+OBvuOBmeOAguaWsOOBl+OBhOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwdXNoUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHByZXBhcmUgPSBwYWdlRWxlbWVudCA9PiB7XG4gICAgICB0aGlzLl92ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICBwYWdlRWxlbWVudCA9IHV0aWwuZXh0ZW5kKHBhZ2VFbGVtZW50LCB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMucGFnZSxcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhXG4gICAgICB9KTtcbiAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGluc3RhbnRQYWdlTG9hZGVyLmxvYWQoe3BhZ2U6IG9wdGlvbnMucGFnZUhUTUwsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgICAgcHJlcGFyZShwYWdlRWxlbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICBfcHVzaFBhZ2Uob3B0aW9ucyA9IHt9LCB1cGRhdGUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpO1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCB7YW5pbWF0aW9uT3B0aW9uc30sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBlbnRlclBhZ2UgID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMl07XG5cbiAgICAgIGlmIChlbnRlclBhZ2Uubm9kZU5hbWUgIT09ICdPTlMtUEFHRScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGVsZW1lbnRzIG9mIHR5cGUgPG9ucy1wYWdlPiBjYW4gYmUgcHVzaGVkIHRvIHRoZSBuYXZpZ2F0b3InKTtcbiAgICAgIH1cblxuICAgICAgZW50ZXJQYWdlLnVwZGF0ZUJhY2tCdXR0b24ocGFnZUxlbmd0aCAtIDEpO1xuXG4gICAgICBlbnRlclBhZ2UucHVzaGVkT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UucHVzaGVkT3B0aW9ucyB8fCB7fSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIGVudGVyUGFnZS5uYW1lID0gZW50ZXJQYWdlLm5hbWUgfHwgb3B0aW9ucy5wYWdlO1xuICAgICAgZW50ZXJQYWdlLnVubG9hZCA9IGVudGVyUGFnZS51bmxvYWQgfHwgb3B0aW9ucy51bmxvYWQ7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICAgIGxlYXZlUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBlbnRlclBhZ2UuX3Nob3coKSk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cHVzaCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBpZiAobGVhdmVQYWdlKSB7XG4gICAgICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICAgICAgYW5pbWF0b3IucHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZXBsYWNlUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlcGxhY2VQYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXBsYWNlcyB0aGUgY3VycmVudCB0b3AgcGFnZSB3aXRoIHRoZSBzcGVjaWZpZWQgb25lLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuS4reOBruODmuODvOOCuOOCkuOCkuaMh+WumuOBl+OBn+ODmuODvOOCuOOBq+e9ruOBjeaPm+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXBsYWNlUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShwYWdlLCBvcHRpb25zKVxuICAgICAgLnRoZW4ocmVzb2x2ZWRWYWx1ZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzb2x2ZWRWYWx1ZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGluc2VydFBhZ2VcbiAgICogQHNpZ25hdHVyZSBpbnNlcnRQYWdlKGluZGV4LCBwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggd2hlcmUgaXQgc2hvdWxkIGJlIGluc2VydGVkLlsvZW5dXG4gICAqICAgW2phXeOCueOCv+ODg+OCr+OBq+aMv+WFpeOBmeOCi+S9jee9ruOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGluc2VydGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JbnNlcnQgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrIHdpdGggYXQgYSBwb3NpdGlvbiBkZWZpbmVkIGJ5IHRoZSBgaW5kZXhgIGFyZ3VtZW50LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga5pbmRleOOBp+aMh+WumuOBl+OBn+S9jee9ruOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBpbnNlcnRQYWdlKGluZGV4LCBwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcbiAgICBpbmRleCA9IHRoaXMuX25vcm1hbGl6ZUluZGV4KGluZGV4KTtcblxuICAgIGlmIChpbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcGFnZSA9IHR5cGVvZiBvcHRpb25zLnBhZ2VIVE1MID09PSAnc3RyaW5nJyA/IG9wdGlvbnMucGFnZUhUTUwgOiBwYWdlO1xuICAgIGNvbnN0IGxvYWRlciA9IHR5cGVvZiBvcHRpb25zLnBhZ2VIVE1MID09PSAnc3RyaW5nJyA/IGluc3RhbnRQYWdlTG9hZGVyIDogdGhpcy5fcGFnZUxvYWRlcjtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeVBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIG5hbWU6IG9wdGlvbnMucGFnZSxcbiAgICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICBwYWdlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShwYWdlRWxlbWVudCwgdGhpcy5wYWdlc1tpbmRleF0pO1xuICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbih0cnVlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwYWdlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAqIEBzaWduYXR1cmUgcmVzZXRUb1BhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbGVhcnMgcGFnZSBzdGFjayBhbmQgYWRkcyB0aGUgc3BlY2lmaWVkIHBhZ2UgdG8gdGhlIHN0YWNrLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOCueOCv+ODg+OCr+OCkuODquOCu+ODg+ODiOOBl+OAgeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXNldFRvUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZ2VzWzBdLnVwZGF0ZUJhY2tCdXR0b24oZmFsc2UpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLnBhZ2UgJiYgIW9wdGlvbnMucGFnZUhUTUwgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnJpbmdQYWdlVG9wXG4gICAqIEBzaWduYXR1cmUgYnJpbmdQYWdlVG9wKGl0ZW0sIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtXG4gICAqICAgW2VuXVBhZ2UgVVJMIG9yIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UgaW4gbmF2aWdhdG9yJ3Mgc3RhY2suWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GuVVJM44GL44KC44GX44GP44Gvb25zLW5hdmlnYXRvcuOBruODmuODvOOCuOOCueOCv+ODg+OCr+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg4jjg4Pjg5fjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJyaW5ncyB0aGUgZ2l2ZW4gcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHN0YWNrIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9yIHB1c2hlcyBpdCBpbnRvIHRoZSBzdGFjayBpZiBkb2Vzbid0LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBruS4gOeVquS4iuOBq+enu+WLleOBl+OBvuOBmeOAguOCguOBl+aMh+WumuOBl+OBn+ODmuODvOOCuOOBjOeEoeOBi+OBo+OBn+WgtOWQiOaWsOOBl+OBj3B1c2jjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgYnJpbmdQYWdlVG9wKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChbJ251bWJlcicsICdzdHJpbmcnXS5pbmRleE9mKHR5cGVvZiBpdGVtKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBhZ2UgbmFtZSBvciB0aGUgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZS4gWW91IHN1cHBsaWVkICcgKyBpdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgPyB0aGlzLl9ub3JtYWxpemVJbmRleChpdGVtKSA6IHRoaXMuX2xhc3RJbmRleE9mUGFnZShpdGVtKTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcbiAgICB9XG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGl0ZW0gJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHV0aWwuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgIHBhZ2U6IHBhZ2UubmFtZVxuICAgIH0pO1xuICAgIHBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBwYWdlLnNldEF0dHJpYnV0ZSgnX3NraXBpbml0JywgJycpO1xuICAgIHBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwYWdlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucyk7XG4gIH1cblxuICBfcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICgocGFnZSA9PT0gbnVsbCB8fCBwYWdlID09PSB1bmRlZmluZWQpICYmIG9wdGlvbnMucGFnZSkge1xuICAgICAgcGFnZSA9IG9wdGlvbnMucGFnZTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucywge3BhZ2V9KTtcblxuICAgIHJldHVybiB7cGFnZSwgb3B0aW9uc307XG4gIH1cblxuICBfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VzW2luZGV4XS51cGRhdGVCYWNrQnV0dG9uKGluZGV4ID4gMCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IE1hdGguYWJzKHRoaXMucGFnZXMubGVuZ3RoICsgaW5kZXgpICUgdGhpcy5wYWdlcy5sZW5ndGg7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wb3BQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2xhc3RJbmRleE9mUGFnZShwYWdlTmFtZSkge1xuICAgIGxldCBpbmRleDtcbiAgICBmb3IgKGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBpZiAodGhpcy5wYWdlc1tpbmRleF0ubmFtZSA9PT0gcGFnZU5hbWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIF9lbWl0UHJlRXZlbnQobmFtZSwgZGF0YSA9IHt9KSB7XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlJyArIG5hbWUsIHV0aWwuZXh0ZW5kKHtcbiAgICAgIG5hdmlnYXRvcjogdGhpcyxcbiAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0sXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSwgZGF0YSkpO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfZW1pdFByZVB1c2hFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwdXNoJyk7XG4gIH1cblxuICBfZW1pdFByZVBvcEV2ZW50KCkge1xuICAgIGNvbnN0IGwgPSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwb3AnLCB7XG4gICAgICBsZWF2ZVBhZ2U6IHRoaXMucGFnZXNbbCAtIDFdLFxuICAgICAgZW50ZXJQYWdlOiB0aGlzLnBhZ2VzW2wgLSAyXVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzog5pu444GN55u044GZXG4gIF9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpIHtcbiAgICBjb25zdCBwYWdlRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTCh0ZW1wbGF0ZUhUTUwpKTtcbiAgICB0aGlzLl92ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgcmV0dXJuIHBhZ2VFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgX3ZlcmlmeVBhZ2VFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25zLXBhZ2UnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBcIm9ucy1wYWdlXCIgZWxlbWVudCB0byBcIm9ucy1uYXZpZ2F0b3JcIi4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdG9wUGFnZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCB0b3AgcGFnZSBlbGVtZW50LiBVc2UgdGhpcyBtZXRob2QgdG8gYWNjZXNzIG9wdGlvbnMgcGFzc2VkIGJ5IGBwdXNoUGFnZSgpYC1saWtlIG1ldGhvZHMuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oa44O844K444KS5Y+W5b6X44GX44G+44GZ44CCcHVzaFBhZ2UoKeOChHJlc2V0VG9QYWdlKCnjg6Hjgr3jg4Pjg4njga7lvJXmlbDjgpLlj5blvpfjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlc1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29weSBvZiB0aGUgbmF2aWdhdG9yJ3MgcGFnZSBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsXG4gICAgICAuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKG4gPT4gbi50YWdOYW1lID09PSAnT05TLVBBR0UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGVmYXVsdCBvcHRpb25zIG9iamVjdC4gQXR0cmlidXRlcyBoYXZlIHByaW9yaXR5IG92ZXIgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMucmVmcmVzaFxuICAgKiBAZGVmYXVsdCAgZmFsc2VcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIHRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBgcG9wUGFnZSgpYCBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIHNldCBfaXNSdW5uaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJywgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgfVxuICBnZXQgX2lzUnVubmluZygpIHtcbiAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycpKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgIHRoaXMudG9wUGFnZS5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBOYXZpZ2F0b3JFbGVtZW50Lk5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicpO1xuICAgIH1cblxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW5hdmlnYXRvcicsIE5hdmlnYXRvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ25hdmlnYXRpb24tYmFyLS0qJyxcbiAgJy5uYXZpZ2F0aW9uLWJhcl9fbGVmdCc6ICduYXZpZ2F0aW9uLWJhci0tKl9fbGVmdCcsXG4gICcubmF2aWdhdGlvbi1iYXJfX2NlbnRlcic6ICduYXZpZ2F0aW9uLWJhci0tKl9fY2VudGVyJyxcbiAgJy5uYXZpZ2F0aW9uLWJhcl9fcmlnaHQnOiAnbmF2aWdhdGlvbi1iYXItLSpfX3JpZ2h0J1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhclxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdHJhbnNwYXJlbnRcbiAqICAgW2VuXVRyYW5zcGFyZW50IHRvb2xiYXJbL2VuXVxuICogICBbamFd6YCP5piO44Gq6IOM5pmv44KS5oyB44Gk44OE44O844Or44OQ44O844KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBub3NoYWRvd1xuICogICBbZW5dVG9vbGJhciB3aXRob3V0IHNoYWRvd1svZW5dXG4gKiAgIFtqYV3jganjgYbjgZfjgojjgYZbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUb29sYmFyIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggbmF2aWdhdGlvbi5cbiAqXG4gKiAgICAgTGVmdCwgY2VudGVyIGFuZCByaWdodCBjb250YWluZXIgY2FuIGJlIHNwZWNpZmllZCBieSBjbGFzcyBuYW1lcy5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgd2hlbiBydW5uaW5nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODiuODk+OCsuODvOOCt+ODp+ODs+OBp+S9v+eUqOOBmeOCi+ODhOODvOODq+ODkOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOCr+ODqeOCueWQjeOBq+OCiOOCiuOAgeW3puOAgeS4reWkruOAgeWPs+OBruOCs+ODs+ODhuODiuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBhZGRpbmctYS10b29sYmFyIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1bamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1ib3R0b20tdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLWJvdHRvbS10b29sYmFyPmAgZGlzcGxheXMgYSB0b29sYmFyIG9uIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1ib3R0b20tdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGJhY2sgYnV0dG9uIGluc2lkZSB0aGUgdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgdG9vbGJhciBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhci1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICA8b25zLWJhY2stYnV0dG9uPlxuICogICAgICAgICBCYWNrXG4gKiAgICAgICA8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICBUaXRsZVxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICogPC9vbnMtcGFnZT5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmxpbmVcbiAgICogQGluaXRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXNwbGF5IHRoZSB0b29sYmFyIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOCkuOCpOODs+ODqeOCpOODs+OBq+e9ruOBjeOBvuOBmeOAguOCueOCr+ODreODvOODq+mgmOWfn+WGheOBq+OBneOBruOBvuOBvuihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9faWNvbicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCduYXZpZ2F0aW9uLWJhcicpO1xuICAgIHRoaXMuX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxuICAgICAgaWYgKHRoaXMuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnY2VudGVyJyk7XG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ25hdmlnYXRpb24tYmFyX190aXRsZScpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0aGlzLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnbGVmdCcpO1xuICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgncmlnaHQnKTtcblxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0gIT09IGxlZnQgfHwgdGhpcy5jaGlsZHJlblsxXSAhPT0gY2VudGVyIHx8IHRoaXMuY2hpbGRyZW5bMl0gIT09IHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGVmdCk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChyaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJFbGVtZW50KG5hbWUpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5uYXZpZ2F0aW9uLWJhcl9fJyArIG5hbWUpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5uYXZpZ2F0aW9uLWJhcl9fJyArIG5hbWUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuJyArIG5hbWUpIHx8IHV0aWwuY3JlYXRlKCcuJyArIG5hbWUpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXInLCBUb29sYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmltcG9ydCAnLi9vbnMtdG9vbGJhcic7IC8vIGVuc3VyZXMgdGhhdCAnb25zLXRvb2xiYXInIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZFxuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAncGFnZS0tKicsXG4gICcucGFnZV9fY29udGVudCc6ICdwYWdlLS0qX19jb250ZW50JyxcbiAgJy5wYWdlX19iYWNrZ3JvdW5kJzogJ3BhZ2UtLSpfX2JhY2tncm91bmQnXG59O1xuXG5jb25zdCBudWxsVG9vbGJhckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtdG9vbGJhcicpOyAvLyByZXF1aXJlcyB0aGF0ICdvbnMtdG9vbGJhcicgZWxlbWVudCBpcyByZWdpc3RlcmVkXG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXBhZ2VcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIHRoZSByb290IG9mIGVhY2ggcGFnZS4gSWYgdGhlIGNvbnRlbnQgaXMgbGFyZ2UgaXQgd2lsbCBiZWNvbWUgc2Nyb2xsYWJsZS5cbiAqXG4gKiAgICAgQSBuYXZpZ2F0aW9uIGJhciBjYW4gYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSB1c2luZyB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjlrprnvqnjga7jgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7lhoXlrrnjga/jgrnjgq/jg63jg7zjg6vjgYzoqLHlj6/jgZXjgozjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBjcmVhdGluZy1hLXBhZ2VcbiAqICAgW2VuXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2VuXVxuICogICBbamFdU2V0dGluZyB1cCBhIHBhZ2UgaW4gaXRzIGBpbml0YCBldmVudFsvamFdXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVVzZSB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQgdG8gYWRkIGEgbmF2aWdhdGlvbiBiYXIgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8cD5QYWdlIGNvbnRlbnQ8L3A+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICBteUFwcC5oYW5kbGVyID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIGxvYWRNb3JlKCkudGhlbihkb25lKTtcbiAqICAgfVxuICogPC9zY3JpcHQ+XG4gKlxuICogPG9ucy1wYWdlIG9uLWluZmluaXRlLXNjcm9sbD1cIm15QXBwLmhhbmRsZXJcIj5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5MaXN0PC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8b25zLWxpc3Q+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzE8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzI8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzM8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLWxpc3Q+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGluaXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGF0dGFjaGVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOOCouOCv+ODg+ODgeOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgc2hvd24uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6KGo56S644GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBkZXN0cm95XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgaXMgZGVzdHJveWVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOegtOajhOOBleOCjOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IG1vZGlmaWVyIG5hbWUgdG8gc3BlY2lmeSBjdXN0b20gc3R5bGVzLlsvZW5dXG4gICAqICAgW2phXeOCueOCv+OCpOODq+Wumue+qeOCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+OBn+OCgeOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9uLWluZmluaXRlLXNjcm9sbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGF0aCBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gaW5maW5pdGUgc2Nyb2xsaW5nLiBFeGFtcGxlOiBgYXBwLmxvYWREYXRhYC4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGFnZScpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcblxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQgPSB0aGlzLl9nZXRDb250ZW50RWxlbWVudCgpO1xuICAgICAgdGhpcy5faXNNdXRlZCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfbXV0ZWQnKTtcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgICAgdGhpcy5wdXNoZWRPcHRpb25zID0ge307XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9za2lwSW5pdCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdpbml0JykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJ5VG9GaWxsU3RhdHVzQmFyKCk7XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVCYWNrQnV0dG9uKHNob3cpIHtcbiAgICBpZiAodGhpcy5iYWNrQnV0dG9uKSB7XG4gICAgICBzaG93ID8gdGhpcy5iYWNrQnV0dG9uLnNob3coKSA6IHRoaXMuYmFja0J1dHRvbi5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5hbWUoc3RyKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBzdHIpO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gIH1cblxuICBnZXQgYmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24nKTtcbiAgfVxuXG4gIF90cnlUb0ZpbGxTdGF0dXNCYXIoKXtcbiAgICBpbnRlcm5hbC5hdXRvU3RhdHVzQmFyRmlsbCgoKSA9PiB7XG4gICAgICBjb25zdCBmaWxsZWQgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgZSA9PiBlLmhhc0F0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJykpO1xuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsICFmaWxsZWQgJiYgKHRoaXMuX2NhbkFuaW1hdGVUb29sYmFyKCkgfHwgIXRoaXMuX2hhc0FQYWdlQ29udHJvbENoaWxkKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9oYXNBUGFnZUNvbnRyb2xDaGlsZCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fY29udGVudEVsZW1lbnQsIGUgPT4gZS5ub2RlTmFtZS5tYXRjaCgvb25zLShzcGxpdHRlcnxzbGlkaW5nLW1lbnV8bmF2aWdhdG9yfHRhYmJhcikvaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkluZmluaXRlU2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gc2Nyb2xsaW5nIHRvIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnQgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IG9uSW5maW5pdGVTY3JvbGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uSW5maW5pdGVTY3JvbGwgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwnKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vbkluZmluaXRlU2Nyb2xsKSB7XG4gICAgICB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0ID0gMC45O1xuICAgICAgdGhpcy5fYm91bmRPblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCkpO1xuICAgIH1cbiAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgb25JbmZpbml0ZVNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25JbmZpbml0ZVNjcm9sbDtcbiAgfVxuXG4gIF9vblNjcm9sbCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xuXG4gICAgaWYgKHRoaXMuX29uSW5maW5pdGVTY3JvbGwgJiYgIXRoaXMuX2xvYWRpbmdDb250ZW50ICYmIG92ZXJMaW1pdCkge1xuICAgICAgdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCgoKSA9PiB0aGlzLl9sb2FkaW5nQ29udGVudCA9IGZhbHNlKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldENvbnRlbnRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19jb250ZW50XCIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2NhbkFuaW1hdGVUb29sYmFyKCkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMuX2NvbnRlbnRFbGVtZW50LCBlbCA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlbCwgJ29ucy10b29sYmFyJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2JhY2tncm91bmRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykgfHwgbnVsbFRvb2xiYXJFbGVtZW50O1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnX211dGVkJywgJ19za2lwaW5pdCcsICdvbi1pbmZpbml0ZS1zY3JvbGwnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdfbXV0ZWQnKSB7XG4gICAgICB0aGlzLl9pc011dGVkID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19tdXRlZCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ19za2lwaW5pdCcpIHtcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uLWluZmluaXRlLXNjcm9sbCcpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSAoZG9uZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgIGYoZG9uZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5jb250ZW50JykpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRoaXMsICcuY29udGVudCcpLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrZ3JvdW5kJykpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFja2dyb3VuZCcpLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2JhY2tncm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEgfHwgdGhpcy5fZWxlbWVudFNob3VsZEJlTW92ZWQobm9kZSkpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcHJldk5vZGUgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKSB8fCB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY29udGVudCwgcHJldk5vZGUgJiYgcHJldk5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZWxlbWVudFNob3VsZEJlTW92ZWQoZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJ29ucy1mYWInKSB7XG4gICAgICByZXR1cm4gIWVsLmhhc0F0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZml4ZWRFbGVtZW50cyA9IFsnb25zLXRvb2xiYXInLCAnb25zLWJvdHRvbS10b29sYmFyJywgJ29ucy1tb2RhbCcsICdvbnMtc3BlZWQtZGlhbCddO1xuICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUoJ2lubGluZScpIHx8IGZpeGVkRWxlbWVudHMuaW5kZXhPZih0YWdOYW1lKSA9PT0gLTE7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdXRpbC5pc0F0dGFjaGVkKHRoaXMpKSB7XG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnc2hvdycpO1xuICAgICAgfVxuXG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLl9jb250ZW50RWxlbWVudCwgJ19zaG93Jyk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblxuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnaGlkZScpO1xuICAgICAgfVxuXG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLl9jb250ZW50RWxlbWVudCwgJ19oaWRlJyk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5faGlkZSgpO1xuXG4gICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Rlc3Ryb3knKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbkRldmljZUJhY2tCdXR0b24pIHtcbiAgICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLl9jb250ZW50RWxlbWVudCwgJ19kZXN0cm95Jyk7XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlcidzIGN1c3RvbSBkYXRhIHBhc3NlZCB0byBgcHVzaFBhZ2UoKWAtbGlrZSBtZXRob2RzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wYWdlJywgUGFnZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcblxuZXhwb3J0IGNsYXNzIFBvcG92ZXJBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJyxcbiAgICAgIGR1cmF0aW9uOiAwLjIsXG4gICAgICBkZWxheTogMFxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIF9hbmltYXRlKGVsZW1lbnQsIHtmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2ssIHJlc3RvcmUgPSBmYWxzZSwgYW5pbWF0aW9ufSkge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgIGZyb20gPSBhbmltYXRpb24uZnJvbTtcbiAgICAgIHRvID0gYW5pbWF0aW9uLnRvO1xuICAgIH1cblxuICAgIGFuaW1hdGlvbiA9IGFuaW1pdChlbGVtZW50KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnNhdmVTdHlsZSgpO1xuICAgIH1cbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoZnJvbSkud2FpdChvcHRpb25zLmRlbGF5KS5xdWV1ZSh7XG4gICAgICBjc3M6IHRvLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICB0aW1pbmc6IG9wdGlvbnMudGltaW5nXG4gICAgfSk7XG4gICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5yZXN0b3JlU3R5bGUoKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoKGRvbmUpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICBfYW5pbWF0ZUFsbChlbGVtZW50LCBhbmltYXRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMoYW5pbWF0aW9ucykuZm9yRWFjaChrZXkgPT4gdGhpcy5fYW5pbWF0ZShlbGVtZW50W2tleV0sIGFuaW1hdGlvbnNba2V5XSkucGxheSgpKTtcbiAgfVxuXG59XG5cbmNvbnN0IGZhZGUgPSB7XG4gIG91dDoge1xuICAgIGZyb206IHtvcGFjaXR5OiAxLjB9LFxuICAgIHRvOiB7b3BhY2l0eTogMH1cbiAgfSxcbiAgaW46IHtcbiAgICBmcm9tOiB7b3BhY2l0eTogMH0sXG4gICAgdG86IHtvcGFjaXR5OiAxLjB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBNREZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLmluLCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cbiAgICB9KTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLm91dCxcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLm91dCwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBNREZhZGVQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7XG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAsIDEuMCwgIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiB0cnVlLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7UG9wb3ZlckFuaW1hdG9yLCBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yLCBNREZhZGVQb3BvdmVyQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAnLnBvcG92ZXJfX2NvbnRhaW5lcic6ICdwb3BvdmVyX19jb250YWluZXItLSonLFxuICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlcl9fY29udGVudC0tKicsXG4gICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlcl9fYXJyb3ctLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ25vbmUnOiBQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlUG9wb3ZlckFuaW1hdG9yXG59O1xuXG5jb25zdCB0ZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoYFxuICA8ZGl2IGNsYXNzPVwicG9wb3Zlci1tYXNrXCI+PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGVudFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19hcnJvd1wiPjwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC4gRm9yIE1hdGVyaWFsIERlc2lnbiwgcG9wb3ZlciBsb29rcyBleGFjdGx5IGFzIGEgZHJvcGRvd24gbWVudS5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGd1aWRlIGRpYWxvZ3NcbiAqICBbZW5dRGlhbG9nIGNvbXBvbmVudHNbL2VuXVxuICogIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyLW1hc2snKTtcbiAgfVxuXG4gIGdldCBfcG9wb3ZlcigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyX19jb250YWluZXInKTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX2Fycm93KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl9pbml0QW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG4gIH1cblxuICBfaW5pdEFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IFBvcG92ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdQb3BvdmVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpIHx8ICdkZWZhdWx0J1xuICAgIH0pO1xuICAgIHRoaXMuX2FuaW1hdG9yID0gKG9wdGlvbnMpID0+IGZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gIH1cblxuICBfcG9zaXRpb25Qb3BvdmVyKHRhcmdldCkge1xuICAgIGNvbnN0IHtfcmFkaXVzOiByYWRpdXMsIF9jb250ZW50OiBlbCwgX21hcmdpbjogbWFyZ2lufSA9IHRoaXM7XG4gICAgY29uc3QgcG9zID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGlzTUQgPSB1dGlsLmhhc01vZGlmaWVyKHRoaXMsICdtYXRlcmlhbCcpO1xuICAgIGNvbnN0IGNvdmVyID0gaXNNRCAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnY292ZXItdGFyZ2V0Jyk7XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IHtcbiAgICAgIHRvcDogcG9zLnRvcCAtIG1hcmdpbixcbiAgICAgIGxlZnQ6IHBvcy5sZWZ0IC0gbWFyZ2luLFxuICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoIC0gcG9zLnJpZ2h0IC0gbWFyZ2luLFxuICAgICAgYm90dG9tOiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3MuYm90dG9tIC0gbWFyZ2luXG4gICAgfTtcblxuICAgIGNvbnN0IHt2ZXJ0aWNhbCwgcHJpbWFyeSwgc2Vjb25kYXJ5fSA9IHRoaXMuX2NhbGN1bGF0ZURpcmVjdGlvbnMoZGlzdGFuY2UpO1xuICAgIHRoaXMuX3BvcG92ZXIuY2xhc3NMaXN0LmFkZCgncG9wb3Zlci0tJyArIHByaW1hcnkpO1xuXG4gICAgY29uc3Qgb2Zmc2V0ID0gY292ZXIgPyAwIDogKHZlcnRpY2FsID8gcG9zLmhlaWdodCA6IHBvcy53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgdGhpcy5zdHlsZVtwcmltYXJ5XSA9IE1hdGgubWF4KDAsIGRpc3RhbmNlW3ByaW1hcnldICsgb2Zmc2V0KSArIG1hcmdpbiArICdweCc7XG4gICAgZWwuc3R5bGVbcHJpbWFyeV0gPSAwO1xuXG4gICAgY29uc3QgbCA9IHZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIGNvbnN0IHNpemVzID0gKHN0eWxlID0+ICh7XG4gICAgICB3aWR0aDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpKVxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkpO1xuXG4gICAgZWwuc3R5bGVbc2Vjb25kYXJ5XSA9IE1hdGgubWF4KDAsIGRpc3RhbmNlW3NlY29uZGFyeV0gLSAoc2l6ZXNbbF0gLSBwb3NbbF0pIC8gMikgKyAncHgnO1xuICAgIHRoaXMuX2Fycm93LnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heChyYWRpdXMsIGRpc3RhbmNlW3NlY29uZGFyeV0gKyBwb3NbbF0gLyAyKSArICdweCc7XG5cbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm1PcmlnaW4oZGlzdGFuY2UsIHNpemVzLCBwb3MsIHByaW1hcnkpO1xuXG4gICAgLy8gUHJldmVudCBhbmltaXQgZnJvbSByZXN0b3JpbmcgdGhlIHN0eWxlLlxuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltaXQtb3JpZy1zdHlsZScpO1xuICB9XG5cbiAgX3NldFRyYW5zZm9ybU9yaWdpbihkaXN0YW5jZSwgc2l6ZXMsIHBvcywgcHJpbWFyeSkge1xuICAgIGNvbnN0IGNhbGMgPSAoYSwgbywgbCkgPT4gcHJpbWFyeSA9PT0gYSA/IHNpemVzW2xdIC8gMiA6IGRpc3RhbmNlW2FdICsgKHByaW1hcnkgPT09IG8gPyAtc2l6ZXNbbF0gOiBzaXplc1tsXSAtIHBvc1tsXSkgLyAyO1xuICAgIGNvbnN0IFt4LCB5XSA9IFtjYWxjKCdsZWZ0JywgJ3JpZ2h0JywgJ3dpZHRoJykgKyAncHgnLCBjYWxjKCd0b3AnLCAnYm90dG9tJywgJ2hlaWdodCcpICsgJ3B4J107XG4gICAgdXRpbC5leHRlbmQodGhpcy5fcG9wb3Zlci5zdHlsZSwge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB4ICsgJyAnICsgeSxcbiAgICAgIHdlYmtpdFRyYW5zZm9ybU9yaWdpblg6IHgsXG4gICAgICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW5ZOiB5XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIHx8ICd1cCBkb3duIGxlZnQgcmlnaHQnKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IHBvc2l0aW9uc1tlXSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2VbYV0gLSBkaXN0YW5jZVtiXSlbMF07XG4gICAgY29uc3QgdmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHByaW1hcnkpICE9PSAtMTtcbiAgICBsZXQgc2Vjb25kYXJ5O1xuXG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS5sZWZ0IDwgZGlzdGFuY2UucmlnaHQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS50b3AgPCBkaXN0YW5jZS5ib3R0b20gPyAndG9wJyA6ICdib3R0b20nO1xuICAgIH1cblxuICAgIHJldHVybiB7dmVydGljYWwsIHByaW1hcnksIHNlY29uZGFyeX07XG4gIH1cblxuICBfY2xlYXJTdHlsZXMoKSB7XG4gICAgWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5fYXJyb3cuc3R5bGVbZV0gPSB0aGlzLl9jb250ZW50LnN0eWxlW2VdID0gdGhpcy5zdHlsZVtlXSA9ICcnO1xuICAgICAgdGhpcy5fcG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKGBwb3BvdmVyLS0ke2V9YCk7XG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdwb3BvdmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXInKTtcblxuICAgIGNvbnN0IGhhc0RlZmF1bHRDb250YWluZXIgPSB0aGlzLl9wb3BvdmVyICYmIHRoaXMuX2NvbnRlbnQ7XG5cbiAgICBpZiAoaGFzRGVmYXVsdENvbnRhaW5lcikge1xuXG4gICAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItbWFzaycpO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Fycm93KSB7XG4gICAgICAgIGNvbnN0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXJfX2Fycm93Jyk7XG4gICAgICAgIHRoaXMuX3BvcG92ZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnBvcG92ZXJfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgdGhpcy5fcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiAmJiAhKG9wdGlvbnMuYW5pbWF0aW9uIGluIF9hbmltYXRvckRpY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuaW1hdG9yICR7b3B0aW9ucy5hbmltYXRpb259IGlzIG5vdCByZWdpc3RlcmVkLmApO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSksXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICApO1xuICB9XG5cbiAgX2V4ZWN1dGVBY3Rpb24oYWN0aW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIGNvbnN0IHthY3Rpb24sIGJlZm9yZSwgYWZ0ZXJ9ID0gYWN0aW9ucztcblxuICAgIHRoaXMuX3ByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwcmUke2FjdGlvbn1gLCB7IC8vIHN5bmNocm9ub3VzXG4gICAgICBwb3BvdmVyOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBjYW5jZWxlZCA9IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcblxuICAgICAgICBiZWZvcmUgJiYgYmVmb3JlKCk7XG5cbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9hbmltYXRvcihvcHRpb25zKVthY3Rpb25dKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFmdGVyICYmIGFmdGVyKCk7XG5cbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgYHBvc3Qke2FjdGlvbn1gLCB7cG9wb3ZlcjogdGhpc30pO1xuXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KHRhcmdldCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudHxIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LiBDYW4gYmUgZWl0aGVyIGEgQ1NTIHNlbGVjdG9yLCBhbiBldmVudCBvYmplY3Qgb3IgYSBET00gZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgr/jg7zjgrLjg4Pjg4jjgajjgarjgovopoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJDU1Pjgrvjg6zjgq/jgr/jgYtldmVudOOCquODluOCuOOCp+OCr+ODiOOBi0RPTeimgee0oOOBruOBhOOBmuOCjOOBi+OCkua4oeOBm+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbiB0aGUgcG9wb3ZlciBhbmQgcG9pbnQgaXQgYXQgYSB0YXJnZXQuIFRoZSB0YXJnZXQgY2FuIGJlIGVpdGhlciBhbiBldmVudCwgYSBDU1Mgc2VsZWN0b3Igb3IgYSBET00gZWxlbWVudC4uWy9lbl1cbiAgICogICBbamFd5a++6LGh44Go44GZ44KL6KaB57Sg44Gr44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GX44G+44GZ44CCdGFyZ2V05byV5pWw44Gr44Gv44CBJGV2ZW5044Kq44OW44K444Kn44Kv44OI44KERE9N44Ko44Os44Oh44Oz44OI44KEQ1NT44K744Os44Kv44K/44KS5rih44GZ44GT44Go44GM5Ye65p2l44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3codGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRhcmdldCBhcmd1bWVudCBtdXN0IGJlIGRlZmluZWQgZm9yIHRoZSBwb3BvdmVyLicpO1xuICAgIH1cblxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVBY3Rpb24oe1xuICAgICAgYWN0aW9uOiAnc2hvdycsXG4gICAgICBiZWZvcmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Qb3BvdmVyKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICBhY3Rpb246ICdoaWRlJyxcbiAgICAgIGFmdGVyOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5fY2xlYXJTdHlsZXMoKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgb3Igbm90LlxuICAgKlxuICAgKiAgICAgV2hlbiB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfcmVzZXRCYWNrQnV0dG9uSGFuZGxlcigpIHsgLy8gZG8gd2UgbmVlZCB0aGlzIHR3aWNlP1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3Jlc2V0QmFja0J1dHRvbkhhbmRsZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgndG9wJykpO1xuXG4gICAgICAvLyBGaXggZm9yIGlmcmFtZXNcbiAgICAgIGlmICghdGhpcy5fbWFyZ2luKSB7XG4gICAgICAgIHRoaXMuX21hcmdpbiA9IDY7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JhZGl1cyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2NvbnRlbnQpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKSk7XG5cbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9yZXNldEJhY2tCdXR0b25IYW5kbGVyKCk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2RpcmVjdGlvbicsICdhbmltYXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdkaXJlY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmRPbkNoYW5nZSgpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgIHRoaXMuX2luaXRBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2RpYWxvZy1jYW5jZWwnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7UG9wb3ZlckFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb3BvdmVyQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgUG9wb3ZlckFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgUG9wb3ZlckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBQb3BvdmVyQW5pbWF0b3I7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcG9wb3ZlcicsIFBvcG92ZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXJfX3NlY29uZGFyeS0tKidcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgbGluZWFyIHByb2dyZXNzIGJhci4gSXQgY2FuIGVpdGhlciBkaXNwbGF5IGEgcHJvZ3Jlc3MgYmFyIHRoYXQgc2hvd3MgdGhlIHVzZXIgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZC4gSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHBlcmNlbnRhZ2UgaXMgbm90IGtub3duIGl0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgYW4gYW5pbWF0ZWQgcHJvZ3Jlc3MgYmFyIHNvIHRoZSB1c2VyIGNhbiBzZWUgdGhhdCBhbiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4genZRYkdqXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3NcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWNpcmN1bGFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyZXNzQmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmltYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoYmFyRWxlbWVudCwgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAndmFsdWUnLCAnc2Vjb25kYXJ5LXZhbHVlJywgJ2luZGV0ZXJtaW5hdGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZS53aWR0aCA9ICh0aGlzLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSArICclJyA6ICcwJSc7XG4gICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUud2lkdGggPSB0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKyAnJScgOiAnMCUnO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHJvZ3Jlc3MtYmFyJywgUHJvZ3Jlc3NCYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcic6ICdwcm9ncmVzcy1jaXJjdWxhci0tKicsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnktLSonLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeS0tKidcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPHN2ZyBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyXCI+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMTAlXCIgc3Ryb2tlLW1pdGVybGltaXQ9XCIxMFwiLz5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMTAlXCIgc3Ryb2tlLW1pdGVybGltaXQ9XCIxMFwiLz5cbiAgPC9zdmc+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuIEl0IGNhbiBlaXRoZXIgYmUgdXNlZCB0byBzaG93IGhvdyBtdWNoIG9mIGEgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQgb3IgdG8gc2hvdyBhIGxvb3BpbmcgYW5pbWF0aW9uIHRvIGluZGljYXRlIHRoYXQgYW4gb3BlcmF0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIEVWek1qUlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXG4gKiBAc2VlYWxzbyBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFyIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICBpbmRldGVybWluYXRlPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3ZhbHVlJywgJ3NlY29uZGFyeS12YWx1ZScsICdpbmRldGVybWluYXRlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2luZGV0ZXJtaW5hdGUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtY2lyY3VsYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlYCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1jaXJjdWxhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtY2lyY3VsYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9IE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyID0gIE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHNlY29uZGFyeVZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnLCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKCkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1jaXJjdWxhcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmltYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknKTtcbiAgICB0aGlzLl9zZWNvbmRhcnkgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSwgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9pc0NvbXBpbGVkKCkge1xuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1jaXJjdWxhcicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ZnID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1jaXJjdWxhcicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZChzdmcsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZChzdmcsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXByb2dyZXNzLWNpcmN1bGFyJywgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3QgU1RBVEVfSU5JVElBTCA9ICdpbml0aWFsJztcbmNvbnN0IFNUQVRFX1BSRUFDVElPTiA9ICdwcmVhY3Rpb24nO1xuY29uc3QgU1RBVEVfQUNUSU9OID0gJ2FjdGlvbic7XG5cbmNvbnN0IHJlbW92ZVRyYW5zZm9ybSA9IChlbCkgPT4ge1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgZWwuc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gJyc7XG4gIGVsLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgZWwuc3R5bGUuV2Via2l0VHJhbnNpdGlvbiA9ICcnO1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHVsbC1ob29rXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdGhhdCBhZGRzICoqUHVsbCB0byByZWZyZXNoKiogZnVuY3Rpb25hbGl0eSB0byBhbiBgPG9ucy1wYWdlPmAgZWxlbWVudC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBhIHRhc2sgd2hlbiB0aGUgdXNlciBwdWxscyBkb3duIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2UuIEEgY29tbW9uIHVzYWdlIGlzIHRvIHJlZnJlc2ggdGhlIGRhdGEgZGlzcGxheWVkIGluIGEgcGFnZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBXYkpvZ01cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wdWxsLWhvb2tcbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtcHVsbC1ob29rPlxuICogICAgIFJlbGVhc2UgdG8gcmVmcmVzaFxuICogICA8L29ucy1wdWxsLWhvb2s+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wdWxsLWhvb2snKS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDApO1xuICogICB9O1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1bGxIb29rRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZXN0YXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkLiBUaGUgc3RhdGUgY2FuIGJlIGVpdGhlciBcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiBvciBcImFjdGlvblwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrueKtuaFi+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAgueKtuaFi+OBr+OAgVwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiLCBcImFjdGlvblwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucHVsbEhvb2tcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQuc3RhdGVcbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7nirbmhYvlkI3jgpLlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBcInB1bGwtdG8tcmVmcmVzaFwiIGZ1bmN0aW9uYWxpdHkgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZGlzYWJsZWTnirbmhYvjgavjgarjgorjgqLjgq/jgrfjg6fjg7PjgYzlrp/ooYzjgZXjgozjgarjgY/jgarjgorjgb7jgZlbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBoZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50LiBXaGVuIHB1bGxlZCBkb3duIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlIGl0IHdpbGwgc3dpdGNoIHRvIHRoZSBcInByZWFjdGlvblwiIHN0YXRlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjY0cHhcIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7pq5jjgZXku6XkuIrjgatwdWxsIGRvd27jgZnjgovjgahcInByZWFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gu5YCk44GvXCI2NHB4XCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0aHJlc2hvbGQtaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSB0aHJlc2hvbGQgaGVpZ2h0LiBUaGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgc3dpdGNoZXMgdG8gdGhlIFwiYWN0aW9uXCIgc3RhdGUgd2hlbiBwdWxsZWQgZnVydGhlciB0aGFuIHRoaXMgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiOTZweFwiLiBBIG5lZ2F0aXZlIHZhbHVlIG9yIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSBoZWlnaHQgd2lsbCBkaXNhYmxlIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFd6Za+5YCk44Go44Gq44KL6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5YCk44Gn5oyH5a6a44GX44Gf6auY44GV44KI44KK44KCcHVsbCBkb3du44GZ44KL44Go44CB44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gv6Ieq5YuV55qE44GrXCJhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZpeGVkLWNvbnRlbnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgcGFnZSB3aWxsIG5vdCBtb3ZlIHdoZW4gcHVsbGluZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgabjgYTjgovmmYLjgavjgoLjgrPjg7Pjg4bjg7Pjg4Tjga/li5XjgY3jgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JvdW5kT25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdTdGFydCA9IHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwsIHRydWUpO1xuICB9XG5cbiAgX3NldFN0eWxlKCkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgIHRoaXMuc3R5bGUubGluZUhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgdGhpcy5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gYC0ke2hlaWdodH1weGA7XG4gIH1cblxuICBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCAwKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgwcHgsICR7c2Nyb2xsfXB4LCAwcHgpYDtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhY2sgdG8gbWFrZSBpdCB3b3JrIG9uIEFuZHJvaWQgNC40IFdlYlZpZXcuIFNjcm9sbHMgbWFudWFsbHkgbmVhciB0aGUgdG9wIG9mIHRoZSBwYWdlIHNvXG4gICAgLy8gdGhlcmUgd2lsbCBiZSBubyBpbmVydGlhbCBzY3JvbGwgd2hlbiBzY3JvbGxpbmcgZG93bi4gQWxsb3dpbmcgZGVmYXVsdCBzY3JvbGxpbmcgd2lsbFxuICAgIC8vIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cbiAgICBpZiAocGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9wYWdlRWxlbWVudDtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5fc3RhcnRTY3JvbGwgLSBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiBldmVudC5nZXN0dXJlLmRpcmVjdGlvbiAhPT0gJ3VwJykge1xuICAgICAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9PT0gMCAmJiB0aGlzLl9nZXRDdXJyZW50U2Nyb2xsKCkgPT09IDApIHtcbiAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoID0gZXZlbnQuZ2VzdHVyZS5kZWx0YVk7XG5cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50Lmdlc3R1cmUuaW50ZXJpbURpcmVjdGlvbjtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heChldmVudC5nZXN0dXJlLmRlbHRhWSAtIHRoaXMuX3N0YXJ0U2Nyb2xsLCAwKTtcblxuICAgIGlmICh0aGlzLl90aHJlc2hvbGRIZWlnaHRFbmFibGVkKCkgJiYgc2Nyb2xsID49IHRoaXMudGhyZXNob2xkSGVpZ2h0KSB7XG4gICAgICBldmVudC5nZXN0dXJlLnN0b3BEZXRlY3QoKTtcblxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2ZpbmlzaCgpKTtcbiAgICB9IGVsc2UgaWYgKHNjcm9sbCA+PSB0aGlzLmhlaWdodCkge1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfUFJFQUNUSU9OKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgfVxuXG4gICAgLy8gQnkgc3RvcHBpbmcgcHJvcGFnYXRpb24gb25seSBvZiBgZHJhZ3VwYCBhbmQgYGRyYWdkb3duYCxcbiAgICAvLyBhbGxvd2luZyBhbmNlc3RvciBlbGVtZW50cyB0byBkZXRlY3QgYGRyYWdsZWZ0YCBhbmQgYGRyYWdyaWdodGAuXG4gICAgLy8gSWYgd2UgY29tbWVudCBvdXQgdGhlIGZvbGxvd2luZyBgaWZgIGJsb2NrLCBgb25zLXNwbGl0dGVyYCB3aXRoIGBvbnMtcHVsbC1ob29rYCB3aWxsIGJlIGJyb2tlbi5cbiAgICBpZiAoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICd1cCcgfHwgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNsYXRlVG8oc2Nyb2xsKTtcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChldmVudCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnRTY3JvbGwgPSB0aGlzLl9nZXRDdXJyZW50U2Nyb2xsKCk7XG4gIH1cblxuICBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID4gMCkge1xuICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xuXG4gICAgICBpZiAoc2Nyb2xsID4gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25BY3Rpb25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYGFjdGlvbmAgc3RhdGUgaWYgaXQgZXhpc3RzLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBnaXZlbiBhIGBkb25lYCBjYWxsYmFjayBhcyBpdCdzIGZpcnN0IGFyZ3VtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIF9maW5pc2goKSB7XG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfQUNUSU9OKTtcbiAgICB0aGlzLl90cmFuc2xhdGVUbyh0aGlzLmhlaWdodCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm9uQWN0aW9uIHx8IChkb25lID0+IGRvbmUoKSk7XG4gICAgYWN0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgaGVpZ2h0IG9mIHRoZSBwdWxsIGhvb2sgaW4gcGl4ZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNjRweGAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaGVpZ2h0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICc2NCcsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdGhyZXNob2xkSGVpZ2h0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgdGhyZXNob2xkSGVpZ2h0IG9mIHRoZSBwdWxsIGhvb2sgaW4gcGl4ZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgOTZweGAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCB0aHJlc2hvbGRIZWlnaHQodmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGhyZXNob2xkIGhlaWdodCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGhyZXNob2xkLWhlaWdodCcsIGAke3ZhbHVlfXB4YCk7XG4gIH1cblxuICBnZXQgdGhyZXNob2xkSGVpZ2h0KCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndGhyZXNob2xkLWhlaWdodCcpIHx8ICc5NicsIDEwKTtcbiAgfVxuXG4gIF90aHJlc2hvbGRIZWlnaHRFbmFibGVkKCkge1xuICAgIGNvbnN0IHRoID0gdGhpcy50aHJlc2hvbGRIZWlnaHQ7XG4gICAgcmV0dXJuIHRoID4gMCAmJiB0aCA+PSB0aGlzLmhlaWdodDtcbiAgfVxuXG4gIF9zZXRTdGF0ZShzdGF0ZSwgbm9FdmVudCkge1xuICAgIGNvbnN0IGxhc3RTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKCk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3RhdGUnLCBzdGF0ZSk7XG5cbiAgICBpZiAoIW5vRXZlbnQgJiYgbGFzdFN0YXRlICE9PSB0aGlzLl9nZXRTdGF0ZSgpKSB7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZXN0YXRlJywge1xuICAgICAgICBwdWxsSG9vazogdGhpcyxcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBsYXN0U3RhdGU6IGxhc3RTdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3RhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3RhdGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7XG4gIH1cblxuICBfZ2V0Q3VycmVudFNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwdWxsRGlzdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBudW1iZXIgb2YgcGl4ZWxzIHRoZSBwdWxsIGhvb2sgaGFzIG1vdmVkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODl+ODq+ODleODg+OCr+OBjOW8leOBjeWHuuOBleOCjOOBn+i3nembouOCkuODlOOCr+OCu+ODq+aVsOOAglsvamFdXG4gICAqL1xuICBnZXQgcHVsbERpc3RhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2lzQ29udGVudEZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZml4ZWQtY29udGVudCcpO1xuICB9XG5cbiAgX2dldFNjcm9sbGFibGVFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLl9pc0NvbnRlbnRGaXhlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKi9cbiAgX3RyYW5zbGF0ZVRvKHNjcm9sbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9PSAwICYmIHNjcm9sbCA9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgIGlmIChzY3JvbGwgPT09IDApIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpO1xuICAgICAgICByZW1vdmVUcmFuc2Zvcm0oZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IHNjcm9sbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4zLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnBsYXkoZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgIH0pXG4gICAgICAgIC5wbGF5KGRvbmUpO1xuICAgIH1cbiAgfVxuXG4gIF9kaXNhYmxlRHJhZ0xvY2soKSB7IC8vIGUyZSB0ZXN0cyBuZWVkIGl0XG4gICAgdGhpcy5fZHJhZ0xvY2tEaXNhYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fZGVzdHJveUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fY3JlYXRlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIF9jcmVhdGVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuX3BhZ2VFbGVtZW50LCB7XG4gICAgICBkcmFnTWluRGlzdGFuY2U6IDEsXG4gICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiBmYWxzZSxcbiAgICAgIGRyYWdMb2NrVG9BeGlzOiAhdGhpcy5fZHJhZ0xvY2tEaXNhYmxlZFxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBsaXN0ZW5lcnNcbiAgICAvL1xuICAgIC8vIE5vdGU6XG4gICAgLy8gSWYgd2Ugc3dpcGUgdXAvZG93biBhIHNjcmVlbiB0b28gZmFzdCxcbiAgICAvLyB0aGUgZ2VzdHVyZSBkZXRlY3RvciBvY2Nhc2lvbmFsbHkgZGlzcGF0Y2hlcyBhIGBkcmFnbGVmdGAgb3IgYGRyYWdyaWdodGAsXG4gICAgLy8gc28gd2UgbmVlZCB0byBoYXZlIHRoZSBwdWxsIGhvb2sgbGlzdGVuIHRvIGBkcmFnbGVmdGAgYW5kIGBkcmFncmlnaHRgIGFzIHdlbGwgYXMgYGRyYWd1cGAgYW5kIGBkcmFnZG93bmAuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFndXAgZHJhZ2Rvd24gZHJhZ2xlZnQgZHJhZ3JpZ2h0JywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdTdGFydCk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuXG4gICAgdGhpcy5fcGFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCwgZmFsc2UpO1xuICB9XG5cbiAgX2Rlc3Ryb3lFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFndXAgZHJhZ2Rvd24gZHJhZ2xlZnQgZHJhZ3JpZ2h0JywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdTdGFydCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuXG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSAwO1xuICAgIHRoaXMuX3BhZ2VFbGVtZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgdGhpcy5fY3JlYXRlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9zZXRTdHlsZSgpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJyc7XG5cbiAgICB0aGlzLl9kZXN0cm95RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2hlaWdodCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2hlaWdodCcpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBTVEFURV9JTklUSUFMKCkge1xuICAgIHJldHVybiBTVEFURV9JTklUSUFMO1xuICB9XG5cbiAgc3RhdGljIGdldCBTVEFURV9QUkVBQ1RJT04oKSB7XG4gICAgcmV0dXJuIFNUQVRFX1BSRUFDVElPTjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgU1RBVEVfQUNUSU9OKCkge1xuICAgIHJldHVybiBTVEFURV9BQ1RJT047XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHVsbC1ob29rJywgUHVsbEhvb2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE2IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuXG4vKipcbiAqIEBjbGFzcyBBbmltYXRvckNTUyAtIGltcGxlbWVudGF0aW9uIG9mIEFuaW1hdG9yIGNsYXNzIHVzaW5nIGNzcyB0cmFuc2l0aW9uc1xuICovXG5jbGFzcyBBbmltYXRvckNTUyB7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYW5pbWF0ZVxuICAgKiBAZGVzYyBtYWluIGFuaW1hdGlvbiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbmFsQ1NTXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSAtIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnRoZW4oY2FsbGJhY2spIC0gc2V0cyBhIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIHN0b3BwZWRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zdG9wKG9wdGlvbnMpIC0gc3RvcHMgdGhlIGFuaW1hdGlvbjsgaWYgb3B0aW9ucy5zdG9wTmV4dCBpcyB0cnVlIHRoZW4gaXQgZG9lc24ndCBjYWxsIHRoZSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LmZpbmlzaChtcykgLSBmaW5pc2hlcyB0aGUgYW5pbWF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zcGVlZChtcykgLSBzZXRzIHRoZSBhbmltYXRpb24gc3BlZWQgc28gdGhhdCBpdCBmaW5pc2hlcyBhcyBpZiB0aGUgb3JpZ2luYWwgZHVyYXRpb24gd2FzIHRoZSBvbmUgc3BlY2lmaWVkIGhlcmVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgYFxuICAgKiAgdmFyIHJlc3VsdCA9IGFuaW1hdG9yLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwLjV9LCAxMDAwKTtcbiAgICpcbiAgICogIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAqICAgIHJlc3VsdC5zcGVlZCgyMDApLnRoZW4oZnVuY3Rpb24oKXtcbiAgICogICAgICBjb25zb2xlLmxvZygnZG9uZScpO1xuICAgKiAgICB9KTtcbiAgICogIH0sIDMwMCk7XG4gICAqIGBgYGBcbiAgICovXG4gIGFuaW1hdGUoZWwsIGZpbmFsLCBkdXJhdGlvbiA9IDIwMCkge1xuICAgIHZhciBzdGFydCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgIGluaXRpYWwgPSB7fSxcbiAgICAgICAgc3RvcHBlZCA9IGZhbHNlLFxuICAgICAgICBuZXh0ID0gZmFsc2UsXG4gICAgICAgIHRpbWVvdXQgPSBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGZpbmFsKTtcblxuICAgIHZhciB1cGRhdGVTdHlsZXMgPSAoKSA9PiB7XG4gICAgICBsZXQgcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChzLmdldFByb3BlcnR5VmFsdWUuYmluZChzKSk7XG4gICAgICBzID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RvcDogKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdmFyIGsgPSBNYXRoLm1pbigxLCAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uKTtcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcblxuICAgICAgICBpZiAob3B0aW9ucy5zdG9wTmV4dCkge1xuICAgICAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgdGhlbjogKGNiKSA9PiB7XG4gICAgICAgIG5leHQgPSBjYjtcbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHNwZWVkOiAobmV3RHVyYXRpb24pID0+IHtcbiAgICAgICAgaWYgKGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgICAgICBuZXdEdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgICBjb25zdCBwYXNzZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQ7XG4gICAgICAgICAgY29uc3QgIGsgPSBwYXNzZWQgLyBkdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBuZXdEdXJhdGlvbiAqICgxIC0gayk7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVwZGF0ZVN0eWxlcygpO1xuXG4gICAgICAgICAgc3RhcnQgPSBlbC5zcGVlZFVwVGltZTtcbiAgICAgICAgICBkdXJhdGlvbiA9IHJlbWFpbmluZztcblxuICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IChtaWxsaXNlY29uZHMgPSA1MCkgPT4ge1xuICAgICAgICB2YXIgayA9ICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb247XG5cbiAgICAgICAgcmVzdWx0LnNwZWVkKG1pbGxpc2Vjb25kcyAvICgxIC0gaykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IHN0b3BwZWQgfHwgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgY29uc3QgdiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShlKSk7XG4gICAgICBpbml0aWFsW2VdID0gaXNOYU4odikgPyAwIDogdjtcbiAgICB9KTtcblxuXG4gICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBwcm9wZXJ0aWVzLmpvaW4oJywnKTtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBlbC5zdHlsZVtlXSA9IGZpbmFsW2VdICsgKGUgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fb25TdG9wQW5pbWF0aW9ucyhlbCwgcmVzdWx0LnN0b3ApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5faW5kZXggPSAwO1xuICB9XG5cbiAgX29uU3RvcEFuaW1hdGlvbnMoZWwsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGkgPSB0aGlzLl9pbmRleCsrO1xuICAgIHF1ZXVlW2VsXSA9IHF1ZXVlW2VsXSB8fCBbXTtcbiAgICBxdWV1ZVtlbF1baV0gPSAob3B0aW9ucykgPT4ge1xuICAgICAgZGVsZXRlIHF1ZXVlW2VsXVtpXTtcbiAgICAgIGlmIChxdWV1ZVtlbF0gJiYgcXVldWVbZWxdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBxdWV1ZVtlbF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXIob3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFuaW1hdGlvbnNcbiAgKiBAZGVzYyBzdG9wcyBhY3RpdmUgYW5pbWF0aW9ucyBvbiBhIHNwZWNpZmllZCBlbGVtZW50XG4gICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbGVtZW50IC0gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50c1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgcmV0dXJuIGVsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICh0aGlzLl9xdWV1ZVtlbF0gfHwgW10pLmZvckVhY2goZSA9PiB7IGUob3B0aW9ucyB8fCB7fSk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBzdG9wQWxsXG4gICogQGRlc2Mgc3RvcHMgYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxuICAqL1xuICBzdG9wQWxsKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbnMoT2JqZWN0LmtleXModGhpcy5fcXVldWUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2QgZmFkZVxuICAqIEBkZXNjIGZhZGVzIHRoZSBlbGVtZW50IChzaG9ydCB2ZXJzaW9uIGZvciBhbmltYXRlKGVsLCB7b3BhY2l0eTogMH0pKVxuICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXVxuICAqL1xuICBmYWRlKGVsLCBkdXJhdGlvbiA9IDIwMCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSwgZHVyYXRpb24pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0b3JDU1M7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uLy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3ItY3NzJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yaXBwbGVcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWRkcyBhIE1hdGVyaWFsIERlc2lnbiBcInJpcHBsZVwiIGVmZmVjdCB0byBhbiBlbGVtZW50LiBUaGUgcmlwcGxlIGVmZmVjdCB3aWxsIHNwcmVhZCBmcm9tIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgdXNlciB0YXBzLlxuICpcbiAqICAgICBTb21lIGVsZW1lbnRzIHN1Y2ggYXMgYDxvbnMtYnV0dG9uPmAgYW5kIGA8b25zLWZhYj5gICBzdXBwb3J0IGEgYHJpcHBsZWAgYXR0cmlidXRlLlxuICogICBbL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oq44OD44OX44Or5Yq55p6c44KSRE9N6KaB57Sg44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHdLUVdkWlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JpcHBsZVxuICogQGd1aWRlIGNyb3NzLXBsYXRmb3JtLXN0eWxpbmdcbiAqICBbZW5dQ3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dXG4gKiAgW2phXUNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxkaXYgY2xhc3M9XCJteS1kaXZcIj5cbiAqICA8b25zLXJpcHBsZT48L29ucy1yaXBwbGU+XG4gKiA8L2Rpdj5cbiAqXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gcmlwcGxlPkNsaWNrIG1lITwvb25zLWJ1dHRvbj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmlwcGxlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogICBbamFd44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFja2dyb3VuZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu6Imy44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgdGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga/nhKHlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuICAgIFsnY29sb3InLCAnY2VudGVyJywgJ3N0YXJ0LXJhZGl1cycsICdiYWNrZ3JvdW5kJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmlwcGxlJyk7XG5cbiAgICB0aGlzLl93YXZlID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX3dhdmUnKVswXTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX2JhY2tncm91bmQnKVswXTtcblxuICAgIGlmICghKHRoaXMuX2JhY2tncm91bmQgJiYgdGhpcy5fd2F2ZSkpIHtcbiAgICAgIHRoaXMuX3dhdmUgPSB1dGlsLmNyZWF0ZSgnLnJpcHBsZV9fd2F2ZScpO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IHV0aWwuY3JlYXRlKCcucmlwcGxlX19iYWNrZ3JvdW5kJyk7XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fd2F2ZSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX2JhY2tncm91bmQpO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgIHZhciB4LCB5LCBoLCB3LCByO1xuICAgIHZhciBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAodGhpcy5fY2VudGVyKSB7XG4gICAgICB4ID0gYi53aWR0aCAvIDI7XG4gICAgICB5ID0gYi5oZWlnaHQgLyAyO1xuICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IChlLmNsaWVudFggfHwgZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSAtIGIubGVmdDtcbiAgICAgIHkgPSAoZS5jbGllbnRZIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdyk7XG4gICAgfVxuICAgIHJldHVybiB7eCwgeSwgcn07XG4gIH1cblxuICBfcmlwcGxlQW5pbWF0aW9uKGUsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgdmFyXG4gICAgICB7X2FuaW1hdG9yLCBfd2F2ZSwgX2JhY2tncm91bmQsIF9taW5SfSA9IHRoaXMsXG4gICAgICB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9ob2xkaW5nLnNwZWVkKDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faG9sZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBuID0gdGhpcy5fcGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGU7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N0YXJ0LXJhZGl1cycsICdjb2xvcicsICdiYWNrZ3JvdW5kJywgJ2NlbnRlciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3N0YXJ0LXJhZGl1cycpIHtcbiAgICAgIHRoaXMuX21pblIgPSBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KGN1cnJlbnQpIHx8IDApO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2NvbG9yJyAmJiBjdXJyZW50KSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl93YXZlLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdiYWNrZ3JvdW5kJykpIHtcbiAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kJyAmJiAoY3VycmVudCB8fCBsYXN0KSkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09ICdub25lJykge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdjZW50ZXInKSB7XG4gICAgICB0aGlzLl9jZW50ZXIgPSBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudCAhPSAnZmFsc2UnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcmlwcGxlJywgUmlwcGxlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJvd1xuICogQGNhdGVnb3J5IGdyaWRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIHJvdyBpbiB0aGUgZ3JpZCBzeXN0ZW0uIFVzZSB3aXRoIGA8b25zLWNvbD5gIHRvIGxheW91dCBjb21wb25lbnRzLlsvZW5dXG4gKiAgIFtqYV3jgrDjg6rjg4Pjg4njgrfjgrnjg4bjg6DjgavjgabooYzjgpLlrprnvqnjgZfjgb7jgZnjgIJvbnMtY29s44Go44Go44KC44Gr5L2/55So44GX44CB44Kz44Oz44Od44O844ON44Oz44OI44Gu6YWN572u44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxuICogQGd1aWRlIGxheW91dGluZ1xuICogICBbZW5dTGF5b3V0aW5nIGd1aWRlWy9lbl1cbiAqICAgW2phXeODrOOCpOOCouOCpuODiOiqv+aVtFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtY29sXG4gKiAgIFtlbl1UaGUgYDxvbnMtY29sPmAgY29tcG9uZW50IGlzIHVzZWQgYXMgY2hpbGRyZW4gb2YgYDxvbnMtcm93PmAuWy9lbl1cbiAqICAgW2phXW9ucy1jb2zjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQG5vdGVcbiAqICAgW2VuXUZvciBBbmRyb2lkIDQuMyBhbmQgZWFybGllciwgYW5kIGlPUzYgYW5kIGVhcmxpZXIsIHdoZW4gdXNpbmcgbWl4ZWQgYWxpZ25tZW50IHdpdGggb25zLXJvdyBhbmQgb25zLWNvbCwgdGhleSBtYXkgbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuIFlvdSBjYW4gdXNlIG9ubHkgb25lIHZlcnRpY2FsLWFsaWduLlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbOOCkue1hOOBv+WQiOOCj+OBm+OBpuOBneOCjOOBnuOCjOOBrm9ucy1jb2zopoHntKDjga52ZXJ0aWNhbC1hbGlnbuWxnuaAp+OBruWApOOBq+WIpeOAheOBruWApOOCkuaMh+WumuOBmeOCi+OBqOOAgeaPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAgnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr44Gv5LiA44Gk44Gu5YCk44Gg44GR44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJvdz5cbiAqICAgPG9ucy1jb2wgd2lkdGg9XCI1MHB4XCI+PG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj48L29ucy1jb2w+XG4gKiAgIDxvbnMtY29sPlRleHQ8L29ucy1jb2w+XG4gKiA8L29ucy1yb3c+XG4gKi9cblxuLyoqXG4gKiBAYXR0cmlidXRlIHZlcnRpY2FsLWFsaWduXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TaG9ydCBoYW5kIGF0dHJpYnV0ZSBmb3IgYWxpZ25pbmcgdmVydGljYWxseS4gVmFsaWQgdmFsdWVzIGFyZSB0b3AsIGJvdHRvbSwgYW5kIGNlbnRlci5bL2VuXVxuICogICBbamFd57im44Gr5pW05YiX44GZ44KL44Gf44KB44Gr5oyH5a6a44GX44G+44GZ44CCdG9w44CBYm90dG9t44CBY2VudGVy44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yb3cnLCBSb3dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsX19pdGVtLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWwtaXRlbVxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgZGlhbCBjb21wb25lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICBNYXRlcmlhbCBEZXNpZ27jga5TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo54++44GZ44KL6KaB57Sg44Gn44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbFxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1zcGVlZC1kaWFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1taW5pJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzcGVlZC1kaWFsX19pdGVtJyk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGVlZC1kaWFsLWl0ZW0nLCBTcGVlZERpYWxJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vKipcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxuICovXG5jb25zdCBzdHlsZXIgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZSkge1xuICByZXR1cm4gc3R5bGVyLmNzcy5hcHBseShzdHlsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNldCBlbGVtZW50J3Mgc3R5bGUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5zdHlsZXIuY3NzID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChzdHlsZXIuX3ByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVyLl9wcmVmaXgoa2V5KV0gPSBzdHlsZXNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuc3R5bGVyLl9wcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgdmFyIHByZWZpeCA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChzdHlsZXMpXG4gICAgLmpvaW4oJycpXG4gICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgKVsxXTtcblxuICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBuYW1lLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5zdHlsZXIuY2xlYXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHN0eWxlci5fY2xlYXIoZWxlbWVudCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5zdHlsZXIuX2NsZWFyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXlzLnB1c2goc3R5bGVbaV0pO1xuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHN0eWxlW2tleV0gPSAnJztcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZXI7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL2xpYi9zdHlsZXInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbC0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBFbGVtZW50IHRoYXQgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgRGlhbG9nIGNvbXBvbmVudC4gSXQgaXMgdXNlZnVsIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBhY3Rpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGluIGEgcGFnZS5cbiAqXG4gKiAgICAgVGhlIFNwZWVkIGRpYWwgbG9va3MgbGlrZSBhIGA8b25zLWZhYj5gIGVsZW1lbnQgYnV0IHdpbGwgZXhwYW5kIGEgbWVudSB3aGVuIHRhcHBlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbC1pdGVtPmAgcmVwcmVzZW50cyBhIG1lbnUgaXRlbS5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZmFiXG4gKiAgIFtlbl1vbnMtZmFiIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZmFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVlZERpYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgc2hvd24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqICAgICBJLmUuIHRvIGRpc3BsYXkgaXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXIgc3BlY2lmeSBcInJpZ2h0IHRvcFwiLlxuICAgKiAgICAgQ2hvb3NlIGZyb20gXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBruimgee0oOOCkuihqOekuuOBmeOCi+W3puWPs+OBqOS4iuS4i+OBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5L6L44GI44Gw44CB5Y+z5LiK44Gr6KGo56S644GZ44KL5aC05ZCI44Gr44GvXCJyaWdodCB0b3BcIuOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44Gu5oyH5a6a44Gr44Gv44CBcmlnaHTjgahsZWZ044CBdG9w44GoYm90dG9t44GM44Gd44KM44Ge44KM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOimgee0oOOBjOihqOekuuOBmeOCi+aWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAgnVwLCBkb3duLCBsZWZ0LCByaWdodOOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ3NwZWVkX19kaWFsJykpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3BlZWRfX2RpYWwnKTtcbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdkaXJlY3Rpb24nLCAncG9zaXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtc3BlZWQtZGlhbC1pdGVtJykpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLl9zaG93bikge1xuICAgICAgdGhpcy50b2dnbGVJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgY29uc3QgZmFiID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1mYWInKTtcblxuICAgIGlmIChmYWIpIHtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSA/IGZhYi5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKSA6IGZhYi5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogaSArICdtcycsXG4gICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgICB0b3A6ICdhdXRvJyxcbiAgICAgICAgbGVmdDogJ2F1dG8nXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmJvdHRvbSA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAnOHB4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AgbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1mYWInKS5zaG93KCk7XG4gICAgdGhpcy5fc2hvd24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1mYWInKS5oaWRlKCk7XG4gICAgfSwgMjAwKTtcbiAgICB0aGlzLl9zaG93biA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0l0ZW1zXG4gICAqIEBzaWduYXR1cmUgc2hvd0l0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93SXRlbXMoKSB7XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCd1cCcpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faXRlbVNob3duKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogaSArICdtcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2l0ZW1TaG93biA9IHRydWU7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIGhpZGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaGlkZUl0ZW1zKCkge1xuICAgIGlmICh0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiAoY2hpbGRyZW4ubGVuZ3RoIC0gaSkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Nsb3NlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICB9XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZHJlbikuZm9yRWFjaChlID0+IHtcbiAgICAgIHV0aWwubWF0Y2goZSwgJy5mYWInKSAmJiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZShlLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5saW5lXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgaW5saW5lIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg7Pjg6njgqTjg7PopoHntKDjga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGlubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93biAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlblxuICAgKiBAc2lnbmF0dXJlIGlzT3BlbigpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIG1lbnUgaXMgb3BlbiBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbVNob3duO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMudmlzaWJsZSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBpdGVtIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGVJdGVtcygpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93SXRlbXMoKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BlZWQtZGlhbCcsIFNwZWVkRGlhbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7UGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXJ9IGZyb20gJy4uL29ucy9wYWdlLWxvYWRlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItY29udGVudFxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2hpbGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbnRhaW5zIHRoZSBsaXN0LlxuICogIFsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gv44CBb25zLXNwbGl0dGVy6KaB57Sg44Gu5a2Q6KaB57Sg44Go44GX44Gm5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBlbGVtZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckNvbnRlbnRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHVybCBvZiB0aGUgY29udGVudCBwYWdlLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyB1c2VkIHRoZSBjb250ZW50IHdpbGwgYmUgbG9hZGVkIGZyb20gYSBgPG9ucy10ZW1wbGF0ZT5gIHRhZyBvciBhIHJlbW90ZSBmaWxlLlxuICAgKlxuICAgKiAgICAgSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwdXQgYDxvbnMtcGFnZT5gIGVsZW1lbnQgYXMgYSBjaGlsZCBvZiB0aGUgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG5cbiAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgIHRoaXMubG9hZChwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIm9ucy1zcGxpdHRlci1jb250ZW50XCIgbXVzdCBoYXZlIFwib25zLXNwbGl0dGVyXCIgYXMgcGFyZW50Tm9kZS5gKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHBhZ2UgdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBlbGVtZW50IGxvYWRlZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihsb2FkZXIpIHtcbiAgICBpZiAoIShsb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBhZ2VMb2FkZXInKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UsIFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHBhZ2Ugc3BlY2lmaWVkIGluIGBwYWdlYCBpbiB0aGUgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IGA8b25zLXBhZ2U+YCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdYDxvbnMtcGFnZT5g6KaB57Sg44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IG9sZENvbnRlbnQgPSB0aGlzLl9jb250ZW50IHx8IG51bGw7XG5cbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAob2xkQ29udGVudCkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIG9sZENvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG5cbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5fY29udGVudC5fc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5fY29udGVudC5faGlkZSgpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLWNvbnRlbnQnLCBTcGxpdHRlckNvbnRlbnRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJNYXNrRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHNpZGUuY2xvc2UoJ2xlZnQnKS5jYXRjaCgoKSA9PiB7fSkpO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLW1hc2snLCBTcGxpdHRlck1hc2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcbiAgICAgIGR1cmF0aW9uOiAnMC4zJyxcbiAgICAgIGRlbGF5OiAnMCdcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHVwZGF0ZU9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdXRpbC5leHRlbmQodGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5fdGltaW5nID0gdGhpcy5fb3B0aW9ucy50aW1pbmc7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl9vcHRpb25zLmR1cmF0aW9uO1xuICAgIHRoaXMuX2RlbGF5ID0gdGhpcy5fb3B0aW9ucy5kZWxheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNpZGVFbGVtZW50XG4gICAqL1xuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIGNvbnN0IHNwbGl0dGVyID0gc2lkZUVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2lkZSA9IHNpZGVFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGVudCA9IHNwbGl0dGVyLmNvbnRlbnQ7XG4gICAgICB0aGlzLl9tYXNrID0gc3BsaXR0ZXIubWFzaztcbiAgICB9KTtcbiAgfVxuXG4gIGluYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IHRoaXMuX3NpZGUgPSB0aGlzLl9tYXNrID0gbnVsbDtcbiAgfVxuXG4gIGdldCBtaW51cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5fc2lkZSA9PT0gJ3JpZ2h0JyA/ICctJyA6ICcnO1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAucXVldWUoe1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXN9MTAwJSwgMHB4LCAwcHgpYFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy5fdGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5fZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLl90aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uLy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgZGVmYXVsdDogU3BsaXR0ZXJBbmltYXRvcixcbiAgb3ZlcmxheTogU3BsaXR0ZXJBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXJcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNvbXBvbmVudCB0aGF0IGVuYWJsZXMgcmVzcG9uc2l2ZSBsYXlvdXQgYnkgaW1wbGVtZW50aW5nIGJvdGggYSB0d28tY29sdW1uIGxheW91dCBhbmQgYSBzbGlkaW5nIG1lbnUgbGF5b3V0LlxuICpcbiAqICAgIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgZXhwYW5kIGludG8gYSBjb2x1bW4gbGF5b3V0IG9uIGxhcmdlIHNjcmVlbnMgYW5kIGNvbGxhcHNlIHRoZSBtZW51IG9uIHNtYWxsZXIgc2NyZWVucy4gV2hlbiB0aGUgbWVudSBpcyBjb2xsYXBzZWQgdGhlIHVzZXIgY2FuIG9wZW4gaXQgYnkgc3dpcGluZy5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFdTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlciBpZD1cInNwbGl0dGVyXCI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2Ugc3dpcGVhYmxlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNwbGl0dGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwbGl0dGVyJyk7XG4gKiAgIHNwbGl0dGVyLmxlZnQub3BlbigpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBfZ2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGUgPT4ge1xuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZSwgJ29ucy1zcGxpdHRlci1zaWRlJykgJiYgZS5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gc2lkZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbGVmdFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTGVmdCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ2xlZnQnKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IHJpZ2h0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SaWdodCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdyaWdodCcpO1xuICB9XG5cbiAgZ2V0IF9zaWRlcygpIHtcbiAgICByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy5yaWdodF0uZmlsdGVyKGUgPT4gZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjb250ZW50XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLWNvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIHRoaXMuX3NpZGVzLnNvbWUocyA9PiBzLmlzT3BlbiA/IHMuY2xvc2UoKSA6IGZhbHNlKSB8fCBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICB9XG5cbiAgX29uTW9kZUNoYW5nZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2xheW91dCgpIHtcbiAgICB0aGlzLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3NpZGUuc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLl93aWR0aCA6IDA7XG4gICAgfSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlID0gdGhpcy5fb25Nb2RlQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMubWFzaykge1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBTcGxpdHRlckFuaW1hdG9yLicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNwbGl0dGVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFNwbGl0dGVyQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlcicsIFNwbGl0dGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuLi9vbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb25zLXNwbGl0dGVyL2FuaW1hdG9yJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IFNwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XG5cbmNvbnN0IFNQTElUX01PREUgPSAnc3BsaXQnO1xuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTE9TRURfU1RBVEUgPSAnY2xvc2VkJztcbmNvbnN0IE9QRU5fU1RBVEUgPSAnb3Blbic7XG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XG5cbmNvbnN0IFdBVENIRURfQVRUUklCVVRFUyA9IFsnYW5pbWF0aW9uJywgJ3dpZHRoJywgJ3NpZGUnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ3N3aXBlLXRhcmdldC13aWR0aCcsICdhbmltYXRpb24tb3B0aW9ucycsICdvcGVuLXRocmVzaG9sZCddO1xuXG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShzcGxpdHRlclNpZGVFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmNsYXNzIENvbGxhcHNlRGV0ZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGFyZ2V0ICYmIHRoaXMuY2hhbmdlVGFyZ2V0KHRhcmdldCk7XG4gIH1cblxuICBjaGFuZ2VUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXS5pbmRleE9mKHRhcmdldCkgIT09IC0xO1xuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9tYXRjaCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldCA9PT0gKHZhbHVlLmlzUG9ydHJhaXQgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubWF0Y2hlcztcbiAgfVxuXG4gIF9vbkNoYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZU1vZGUodGhpcy5fbWF0Y2godmFsdWUpID8gQ09MTEFQU0VfTU9ERSA6IFNQTElUX01PREUpO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh7aXNQb3J0cmFpdDogb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gd2luZG93Lm1hdGNoTWVkaWEodGhpcy5fdGFyZ2V0KTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LmFkZExpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fcXVlcnlSZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcXVlcnlSZXN1bHQpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgsIHBhcmVudCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKHBhcmVudC5vZmZzZXRXaWR0aCAqIHZhbHVlIC8gMTAwKTtcbn07XG5cbmNsYXNzIENvbGxhcHNlTW9kZSB7XG4gIGdldCBfYW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuX2FuaW1hdG9yO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2xvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XG4gIH1cblxuICBoYW5kbGVHZXN0dXJlKGUpIHtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9sb2NrLmlzTG9ja2VkKCkgfHwgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICB0aGlzLl9vbkRyYWdTdGFydChlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBlLnR5cGUgPT09ICdkcmFnZW5kJyA/IHRoaXMuX29uRHJhZ0VuZChlKSA6IHRoaXMuX29uRHJhZyhlKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBzY3JvbGxpbmcgPSAhL2xlZnR8cmlnaHQvLnRlc3QoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24pO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZWxlbWVudC5fc2lkZSA9PT0gJ2xlZnQnID8gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WCA6IHdpbmRvdy5pbm5lcldpZHRoIC0gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5fZWxlbWVudC5fc3dpcGVUYXJnZXRXaWR0aDtcbiAgICBjb25zdCBpc09wZW4gPSB0aGlzLmlzT3BlbigpO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBzY3JvbGxpbmcgfHwgKGFyZWEgJiYgZGlzdGFuY2UgPiBhcmVhICYmICFpc09wZW4pO1xuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFRvUHgodGhpcy5fZWxlbWVudC5fd2lkdGgsIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgdGhpcy5fc3RhcnREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlID0gaXNPcGVuID8gdGhpcy5fd2lkdGggOiAwO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSk7XG4gICAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qge19kaXN0YW5jZTogZGlzdGFuY2UsIF93aWR0aDogd2lkdGgsIF9lbGVtZW50OiBlbH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50Lmdlc3R1cmUuaW50ZXJpbURpcmVjdGlvbjtcbiAgICBjb25zdCBzaG91bGRPcGVuID0gZWwuX3NpZGUgIT09IGRpcmVjdGlvbiAmJiBkaXN0YW5jZSA+IHdpZHRoICogZWwuX3RocmVzaG9sZDtcbiAgICB0aGlzLmV4ZWN1dGVBY3Rpb24oc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScpO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnRlciBjb2xsYXBzZSBtb2RlXG4gIGVudGVyTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhpdCBjb2xsYXBzZSBtb2RlXG4gIGV4aXRNb2RlKCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgX2lzT3Blbk90aGVyU2lkZU1lbnUoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2VsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbikuc29tZShlID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGUsICdvbnMtc3BsaXR0ZXItc2lkZScpICYmIGUgIT09IHRoaXMuX2VsZW1lbnQgJiYgZS5pc09wZW47XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSAnb3Blbicgb3IgJ2Nsb3NlJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRBbmltYXRpb25dXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVcbiAgICovXG4gIGV4ZWN1dGVBY3Rpb24obmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgRklOQUxfU1RBVEUgPSBuYW1lID09PSAnb3BlbicgPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gRklOQUxfU1RBVEUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sb2NrLmlzTG9ja2VkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BsaXR0ZXIgc2lkZSBpcyBsb2NrZWQuJyk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnb3BlbicgJiYgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgbWVudSBpcyBhbHJlYWR5IG9wZW4uJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbGVtZW50Ll9lbWl0RXZlbnQoYHByZSR7bmFtZX1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke25hbWV9IGV2ZW50LmApO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9sb2NrLmxvY2soKTtcbiAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUgPSBGSU5BTF9TVEFURTtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICB1bmxvY2soKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuX2VtaXRFdmVudChgcG9zdCR7bmFtZX1gKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLndpdGhvdXRBbmltYXRpb24pIHtcbiAgICAgIGRvbmUoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fYW5pbWF0b3JbbmFtZV0oKCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlci1zaWRlXG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IGlzIHVzZWQgYXMgYSBjaGlsZCBlbGVtZW50IG9mIGA8b25zLXNwbGl0dGVyPmAuXG4gKlxuICogICAgSXQgd2lsbCBiZSBkaXNwbGF5ZWQgb24gZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50LlxuICpcbiAqICAgIEl0IHN1cHBvcnRzIHR3byBtb2RlczogY29sbGFwc2VkIGFuZCBzcGxpdC4gV2hlbiBpdCdzIGluIGNvbGxhcHNlZCBtb2RlIGl0IHdpbGwgYmUgaGlkZGVuIGZyb20gdmlldyBhbmQgY2FuIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIHN3aXBlcyB0aGUgc2NyZWVuIG9yIHRhcHMgYSBidXR0b24uIEluIHNwbGl0IG1vZGUgdGhlIGVsZW1lbnQgaXMgYWx3YXlzIHNob3duLiBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCBiZXR3ZWVuIHRoZSB0d28gbW9kZXMgZGVwZW5kaW5nIG9uIHRoZSBzY3JlZW4gc2l6ZS5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgaXMgdGhlIHBhcmVudCBjb21wb25lbnQuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJTaWRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IG1vZGVjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIG1vZGUgY2hhbmdlcy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7jg6Ljg7zjg4njgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50Lm1vZGVcbiAgICogICBbZW5dUmV0dXJucyB0aGUgY3VycmVudCBtb2RlLiBDYW4gYmUgZWl0aGVyIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nIG1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZy1tZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgIGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uLiBVc2Ugb25lIG9mIGBcIm92ZXJsYXlcImAsIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCXCJvdmVybGF5XCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9wZW4tdGhyZXNob2xkXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0ICAwLjNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgbWVudSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIG9wZW5pbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXeOBqeOBruOBj+OCieOBhOOCueODr+OCpOODl+OBmeOCjOOBsOOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOCkumWi+OBj+OBi+OBqeOBhuOBi+OBruWJsuWQiOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokx44Gu6ZaT44Gu5pWw5YCk44KS5oyH5a6a44GX44G+44GZ44CC44K544Ov44Kk44OX44Gu6Led6Zui44GM44GT44GT44Gn5oyH5a6a44GX44Gf5pWw5YCk5o6b44GR44KL44GT44Gu6KaB57Sg44Gu5bmF44KI44KK44KC5aSn44GN44GR44KM44Gw44CB44K544Ov44Kk44OX44GM57WC44KP44Gj44Gf5pmC44Gr44GT44Gu6KaB57Sg44KS6ZaL44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvMC4z44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sbGFwc2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU3BlY2lmeSB0aGUgY29sbGFwc2UgYmVoYXZpb3IuIFZhbGlkIHZhbHVlcyBhcmUgYFwicG9ydHJhaXRcImAsIGBcImxhbmRzY2FwZVwiYCBvciBhIG1lZGlhIHF1ZXJ5LlxuICAgKiAgICAgVGhlIHN0cmluZ3MgYFwicG9ydHJhaXRcImAgYW5kIGBcImxhbmRzY2FwZVwiYCBtZWFucyB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gZGV2aWNlIGlzIGluIGxhbmRzY2FwZSBvciBwb3J0cmFpdCBvcmllbnRhdGlvbi5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBhIG1lZGlhIHF1ZXJ5LCB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gdGhlIG1lZGlhIHF1ZXJ5IHJlc29sdmVzIHRvIGB0cnVlYC5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCwgdGhlIHZpZXcgYWx3YXlzIGJlIGluIGBcImNvbGxhcHNlXCJgIG1vZGUuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDlt6blgbTjga7jg5rjg7zjgrjjgpLpnZ7ooajnpLrjgavjgZnjgovmnaHku7bjgpLmjIflrprjgZfjgb7jgZnjgIJwb3J0cmFpdCwgbGFuZHNjYXBl44CBd2lkdGggI3B444KC44GX44GP44Gv44Oh44OH44Kj44Ki44Kv44Ko44Oq44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCXG4gICAqICAgICBwb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBmeOCi+OBqOOAgeODh+ODkOOCpOOCueOBrueUu+mdouOBjOe4puWQkeOBjeOCguOBl+OBj+OBr+aoquWQkeOBjeOBq+OBquOBo+OBn+aZguOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44Oh44OH44Kj44Ki44Kv44Ko44Oq44KS5oyH5a6a44GZ44KL44Go44CB5oyH5a6a44GX44Gf44Kv44Ko44Oq44Gr6YGp5ZCI44GX44Gm44GE44KL5aC05ZCI44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDlgKTjgavkvZXjgoLmjIflrprjgZfjgarjgYTloLTlkIjjgavjga/jgIHluLjjgatjb2xsYXBzZeODouODvOODieOBq+OBquOCiuOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6/jgqTjg5fjga7liKTlrprpoJjln5/jgpLjg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgZfjgb7jgZnjgILnlLvpnaLjga7nq6/jgYvjgonmjIflrprjgZfjgZ/ot53pm6LjgavpgZTjgZnjgovjgajjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB3aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2FuIGJlIHNwZWNpZmllZCBpbiBlaXRoZXIgcGl4ZWxzIG9yIGFzIGEgcGVyY2VudGFnZSwgZS5nLiBgOTAlYCBvciBgMjAwcHhgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruaoquW5heOCkuaMh+WumuOBl+OBvuOBmeOAgnB444GoJeOBp+OBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAgmVnLiA5MCUsIDIwMHB4Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2lkZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBsZWZ0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoaWNoIHNpZGUgb2YgdGhlIHNjcmVlbiB0aGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgbG9jYXRlZC4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjgYzlt6bjgYvlj7PjgYvjgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovlgKTjga9cImxlZnRcIuOBi1wicmlnaHRcIuOBruOBv+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC4gVGhpcyBhdHRyaWJ1dGUgaXMgcmVhZCBvbmx5LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOBjOioreWumuOBleOCjOOBvuOBmeOAglwiY29sbGFwc2VcIuOCguOBl+OBj+OBr1wic3BsaXRcIuOBjOaMh+WumuOBleOCjOOBvuOBmeOAguOBk+OBruWxnuaAp+OBr+iqreOBv+i+vOOBv+WwgueUqOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgVVJMIG9mIHRoZSBtZW51IHBhZ2UuWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRvIGVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbiBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ5pmC44Gr44K544Ov44Kk44OX5pON5L2c44KS5pyJ5Yq544Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9wYWdlID0gbnVsbDtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fY29sbGFwc2VNb2RlID0gbmV3IENvbGxhcHNlTW9kZSh0aGlzKTtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBTcGxpdHRlckVsZW1lbnQuYW5pbWF0b3JzLFxuICAgICAgYmFzZUNsYXNzOiBTcGxpdHRlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1NwbGl0dGVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gICAgdGhpcy5fYm91bmRIYW5kbGVHZXN0dXJlID0gKGUpID0+IHRoaXMuX2NvbGxhcHNlTW9kZS5oYW5kbGVHZXN0dXJlKGUpO1xuICAgIHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzID0gV0FUQ0hFRF9BVFRSSUJVVEVTO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWQocGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBtdXN0IGJlIGFuIG9ucy1zcGxpdHRlciBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5wYXJlbnRFbGVtZW50LCB7ZHJhZ01pbkRpc3RhbmNlOiAxfSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fd2F0Y2hlZEF0dHJpYnV0ZXMuZm9yRWFjaChlID0+IHRoaXMuX3VwZGF0ZShlKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdzaWRlJykpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzaWRlJywgJ2xlZnQnKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgZ2V0IHNpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzaWRlJykgPT09ICdyaWdodCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBXQVRDSEVEX0FUVFJJQlVURVM7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZShuYW1lLCBjdXJyZW50KTtcbiAgfVxuXG4gIF91cGRhdGUobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gJ191cGRhdGUnICsgbmFtZS5zcGxpdCgnLScpLm1hcChlID0+IGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSkpLmpvaW4oJycpO1xuICAgIHJldHVybiB0aGlzW25hbWVdKHZhbHVlKTtcbiAgfVxuXG4gIF9lbWl0RXZlbnQobmFtZSkge1xuICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpICE9PSAncHJlJykge1xuICAgICAgcmV0dXJuIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7c2lkZTogdGhpc30pO1xuICAgIH1cbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIG5hbWUsIHtcbiAgICAgIHNpZGU6IHRoaXMsXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF91cGRhdGVDb2xsYXBzZSh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xsYXBzZScpKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnc3BsaXQnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShTUExJVF9NT0RFKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ2NvbGxhcHNlJykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoQ09MTEFQU0VfTU9ERSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uY2hhbmdlVGFyZ2V0KHZhbHVlKTtcbiAgfVxuXG4gIC8vIHJlYWRvbmx5IGF0dHJpYnV0ZSBmb3IgdGhlIHVzZXJzXG4gIF91cGRhdGVNb2RlKG1vZGUpIHtcbiAgICBpZiAobW9kZSAhPT0gdGhpcy5fbW9kZSkge1xuICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLl9jb2xsYXBzZU1vZGVbbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSA/ICdlbnRlck1vZGUnIDogJ2V4aXRNb2RlJ10oKTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgbW9kZSk7XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnbW9kZWNoYW5nZScsIHtzaWRlOiB0aGlzLCBtb2RlOiBtb2RlfSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZU9wZW5UaHJlc2hvbGQodGhyZXNob2xkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29wZW4tdGhyZXNob2xkJykpIHtcbiAgICB0aGlzLl90aHJlc2hvbGQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMC4zKSk7XG4gIH1cblxuICBfdXBkYXRlU3dpcGVhYmxlKHN3aXBlYWJsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZWFibGUnKSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHN3aXBlYWJsZSA9PT0gbnVsbCA/ICdvZmYnIDogJ29uJztcblxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnc3RhcnQgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWdlbmQnLCB0aGlzLl9ib3VuZEhhbmRsZUdlc3R1cmUpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVTd2lwZVRhcmdldFdpZHRoKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpKSB7XG4gICAgdGhpcy5fc3dpcGVUYXJnZXRXaWR0aCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIF91cGRhdGVXaWR0aCgpIHtcbiAgICB0aGlzLnN0eWxlLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIH1cblxuICBnZXQgX3dpZHRoKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgcmV0dXJuIC9eXFxkKyhweHwlKSQvLnRlc3Qod2lkdGgpID8gd2lkdGggOiAnODAlJztcbiAgfVxuXG4gIHNldCBfd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB2YWx1ZSk7XG4gIH1cblxuICBfdXBkYXRlU2lkZShzaWRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSkge1xuICAgIHRoaXMuX3NpZGUgPSBzaWRlID09PSAncmlnaHQnID8gc2lkZSA6ICdsZWZ0JztcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb24oYW5pbWF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Ioe2FuaW1hdGlvbn0pO1xuICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbk9wdGlvbnModmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yLnVwZGF0ZU9wdGlvbnMoQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBsb2NhdGlvbiB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBzaWRlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpc09wZW5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmlzT3BlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb3BlblxuICAgKiBAc2lnbmF0dXJlIG9wZW4oW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBvcGVuKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU1vZGUuZXhlY3V0ZUFjdGlvbignb3BlbicsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvc2VcbiAgICogQHNpZ25hdHVyZSBjbG9zZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBjbG9zZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmV4ZWN1dGVBY3Rpb24oJ2Nsb3NlJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVucyBpZiBpdCdzIGNsb3NlZC4gQ2xvc2VzIGlmIGl0J3Mgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV3plovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplonjgZjjgb7jgZnjgZ3jgZfjgabplovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW4gPyB0aGlzLmNsb3NlKG9wdGlvbnMpIDogdGhpcy5vcGVuKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBwYWdlVXJsIGluIHRoZSByaWdodCBzZWN0aW9uWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgKCgpID0+IHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuX2NvbnRlbnQuX3Nob3coKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2NvbnRlbnQpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1zaWRlJywgU3BsaXR0ZXJTaWRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3dpdGNoLS0qJyxcbiAgJy5zd2l0Y2hfX2lucHV0JzogJ3N3aXRjaC0tKl9faW5wdXQnLFxuICAnLnN3aXRjaF9faGFuZGxlJzogJ3N3aXRjaC0tKl9faGFuZGxlJyxcbiAgJy5zd2l0Y2hfX3RvZ2dsZSc6ICdzd2l0Y2gtLSpfX3RvZ2dsZSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVGcmFnbWVudChgXG4gIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInN3aXRjaF9faW5wdXRcIj5cbiAgPGRpdiBjbGFzcz1cInN3aXRjaF9fdG9nZ2xlXCI+XG4gICAgPGRpdiBjbGFzcz1cInN3aXRjaF9faGFuZGxlXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoX190b3VjaFwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBsb2NhdGlvbnMgPSB7XG4gIGlvczogWzEsIDIxXSxcbiAgbWF0ZXJpYWw6IFswLCAxNl1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXN3aXRjaFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU3dpdGNoIGNvbXBvbmVudC4gVGhlIHN3aXRjaCBjYW4gYmUgdG9nZ2xlZCBib3RoIGJ5IGRyYWdnaW5nIGFuZCB0YXBwaW5nLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc3dpdGNoIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzd2l0Y2hbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIExwWFpRUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3N3aXRjaFxuICogQGd1aWRlIGFkZGluZy1wYWdlLWNvbnRlbnRcbiAqICAgW2VuXVVzaW5nIGZvcm0gY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV3jg5Xjgqnjg7zjg6DjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3dpdGNoIGNoZWNrZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggZGlzYWJsZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggbW9kaWZpZXI9XCJtYXRlcmlhbFwiPjwvb25zLXN3aXRjaD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2hFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzd2l0Y2ggaXMgdG9nZ2xlZC5bL2VuXVxuICAgKiAgIFtqYV1PTi9PRkbjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zd2l0Y2hcbiAgICogICBbZW5dU3dpdGNoIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9Td2l0Y2jjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnZhbHVlXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc0ludGVyYWN0aXZlXG4gICAqICAgW2VuXVRydWUgaWYgdGhlIGNoYW5nZSB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyIGNsaWNraW5nIG9uIHRoZSBzd2l0Y2guWy9lbl1cbiAgICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44Gq44Gp44Gu44Om44O844K244Gu5pON5L2c44Gr44KI44Gj44Gm5aSJ44KP44Gj44Gf5aC05ZCI44Gr44GvdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBzd2l0Y2guWy9lbl1cbiAgICogIFtqYV3jgrnjgqTjg4Pjg4Hjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOCkueEoeWKueOBrueKtuaFi+OBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNoZWNrZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu54q25oWL44Gr44GZ44KL44Go44GN44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGBpZGAgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgaWYgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2NoZWNrZWQgPSAhIXZhbHVlO1xuICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjaGVja2VkJywgdGhpcy5fY2hlY2tlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9ICEhdmFsdWU7XG4gICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdGhpcy5fZGlzYWJsZWQpO1xuICAgIHRoaXMuX2NoZWNrYm94LmRpc2FibGVkID0gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrYm94XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgdW5kZXJseWluZyBjaGVja2JveCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOWGhemDqOOBrmNoZWNrYm946KaB57Sg44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBjaGVja2JveCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tib3g7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgWydjaGVja2VkJywgJ2Rpc2FibGVkJywgJ21vZGlmaWVyJywgJ25hbWUnLCAnaW5wdXQtaWQnXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gnKTtcblxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcuc3dpdGNoX19pbnB1dCcpICYmIHV0aWwuZmluZENoaWxkKHRoaXMsICcuc3dpdGNoX190b2dnbGUnKSkpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl9jaGVja2JveCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnN3aXRjaF9faW5wdXQnKTtcbiAgICB0aGlzLl9oYW5kbGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zd2l0Y2hfX2hhbmRsZScpO1xuXG4gICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuX2NoZWNrZWQ7XG4gICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7ZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxfSk7XG4gICAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NoZWNrZWQnLCB0aGlzLmNoZWNrYm94LmNoZWNrZWQpO1xuICB9XG5cbiAgX29uQ2xpY2soZXYpIHtcbiAgICBpZiAoZXYudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc3dpdGNoX190b3VjaCcpKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGNsaWNrKCkge1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlJywge1xuICAgICAgICB2YWx1ZTogdGhpcy5jaGVja2VkLFxuICAgICAgICBzd2l0Y2g6IHRoaXMsXG4gICAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICByZXR1cm4gTWF0aC5taW4obFsxXSwgTWF0aC5tYXgobFswXSwgdGhpcy5fc3RhcnRYICsgZS5nZXN0dXJlLmRlbHRhWCkpO1xuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2xvY2F0aW9uc1t0aGlzLmNoZWNrZWQgPyAxIDogMF07Ly8gLSBlLmdlc3R1cmUuZGVsdGFYO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5nZXN0dXJlLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSB0aGlzLl9nZXRQb3NpdGlvbihlKSArICdweCc7XG4gIH1cblxuICBfb25SZWxlYXNlKGUpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oZSk7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY2hlY2tlZDtcblxuICAgIHRoaXMuY2hlY2tlZCA9IHBvc2l0aW9uID49IChsWzBdICsgbFsxXSkgLyAyO1xuXG4gICAgaWYgKHRoaXMuY2hlY2tlZCAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2UnLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmNoZWNrZWQsXG4gICAgICAgIHN3aXRjaDogdGhpcyxcbiAgICAgICAgaXNJbnRlcmFjdGl2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuXG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdpbnB1dC1pZCcsICdjaGVja2VkJywgJ2Rpc2FibGVkJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgICAgdGhpcy5faXNNYXRlcmlhbCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcbiAgICAgICAgICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnNbdGhpcy5faXNNYXRlcmlhbCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgICB0aGlzLl9jaGVja2JveC5pZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICAgIHRoaXMuX2NoZWNrYm94LmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jaGVja2JveC5kaXNhYmxlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXN3aXRjaCcsIFN3aXRjaEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGNsYXNzIFRhYmJhckFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogJzAuNCc7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbnRlclBhZ2Ugb25zLXBhZ2UgZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGxlYXZlUGFnZSBvbnMtcGFnZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbnRlclBhZ2VJbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVhdmVQYWdlSW5kZXhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVyUGFnZUluZGV4LCBsZWF2ZVBhZ2VJbmRleCwgZG9uZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBUYWJiYXJOb25lQW5pbWF0b3IgZXh0ZW5kcyBUYWJiYXJBbmltYXRvciB7XG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XG4gICAgc2V0VGltZW91dChkb25lLCAxMDAwIC8gNjApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUYWJiYXJGYWRlQW5pbWF0b3IgZXh0ZW5kcyBUYWJiYXJBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGltaW5nIDogJ2xpbmVhcic7XG4gICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC40JztcbiAgICBvcHRpb25zLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6ICcwJztcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVyUGFnZUluZGV4LCBsZWF2ZVBhZ2VJbmRleCwgZG9uZSkge1xuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmJhclNsaWRlQW5pbWF0b3IgZXh0ZW5kcyBUYWJiYXJBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGltaW5nIDogJ2Vhc2UtaW4nO1xuICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogJzAuMTUnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogJzAnO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtqcUxpdGV9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge2pxTGl0ZX0gbGVhdmVQYWdlXG4gICAqL1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJJbmRleCwgbGVhdmVJbmRleCwgZG9uZSkge1xuICAgIGNvbnN0IHNnbiA9IGVudGVySW5kZXggPiBsZWF2ZUluZGV4O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAoc2duID8gJycgOiAnLScpICsgJzEwMCUsIDAsIDApJyxcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgnICsgKHNnbiA/ICctJyA6ICcnKSArICcxMDAlLCAwLCAwKScsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uLy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHtUYWJiYXJBbmltYXRvciwgVGFiYmFyRmFkZUFuaW1hdG9yLCBUYWJiYXJOb25lQW5pbWF0b3IsIFRhYmJhclNsaWRlQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IFRhYkVsZW1lbnQgZnJvbSAnLi4vb25zLXRhYic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRhYi1iYXJfX2NvbnRlbnQnOiAndGFiLWJhci0tKl9fY29udGVudCcsXG4gICcudGFiLWJhcic6ICd0YWItYmFyLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBUYWJiYXJOb25lQW5pbWF0b3IsXG4gICdmYWRlJzogVGFiYmFyRmFkZUFuaW1hdG9yLFxuICAnc2xpZGUnOiBUYWJiYXJTbGlkZUFuaW1hdG9yLFxuICAnbm9uZSc6IFRhYmJhck5vbmVBbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHRhYmJhckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtdGFiYmFyLWdlbi0nICsgKGkrKyk7XG59KSgpO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJiYXJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQSBjb21wb25lbnQgdG8gZGlzcGxheSBhIHRhYiBiYXIgb24gdGhlIGJvdHRvbSBvZiBhIHBhZ2UuIFVzZWQgd2l0aCBgPG9ucy10YWI+YCB0byBtYW5hZ2UgcGFnZXMgdXNpbmcgdGFicy5bL2VuXVxuICogICBbamFd44K/44OW44OQ44O844KS44Oa44O844K45LiL6YOo44Gr6KGo56S644GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCb25zLXRhYuOBqOe1hOOBv+WQiOOCj+OBm+OBpuS9v+OBhuOBk+OBqOOBp+OAgeODmuODvOOCuOOCkueuoeeQhuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtdGFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gKiAgIFtlbl1UaGUgYDxvbnMtcGFnZT5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGFiYmFyPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJob21lLmh0bWxcIlxuICogICAgIGxhYmVsPVwiSG9tZVwiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cInNldHRpbmdzLmh0bWxcIlxuICogICAgIGxhYmVsPVwiU2V0dGluZ3NcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogPC9vbnMtdGFiYmFyPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwic2V0dGluZ3MuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGJlZm9yZSB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgY2hhbmdlIGV2ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBruWkieabtOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBhZnRlciB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44Gj44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBpZiB0aGUgYWxyZWFkeSBvcGVuIHRhYiBpcyB0YXBwZWQgYWdhaW4uWy9lbl1cbiAgICogICBbamFd44GZ44Gn44Gr44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44GM44KC44GG5LiA5bqm44K/44OD44OX44KE44Kv44Oq44OD44Kv44GV44KM44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbm9uZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSB2YWx1ZXMgYXJlIGBcIm5vbmVcImAsIGBcInNsaWRlXCJgIGFuZCBgXCJmYWRlXCJgLiBEZWZhdWx0IGlzIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Oa44O844K46Kqt44G/6L6844G/5pmC44Gu44Ki44OL44Oh44O844K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgIFcImZhZGVcIuOAgVwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkumBuOaKnuOBp+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wibm9uZVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBib3R0b21cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRhYmJhcidzIHBvc2l0aW9uLiBBdmFpbGFibGUgdmFsdWVzIGFyZSBgXCJib3R0b21cImAgYW5kIGBcInRvcFwiYC4gVXNlIGBcImF1dG9cImAgdG8gY2hvb3NlIHBvc2l0aW9uIGRlcGVuZGluZyBvbiBwbGF0Zm9ybSAoaU9TIGJvdHRvbSwgQW5kcm9pZCB0b3ApLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglwiYm90dG9tXCLjgoLjgZfjgY/jga9cInRvcFwi44KS6YG45oqe44Gn44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJib3R0b21cIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fdGFiYmFySWQgPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuXG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udGVudC5jaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpO1xuXG4gICAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXJFbGVtZW50O1xuICAgICAgaWYgKGFjdGl2ZUluZGV4ICYmIHRhYmJhci5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCkge1xuICAgICAgICB0YWJiYXIuY2hpbGRyZW5bYWN0aXZlSW5kZXhdLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ3RydWUnKTtcbiAgICAgIH1cblxuICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICAgIGJhc2VDbGFzczogVGFiYmFyQW5pbWF0b3IsXG4gICAgICAgIGJhc2VDbGFzc05hbWU6ICdUYWJiYXJBbmltYXRvcicsXG4gICAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gIH1cblxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfdGFiYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudEVsZW1lbnQgJiYgdGhpcy5fdGFiYmFyRWxlbWVudCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fY29udGVudCcpO1xuICAgICAgY29uc3QgYmFyID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyJyk7XG5cbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb25zLXRhYi1iYXJfX2NvbnRlbnQnKTtcbiAgICAgIGJhci5jbGFzc0xpc3QuYWRkKCdvbnMtdGFiLWJhcl9fZm9vdGVyJyk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuY3JlYXRlKCcub25zLXRhYi1iYXJfX2NvbnRlbnQudGFiLWJhcl9fY29udGVudCcpO1xuICAgICAgY29uc3QgdGFiYmFyID0gdXRpbC5jcmVhdGUoJy50YWItYmFyLm9ucy10YWItYmFyX19mb290ZXInKTtcblxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0YWJiYXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFiYmFyKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSkge1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuX3RvcCA9IHBvc2l0aW9uID09PSAndG9wJyB8fCAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSk7XG4gICAgY29uc3QgYWN0aW9uID0gdG9wID8gdXRpbC5hZGRNb2RpZmllciA6IHV0aWwucmVtb3ZlTW9kaWZpZXI7XG5cbiAgICBhY3Rpb24odGhpcywgJ3RvcCcpO1xuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXRvcCcpIDogJyc7XG5cbiAgICAgIGlmICh1dGlsLm1hdGNoKHBhZ2UuZmlyc3RDaGlsZCwgJ29ucy10b29sYmFyJykpIHtcbiAgICAgICAgYWN0aW9uKHBhZ2UuZmlyc3RDaGlsZCwgJ25vc2hhZG93Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLCB0b3AgJiYgIWZpbGxlZCk7XG4gICAgfSk7XG4gIH1cblxuICBfZ2V0VGFiYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkUGFnZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAc2lnbmF0dXJlIGxvYWRQYWdlKHVybCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYW4gYDxvbnMtdGVtcGxhdGU+YCBpZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44GfaWTlsZ7mgKfjga7lgKTjgpLliKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheXMgYSBuZXcgcGFnZSB3aXRob3V0IGNoYW5naW5nIHRoZSBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Ki44Kv44OG44Kj44OW44Gq44Kk44Oz44OH44OD44Kv44K544KS5aSJ5pu044Gb44Ga44Gr44CB5paw44GX44GE44Oa44O844K444KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBsb2FkUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zb2xlLndhcm4oJ1RoZSBsb2FkUGFnZSBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1pbm9yIHZlcnNpb24uJyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCB0YWIgPSB0aGlzLl90YWJiYXJFbGVtZW50LmNoaWxkcmVuWzBdIHx8IG5ldyBUYWJFbGVtZW50KCk7XG4gICAgICB0YWIuX2xvYWRQYWdlKHBhZ2UsIHRoaXMuX2NvbnRlbnRFbGVtZW50LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHJlc29sdmUodGhpcy5fbG9hZFBhZ2VET01Bc3luYyhwYWdlRWxlbWVudCwgb3B0aW9ucykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYWdlRWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuXG4gICAqL1xuICBfbG9hZFBhZ2VET01Bc3luYyhwYWdlRWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgICBpZiAodGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpICE9PSAtMSkge1xuICAgICAgICByZXNvbHZlKHRoaXMuX3N3aXRjaFBhZ2UocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29sZFBhZ2VFbGVtZW50ID0gcGFnZUVsZW1lbnQ7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldFRhYmJhcklkKCkge1xuICAgIHJldHVybiB0aGlzLl90YWJiYXJJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50L251bGx9XG4gICAqL1xuICBfZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCkge1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgbGV0IHBhZ2UgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYWdlc1tpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgcGFnZSA9IHBhZ2VzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFnZSAmJiBwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogcGFnZSBlbGVtZW50IG11c3QgYmUgYSBcIm9ucy1wYWdlXCIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnZTtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbGVjdGVkVGFiSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJldmlvdXNUYWJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5cbiAgICovXG4gIF9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvbGRQYWdlRWxlbWVudCA9IHRoaXMuX29sZFBhZ2VFbGVtZW50IHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICAgIHRoaXMuX29sZFBhZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmIChvbGRQYWdlRWxlbWVudCAhPT0gaW50ZXJuYWwubnVsbEVsZW1lbnQpIHtcbiAgICAgICAgb2xkUGFnZUVsZW1lbnQuX2hpZGUoKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0b3IuYXBwbHkoZWxlbWVudCwgb2xkUGFnZUVsZW1lbnQsIG9wdGlvbnMuc2VsZWN0ZWRUYWJJbmRleCwgb3B0aW9ucy5wcmV2aW91c1RhYkluZGV4LCAoKSA9PiB7XG4gICAgICAgIGlmIChvbGRQYWdlRWxlbWVudCAhPT0gaW50ZXJuYWwubnVsbEVsZW1lbnQpIHtcbiAgICAgICAgICBvbGRQYWdlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgZWxlbWVudC5fc2hvdygpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVUYWJcbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVUYWIoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRhYiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5rZWVwUGFnZV1cbiAgICogICBbZW5dSWYgdHJ1ZSB0aGUgcGFnZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBjOePvuWcqOihqOekuuOBl+OBpuOBhOOCi3BhZ2XjgpLlpInjgYjjgarjgYTloLTlkIjjgavjga90cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgLCBgXCJzbGlkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJgXCJmYWRlXCJg44CBYFwic2xpZGVcImDjgIFgXCJub25lXCJg44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHNwZWNpZmllZCB0YWIgcGFnZS4gQW5pbWF0aW9ucyBhbmQgb3RoZXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBruOCv+ODluOCkuihqOekuuOBl+OBvuOBmeOAguOCouODi+ODoeODvOOCt+ODp+ODs+OBquOBqeOBruOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVUYWIoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYW5pbWF0aW9uICYmIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlvdXNUYWIgPSB0aGlzLl9nZXRBY3RpdmVUYWJFbGVtZW50KCksXG4gICAgICBzZWxlY3RlZFRhYiA9IHRoaXMuX2dldFRhYkVsZW1lbnQoaW5kZXgpLFxuICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSxcbiAgICAgIHNlbGVjdGVkVGFiSW5kZXggPSBpbmRleCxcbiAgICAgIHByZXZpb3VzUGFnZUVsZW1lbnQgPSB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcblxuICAgIGlmICghc2VsZWN0ZWRUYWIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkVGFiSW5kZXggPT09IHByZXZpb3VzVGFiSW5kZXgpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVhY3RpdmUnLCB7XG4gICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYlxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJldmlvdXNQYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWNoYW5nZScsIHtcbiAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWIsXG4gICAgICBjYW5jZWw6ICgpID0+IGNhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICBzZWxlY3RlZFRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICAgIHByZXZpb3VzVGFiLnNldEFjdGl2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVjaGFuZ2UgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRUYWIuc2V0QWN0aXZlKCk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcHJldmlvdXNUYWJJbmRleDogcHJldmlvdXNUYWJJbmRleCxcbiAgICAgIHNlbGVjdGVkVGFiSW5kZXg6IHNlbGVjdGVkVGFiSW5kZXhcbiAgICB9O1xuXG4gICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICBwcmV2aW91c1RhYi5zZXRJbmFjdGl2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHNlbGVjdGVkVGFiLl9sb2FkUGFnZUVsZW1lbnQodGhpcy5fY29udGVudEVsZW1lbnQsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgcGFnZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgIHRoaXMuX3N3aXRjaFBhZ2UocGFnZUVsZW1lbnQsIHBhcmFtcylcbiAgICAgICAgICAudGhlbihwYWdlID0+IHtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXG4gICAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocGFnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFRhYmJhclZpc2liaWxpdHlcbiAgICogQHNpZ25hdHVyZSBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlZCB0byBoaWRlIG9yIHNob3cgdGhlIHRhYiBiYXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX3RvcCA/ICd0b3AnIDogJ2JvdHRvbSddID0gdmlzaWJsZSA/ICcnIDogJzBweCc7XG4gICAgdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVUYWJJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZVRhYkluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRhYiBpbmRleCBvbiBjdXJyZW50IGFjdGl2ZSB0YWIuIElmIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAguePvuWcqOOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOOBquOBhOWgtOWQiOOBq+OBry0x44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZVRhYkluZGV4KCkge1xuICAgIGNvbnN0IHRhYnMgPSB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YWJzW2ldIGluc3RhbmNlb2YgVGFiRWxlbWVudCAmJiB0YWJzW2ldLmlzQWN0aXZlICYmIHRhYnNbaV0uaXNBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfSBXaGVuIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlxuICAgKi9cbiAgX2dldEFjdGl2ZVRhYkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRhYkVsZW1lbnQodGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgX2dldFRhYkVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuW2luZGV4XTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkgeyB9XG5cbiAgX3Nob3coKSB7XG4gICAgY29uc3QgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG4gICAgaWYgKGN1cnJlbnRQYWdlRWxlbWVudCkge1xuICAgICAgY3VycmVudFBhZ2VFbGVtZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgY29uc3QgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG4gICAgaWYgKGN1cnJlbnRQYWdlRWxlbWVudCkge1xuICAgICAgY3VycmVudFBhZ2VFbGVtZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgdGFicyA9IHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gdGFicy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFic1tpXS5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFRhYmJhckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBUYWJiYXJBbmltYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUYWJiYXJBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBUYWJiYXJFbGVtZW50LlRhYmJhckFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWJiYXInLCBUYWJiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IFRhYmJhckVsZW1lbnQgZnJvbSAnLi9vbnMtdGFiYmFyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3RhYi1iYXItLSpfX2l0ZW0nLFxuICAnLnRhYi1iYXJfX2J1dHRvbic6ICd0YWItYmFyLS0qX19idXR0b24nXG59O1xuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICA8ZGl2PlxuICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIj5cbiAgICA8YnV0dG9uIGNsYXNzPVwidGFiLWJhcl9fYnV0dG9uXCI+PC9idXR0b24+XG4gIDwvZGl2PlxuYCk7XG5jb25zdCBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2ljb25cIj5cbiAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLWNsb3VkXCI+PC9vbnMtaWNvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGFiLWJhcl9fbGFiZWxcIj5sYWJlbDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0YWItYmFyX19iYWRnZSBub3RpZmljYXRpb25cIj4xPC9kaXY+XG4gIDwvZGl2PlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYlxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgdGFiIGluc2lkZSB0YWIgYmFyLiBFYWNoIGA8b25zLXRhYj5gIHJlcHJlc2VudHMgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgr/jg5bjg5Djg7zjgavphY3nva7jgZXjgozjgovlkITjgqLjgqTjg4bjg6Djga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZ3jgozjgZ7jgozjga5vbnMtdGFi44Gv44Oa44O844K444KS6KGo44GX44G+44GZ44CCXG4gKiAgICAgb25zLXRhYuimgee0oOOBruS4reOBq+OBr+OAgeOCv+ODluOBq+ihqOekuuOBleOCjOOCi+OCs+ODs+ODhuODs+ODhOOCkuebtOaOpeiomOi/sOOBmeOCi+OBk+OBqOOBjOWHuuadpeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYmJhclxuICogICBbZW5db25zLXRhYmJhciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXRhYmJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5db25zLXBhZ2UgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pY29uXG4gKiAgIFtlbl1vbnMtaWNvbiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGFiYmFyPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJob21lLmh0bWxcIlxuICogICAgIGxhYmVsPVwiSG9tZVwiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cInNldHRpbmdzLmh0bWxcIlxuICogICAgIGxhYmVsPVwiU2V0dGluZ3NcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogPC9vbnMtdGFiYmFyPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwic2V0dGluZ3MuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYiBpcyB0YXBwZWQuWy9lbl1cbiAgICogICBbamFdb25zLXRhYuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZSBmb3IgdGhlIHRhYi4gQ2FuIHNwZWNpZnkgdGhlIHNhbWUgaWNvbiBuYW1lIGFzIGA8b25zLWljb24+YC5cbiAgICogICAgIElmIHlvdSBuZWVkIHRvIHVzZSB5b3VyIG93biBpY29uLCBjcmVhdGUgYSBDU1MgY2xhc3Mgd2l0aCBgYmFja2dyb3VuZC1pbWFnZWAgb3IgYW55IENTUyBwcm9wZXJ0aWVzIGFuZCBzcGVjaWZ5IHRoZSBuYW1lIG9mIHlvdXIgQ1NTIGNsYXNzIGhlcmUuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJvbnMtaWNvbuOBqOWQjOOBmOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgICAg5YCL5Yil44Gr44Ki44Kk44Kz44Oz44KS44Kr44K544K/44Oe44Kk44K644GZ44KL5aC05ZCI44Gv44CBYmFja2dyb3VuZC1pbWFnZeOBquOBqeOBrkNTU+OCueOCv+OCpOODq+OCkueUqOOBhOOBpuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZS1pY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbmFtZSBvZiB0aGUgaWNvbiB3aGVuIHRoZSB0YWIgaXMgYWN0aXZlLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBrumam+OBruOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGxhYmVsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbGFiZWwgb2YgdGhlIHRhYiBpdGVtLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+S4i+OBq+ihqOekuuOBleOCjOOCi+ODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhZGdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXNwbGF5IGEgbm90aWZpY2F0aW9uIGJhZGdlIG9uIHRvcCBvZiB0aGUgdGFiLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCuOOBq+ihqOekuuOBmeOCi+WGheWuueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldCB0byB0aGUgdGFiIHRoYXQgaXMgYWN0aXZlIGJ5IGRlZmF1bHQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xhYmVsJykgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSB8fCB0aGlzLmhhc0F0dHJpYnV0ZSgnYmFkZ2UnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gIH1cblxuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgX3RlbXBsYXRlTG9hZGVkKCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzSW5wdXQgPSB0aGlzLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAncmFkaW8nO1xuICAgIGNvbnN0IGhhc0J1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fYnV0dG9uJyk7XG5cbiAgICByZXR1cm4gaGFzSW5wdXQgJiYgaGFzQnV0dG9uO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3RhYi1iYXJfX2l0ZW0nKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVMb2FkZWQoKSkge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBsZXQgaGFzQ2hpbGRyZW4gPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcblxuICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgIHRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGVmYXVsdFRlbXBsYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICAvLyB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19idXR0b24nKSwgdGhpcyk7XG4gIH1cblxuICBfdXBkYXRlRGVmYXVsdFRlbXBsYXRlKCkge1xuICAgIGlmICghdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRlZmF1bHRJbm5lclRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICBpZiAoYnV0dG9uLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcbiAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpKSB7XG4gICAgICBidXR0b24uaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19pY29uJyksIGJ1dHRvbi5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKSkge1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19sYWJlbCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fYmFkZ2UnKSkge1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19iYWRnZScpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBpY29uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsYWJlbCcpO1xuICAgIGNvbnN0IGJhZGdlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2JhZGdlJyk7XG5cbiAgICBpZiAodHlwZW9mIGljb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBpY29uRWxlbWVudCA9IGdldEljb25FbGVtZW50KCk7XG4gICAgICBjb25zdCBsYXN0ID0gaWNvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpY29uJyk7XG4gICAgICBpY29uRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ljb24nLCBpY29uKTtcbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL09uc2VuVUkvT25zZW5VSS9pc3N1ZXMvMTY1NFxuICAgICAgZ2V0SWNvbkVsZW1lbnQoKS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2ljb24nLCBsYXN0LCBpY29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpO1xuICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgZ2V0TGFiZWxFbGVtZW50KCkudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFiZWwgPSBnZXRMYWJlbEVsZW1lbnQoKTtcbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICBsYWJlbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJhZGdlID09PSAnc3RyaW5nJykge1xuICAgICAgZ2V0QmFkZ2VFbGVtZW50KCkudGV4dENvbnRlbnQgPSBiYWRnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFkZ2UgPSBnZXRCYWRnZUVsZW1lbnQoKTtcbiAgICAgIGlmIChiYWRnZSkge1xuICAgICAgICBiYWRnZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gc2VsZi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJY29uRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBzZWxmLnF1ZXJ5U2VsZWN0b3IoJ29ucy1pY29uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmFkZ2VFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHNlbGYucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2JhZGdlJyk7XG4gICAgfVxuICB9XG5cbiAgX29uQ2xpY2soKSB7XG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICBpZiAodGFiYmFyKSB7XG4gICAgICB0YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuX2ZpbmRUYWJJbmRleCgpKTtcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmUoKSB7XG4gICAgY29uc3QgcmFkaW8gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKTtcbiAgICByYWRpby5jaGVja2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1pbmFjdGl2ZV0sIG9ucy10YWItaW5hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWFjdGl2ZV0sIG9ucy10YWItYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0Jyk7XG4gIH1cblxuICBzZXRJbmFjdGl2ZSgpIHtcbiAgICBjb25zdCByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICAgIHJhZGlvLmNoZWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1pbmFjdGl2ZV0sIG9ucy10YWItaW5hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnKTtcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWFjdGl2ZV0sIG9ucy10YWItYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF9sb2FkUGFnZUVsZW1lbnQocGFyZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fbG9hZGVkUGFnZSAmJiAhdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICBjb25zdCBwYWdlcyA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCkucGFnZXM7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xuICAgICAgY2FsbGJhY2socGFnZXNbaW5kZXhdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2xvYWRpbmdQYWdlKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nUGFnZS50aGVuKHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgICB0aGlzLl9sb2FkaW5nUGFnZSA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZTogdGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBwYXJlbnR9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nUGFnZTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodGhpcy5fbG9hZGVkUGFnZSk7XG4gICAgfVxuICB9XG5cbiAgX2xvYWRQYWdlKHBhZ2UsIHBhcmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudH0sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZFBhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xuXG4gICAgcmV0dXJuIHRhYmJhci5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9sb2FkZWRQYWdlKTtcbiAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9lbnN1cmVFbGVtZW50UG9zaXRpb24oKTtcblxuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSArICcgJyA6ICcnO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBwcmVmaXggKyB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSAmJiAhdGhpcy5oYXNMb2FkZWQpIHtcbiAgICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbG9hZFBhZ2VFbGVtZW50KHRhYmJhci5fY29udGVudEVsZW1lbnQsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0YWJiYXIuX2NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICB0YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuX2ZpbmRUYWJJbmRleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsIG9uUmVhZHkpO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBfZmluZFRhYmJhckVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kVGFiSW5kZXgoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMgPT09IGVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVFbGVtZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgb25zLXRhYiBlbGVtZW50IGlzIG11c3QgYmUgY2hpbGQgb2Ygb25zLXRhYmJhciBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnLCAnYmFkZ2UnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgIGNhc2UgJ2JhZGdlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYWdlJzpcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuX3BhZ2UgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWInLCBUYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAndG9vbGJhci1idXR0b24tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGFkZGluZy1hLXRvb2xiYXJcbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIG5hdmlnYXRpb24gYmFyIGF0IHRoZSB0b3Agb2YgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW4gdGhlIG5hdmlnYXRpb24gYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgQnV0dG9uXG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICA8b25zLWljb24gaWNvbj1cImlvbi1uYXZpY29uXCIgc2l6ZT1cIjI4cHhcIj48L29ucy1pY29uPlxuICogICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Rvb2xiYXItYnV0dG9uJyk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10b29sYmFyLWJ1dHRvbicsIFRvb2xiYXJCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnJhbmdlJzogJ3JhbmdlLS0qJyxcbiAgJy5yYW5nZV9fbGVmdCc6ICdyYW5nZS0tKl9fbGVmdCdcbn07XG5cbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8ZGl2PlxuICA8ZGl2IGNsYXNzPVwicmFuZ2VfX2xlZnRcIj48L2Rpdj5cbiAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwicmFuZ2VcIj5cbjwvZGl2PmApO1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWluJyxcbiAgJ25hbWUnLFxuICAncGxhY2Vob2xkZXInLFxuICAncmVhZG9ubHknLFxuICAnc2l6ZScsXG4gICdzdGVwJyxcbiAgJ3ZhbGlkYXRvcicsXG4gICd2YWx1ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJhbmdlXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc2xpZGVyWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFJhbmdlIGlucHV0IGNvbXBvbmVudC4gVXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHNsaWRlci5cbiAqXG4gKiAgICAgV29ya3MgdmVyeSBzaW1pbGFyIHRvIHRoZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4WlFvbU1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yYW5nZVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IHRleHQgaW5wdXRzLCByYWRpbyBidXR0b25zIGFuZCBjaGVja2JveGVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFuZ2UgdmFsdWU9XCIyMFwiPjwvb25zLXJhbmdlPlxuICogPG9ucy1yYW5nZSBtb2RpZmllcj1cIm1hdGVyaWFsXCIgdmFsdWU9XCIxMFwiPjwvcmFuZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcucmFuZ2VfX2xlZnQnKSAmJiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKSkpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmNoaWxkcmVuWzBdKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICB0aGlzLl9sZWZ0LnN0eWxlLndpZHRoID0gKDEwMCAqIHRoaXMuX3JhdGlvKSArICclJztcbiAgfVxuXG4gIF9vbkRyYWdzdGFydChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLmdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBnZXQgX3JhdGlvKCkge1xuICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmF0aW8uXG4gICAgY29uc3QgbWluID0gdGhpcy5faW5wdXQubWluID09PSAnJyA/IDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5taW4pO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2lucHV0Lm1heCA9PT0gJycgPyAxMDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5tYXgpO1xuXG4gICAgcmV0dXJuICh0aGlzLnZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdtaW4nIHx8IG5hbWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdzdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnc3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9sZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yYW5nZV9fbGVmdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcbiAgICAgID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgIDogdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yYW5nZScsIFJhbmdlRWxlbWVudCk7XG4iLCJpbXBvcnQgb25zIGZyb20gJy4vb25zL29ucyc7XG5cbmltcG9ydCBUZW1wbGF0ZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtdGVtcGxhdGUnO1xuaW1wb3J0IElmRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1pZic7XG5pbXBvcnQgQWxlcnREaWFsb2dFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZyc7XG5pbXBvcnQgQmFja0J1dHRvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYmFjay1idXR0b24nO1xuaW1wb3J0IEJvdHRvbVRvb2xiYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcbmltcG9ydCBCdXR0b25FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWJ1dHRvbic7XG5pbXBvcnQgQ2Fyb3VzZWxJdGVtRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtJztcbmltcG9ydCBDYXJvdXNlbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtY2Fyb3VzZWwnO1xuaW1wb3J0IENvbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtY29sJztcbmltcG9ydCBEaWFsb2dFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XG5pbXBvcnQgRmFiRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1mYWInO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgSWNvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtaWNvbic7XG5pbXBvcnQgTGF6eVJlcGVhdEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQnO1xuaW1wb3J0IExpc3RIZWFkZXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyJztcbmltcG9ydCBMaXN0SXRlbUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtbGlzdC1pdGVtJztcbmltcG9ydCBMaXN0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1saXN0JztcbmltcG9ydCBJbnB1dEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtaW5wdXQnO1xuaW1wb3J0IE1vZGFsRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1tb2RhbCc7XG5pbXBvcnQgTmF2aWdhdG9yRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xuaW1wb3J0IFBhZ2VFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXBhZ2UnO1xuaW1wb3J0IFBvcG92ZXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXBvcG92ZXInO1xuaW1wb3J0IFByb2dyZXNzQmFyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXInO1xuaW1wb3J0IFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyJztcbmltcG9ydCBQdWxsSG9va0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcHVsbC1ob29rJztcbmltcG9ydCBSaXBwbGVFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXJpcHBsZSc7XG5pbXBvcnQgUm93RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1yb3cnO1xuaW1wb3J0IFNwZWVkRGlhbEl0ZW1FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbSc7XG5pbXBvcnQgU3BlZWREaWFsRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsJztcbmltcG9ydCBTcGxpdHRlckNvbnRlbnRFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQnO1xuaW1wb3J0IFNwbGl0dGVyTWFza0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzayc7XG5pbXBvcnQgU3BsaXR0ZXJTaWRlRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlJztcbmltcG9ydCBTcGxpdHRlckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXInO1xuaW1wb3J0IFN3aXRjaEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3dpdGNoJztcbmltcG9ydCBUYWJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXRhYic7XG5pbXBvcnQgVGFiYmFyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10YWJiYXInO1xuaW1wb3J0IFRvb2xiYXJCdXR0b25FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uJztcbmltcG9ydCBUb29sYmFyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10b29sYmFyJztcbmltcG9ydCBSYW5nZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcmFuZ2UnO1xuXG5vbnMuVGVtcGxhdGVFbGVtZW50ID0gVGVtcGxhdGVFbGVtZW50O1xub25zLklmRWxlbWVudCA9IElmRWxlbWVudDtcbm9ucy5BbGVydERpYWxvZ0VsZW1lbnQgPSBBbGVydERpYWxvZ0VsZW1lbnQ7XG5vbnMuQmFja0J1dHRvbkVsZW1lbnQgPSBCYWNrQnV0dG9uRWxlbWVudDtcbm9ucy5Cb3R0b21Ub29sYmFyRWxlbWVudCA9IEJvdHRvbVRvb2xiYXJFbGVtZW50O1xub25zLkJ1dHRvbkVsZW1lbnQgPSBCdXR0b25FbGVtZW50O1xub25zLkNhcm91c2VsSXRlbUVsZW1lbnQgPSBDYXJvdXNlbEl0ZW1FbGVtZW50O1xub25zLkNhcm91c2VsRWxlbWVudCA9IENhcm91c2VsRWxlbWVudDtcbm9ucy5Db2xFbGVtZW50ID0gQ29sRWxlbWVudDtcbm9ucy5EaWFsb2dFbGVtZW50ID0gRGlhbG9nRWxlbWVudDtcbm9ucy5GYWJFbGVtZW50ID0gRmFiRWxlbWVudDtcbm9ucy5HZXN0dXJlRGV0ZWN0b3JFbGVtZW50ID0gR2VzdHVyZURldGVjdG9yRWxlbWVudDtcbm9ucy5JY29uRWxlbWVudCA9IEljb25FbGVtZW50O1xub25zLkxhenlSZXBlYXRFbGVtZW50ID0gTGF6eVJlcGVhdEVsZW1lbnQ7XG5vbnMuTGlzdEhlYWRlckVsZW1lbnQgPSBMaXN0SGVhZGVyRWxlbWVudDtcbm9ucy5MaXN0SXRlbUVsZW1lbnQgPSBMaXN0SXRlbUVsZW1lbnQ7XG5vbnMuTGlzdEVsZW1lbnQgPSBMaXN0RWxlbWVudDtcbm9ucy5JbnB1dEVsZW1lbnQgPSBJbnB1dEVsZW1lbnQ7XG5vbnMuTW9kYWxFbGVtZW50ID0gTW9kYWxFbGVtZW50O1xub25zLk5hdmlnYXRvckVsZW1lbnQgPSBOYXZpZ2F0b3JFbGVtZW50O1xub25zLlBhZ2VFbGVtZW50ID0gUGFnZUVsZW1lbnQ7XG5vbnMuUG9wb3ZlckVsZW1lbnQgPSBQb3BvdmVyRWxlbWVudDtcbm9ucy5Qcm9ncmVzc0JhckVsZW1lbnQgPSBQcm9ncmVzc0JhckVsZW1lbnQ7XG5vbnMuUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgPSBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudDtcbm9ucy5QdWxsSG9va0VsZW1lbnQgPSBQdWxsSG9va0VsZW1lbnQ7XG5vbnMuUmlwcGxlRWxlbWVudCA9IFJpcHBsZUVsZW1lbnQ7XG5vbnMuUm93RWxlbWVudCA9IFJvd0VsZW1lbnQ7XG5vbnMuU3BlZWREaWFsSXRlbUVsZW1lbnQgPSBTcGVlZERpYWxJdGVtRWxlbWVudDtcbm9ucy5TcGVlZERpYWxFbGVtZW50ID0gU3BlZWREaWFsRWxlbWVudDtcbm9ucy5TcGxpdHRlckNvbnRlbnRFbGVtZW50ID0gU3BsaXR0ZXJDb250ZW50RWxlbWVudDtcbm9ucy5TcGxpdHRlck1hc2tFbGVtZW50ID0gU3BsaXR0ZXJNYXNrRWxlbWVudDtcbm9ucy5TcGxpdHRlclNpZGVFbGVtZW50ID0gU3BsaXR0ZXJTaWRlRWxlbWVudDtcbm9ucy5TcGxpdHRlckVsZW1lbnQgPSBTcGxpdHRlckVsZW1lbnQ7XG5vbnMuU3dpdGNoRWxlbWVudCA9IFN3aXRjaEVsZW1lbnQ7XG5vbnMuVGFiRWxlbWVudCA9IFRhYkVsZW1lbnQ7XG5vbnMuVGFiYmFyRWxlbWVudCA9IFRhYmJhckVsZW1lbnQ7XG5vbnMuVG9vbGJhckJ1dHRvbkVsZW1lbnQgPSBUb29sYmFyQnV0dG9uRWxlbWVudDtcbm9ucy5Ub29sYmFyRWxlbWVudCA9IFRvb2xiYXJFbGVtZW50O1xub25zLlJhbmdlRWxlbWVudCA9IFJhbmdlRWxlbWVudDtcblxuLy8gZmFzdGNsaWNrXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcbn0sIGZhbHNlKTtcblxuLy8gb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xuICAgIG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICB9KTtcbiAgZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSk7XG59LCBmYWxzZSk7XG5cbi8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcbm9ucy5yZWFkeShmdW5jdGlvbigpIHtcbiAgb25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMoKTtcbn0pO1xuXG4vLyB2aWV3cG9ydC5qc1xubmV3IFZpZXdwb3J0KCkuc2V0dXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl19
